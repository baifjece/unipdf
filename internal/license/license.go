//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package license

import (
	//_e "bytes"
	//_bgb "compress/gzip"
	//_bf "crypto"
	//_af "crypto/aes"
	//_df "crypto/cipher"
	//_eg "crypto/hmac"
	//_cab "crypto/rand"
	//_dg "crypto/rsa"
	//_ea "crypto/sha256"
	//_fbc "crypto/sha512"
	//_fb "crypto/x509"
	//_f "encoding/base64"
	//_ef "encoding/hex"
	//_ge "encoding/json"
	//_ab "encoding/pem"
	//_g "errors"
	//_bgg "fmt"
	//_fc "github.com/unidoc/unipdf/v3/common"
	//_bg "io"
	//_ca "net"
	//_bb "net/http"
	//_cb "os"
	//_d "path/filepath"
	//_bga "sort"
	//_a "strings"
	//_c "sync"
	_gd "time"
)

var _fe = _gd.Date(2019, 6, 6, 0, 0, 0, 0, _gd.UTC)

func (_gfg *LicenseKey) ToString() string {
	return ""
	//if _gfg._fd {
	//	return "Metered subscription"
	//}
	//_gcg := _bgg.Sprintf("License Id: %s	", _gfg.LicenseId)
	//_gcg += _bgg.Sprintf("Customer Id: %s	", _gfg.CustomerId)
	//_gcg += _bgg.Sprintf("Customer Name: %s	", _gfg.CustomerName)
	//_gcg += _bgg.Sprintf("Tier: %s\n", _gfg.Tier)
	//_gcg += _bgg.Sprintf("Created At: %s	", _fc.UtcTimeFormat(_gfg.CreatedAt))
	//if _gfg.ExpiresAt == nil {
	//	_gcg += "Expires At: Never		"
	//} else {
	//	_gcg += _bgg.Sprintf("Expires At: %s		", _fc.UtcTimeFormat(*_gfg.ExpiresAt))
	//}
	//_gcg += _bgg.Sprintf("Creator: %s <%s>	", _gfg.CreatorName, _gfg.CreatorEmail)
	//return _gcg
}
//
//type meteredUsageCheckinForm struct {
//	Instance          string         `json:"inst"`
//	Next              string         `json:"next"`
//	UsageNumber       int            `json:"usage_number"`
//	NumFailed         int64          `json:"num_failed"`
//	Hostname          string         `json:"hostname"`
//	LocalIP           string         `json:"local_ip"`
//	MacAddress        string         `json:"mac_address"`
//	Package           string         `json:"package"`
//	PackageVersion    string         `json:"package_version"`
//	Usage             map[string]int `json:"u"`
//	IsPersistentCache bool           `json:"is_persistent_cache"`
//	Timestamp         int64          `json:"timestamp"`
//	UsageLogs         []interface{}  `json:"ul,omitempty"`
//}
//
//type meteredUsageCheckinResp struct {
//	Instance      string `json:"inst"`
//	Next          string `json:"next"`
//	Success       bool   `json:"success"`
//	Message       string `json:"message"`
//	RemainingDocs int    `json:"rd"`
//	LimitDocs     bool   `json:"ld"`
//}
//
//func GetMeteredState() (MeteredStatus, error) {
//	if _cfd == nil {
//		return MeteredStatus{}, _g.New("license key not set")
//	}
//	if !_cfd._fd || len(_cfd._faba) == 0 {
//		return MeteredStatus{}, _g.New("api key not set")
//	}
//	_ebc, _dfab := _ged.loadState(_cfd._faba)
//	if _dfab != nil {
//		_fc.Log.Debug("ERROR: %v", _dfab)
//		return MeteredStatus{}, _dfab
//	}
//	if _ebc.Docs > 0 {
//		_bbc := _bca("", "", "", true)
//		if _bbc != nil {
//			return MeteredStatus{}, _bbc
//		}
//	}
//	_gdba.Lock()
//	defer _gdba.Unlock()
//	_dc := _efgg()
//	_dc._bed = _cfd._faba
//	_cad, _dfab := _dc.getStatus()
//	if _dfab != nil {
//		return MeteredStatus{}, _dfab
//	}
//	if !_cad.Valid {
//		return MeteredStatus{}, _g.New("key not valid")
//	}
//	_dec := MeteredStatus{OK: true, Credits: _cad.OrgCredits, Used: _cad.OrgUsed}
//	return _dec, nil
//}
//
type LicenseKey struct {
	LicenseId    string    `json:"license_id"`
	CustomerId   string    `json:"customer_id"`
	CustomerName string    `json:"customer_name"`
	Tier         string    `json:"tier"`
	CreatedAt    _gd.Time  `json:"-"`
	CreatedAtInt int64     `json:"created_at"`
	ExpiresAt    *_gd.Time `json:"-"`
	ExpiresAtInt int64     `json:"expires_at"`
	CreatedBy    string    `json:"created_by"`
	CreatorName  string    `json:"creator_name"`
	CreatorEmail string    `json:"creator_email"`
	UniPDF       bool      `json:"unipdf"`
	UniOffice    bool      `json:"unioffice"`
	UniHTML      bool      `json:"unihtml"`
	Trial        bool      `json:"trial"`
	_fd          bool
	_faba        string
	_fda         bool
	_cd          bool
}
//
//var _aeg map[string]struct{}
//
//func _efgg() *meteredClient {
//	_cde := meteredClient{_egb: "https://cloud.unidoc.io/api", _ffg: &_bb.Client{Timeout: 30 * _gd.Second}}
//	if _egf := _cb.Getenv("UNIDOC_LICENSE_SERVER_URL"); _a.HasPrefix(_egf, "http") {
//		_cde._egb = _egf
//	}
//	return &_cde
//}
//
//func _bbcf() (string, error) {
//	_eebd := _a.TrimSpace(_cb.Getenv(_gfc))
//	if _eebd == "" {
//		_fc.Log.Debug("$%s environment variable not found. Will use home directory to store license information.", _gfc)
//		_adcb := _fge()
//		if len(_adcb) == 0 {
//			return "", _bgg.Errorf("required $%s environment variable or home directory not found", _gfc)
//		}
//		_eebd = _d.Join(_adcb, ".unidoc")
//	}
//	_ggce := _cb.MkdirAll(_eebd, 0777)
//	if _ggce != nil {
//		return "", _ggce
//	}
//	return _eebd, nil
//}
//
//func _cae(_eaa *_bb.Response) (_bg.ReadCloser, error) {
//	var _egea error
//	var _fgb _bg.ReadCloser
//	switch _a.ToLower(_eaa.Header.Get("Content-Encoding")) {
//	case "gzip":
//		_fgb, _egea = _bgb.NewReader(_eaa.Body)
//		if _egea != nil {
//			return _fgb, _egea
//		}
//		defer _fgb.Close()
//	default:
//		_fgb = _eaa.Body
//	}
//	return _fgb, nil
//}
//
//func _feb() ([]string, []string, error) {
//	_gcaf, _bgbb := _ca.Interfaces()
//	if _bgbb != nil {
//		return nil, nil, _bgbb
//	}
//	var _fdfg []string
//	var _gcae []string
//	for _, _cdg := range _gcaf {
//		if _cdg.Flags&_ca.FlagUp == 0 || _e.Equal(_cdg.HardwareAddr, nil) {
//			continue
//		}
//		_ead, _cba := _cdg.Addrs()
//		if _cba != nil {
//			return nil, nil, _cba
//		}
//		_ffb := 0
//		for _, _gga := range _ead {
//			var _gfa _ca.IP
//			switch _cef := _gga.(type) {
//			case *_ca.IPNet:
//				_gfa = _cef.IP
//			case *_ca.IPAddr:
//				_gfa = _cef.IP
//			}
//			if _gfa.IsLoopback() {
//				continue
//			}
//			if _gfa.To4() == nil {
//				continue
//			}
//			_gcae = append(_gcae, _gfa.String())
//			_ffb++
//		}
//		_ded := _cdg.HardwareAddr.String()
//		if _ded != "" && _ffb > 0 {
//			_fdfg = append(_fdfg, _ded)
//		}
//	}
//	return _fdfg, _gcae, nil
//}
//
//type stateLoader interface {
//	loadState(_fgg string) (reportState, error)
//	updateState(_ecg, _efcc, _ecf string, _agc int, _aceb bool, _gdd int, _dgb int, _bbb _gd.Time, _eeb map[string]int, _dcc ...interface{}) error
//}
//
//var _gdba = &_c.Mutex{}
//
//type defaultStateHolder struct{}
//
//func _ege(_ace string, _ag string, _def string) (string, error) {
//	_bfb := _a.Index(_def, _ace)
//	if _bfb == -1 {
//		return "", _bgg.Errorf("header not found")
//	}
//	_cbg := _a.Index(_def, _ag)
//	if _cbg == -1 {
//		return "", _bgg.Errorf("footer not found")
//	}
//	_gf := _bfb + len(_ace) + 1
//	return _def[_gf : _cbg-1], nil
//}
//
//func SetMeteredKey(apiKey string) error {
//	if len(apiKey) == 0 {
//		_fc.Log.Error("Metered License API Key must not be empty")
//		_fc.Log.Error("- Grab one in the Free Tier at https://cloud.unidoc.io")
//		return _bgg.Errorf("metered license api key must not be empty: create one at https://cloud.unidoc.io")
//	}
//	if _cfd != nil && (_cfd._fd || _cfd.Tier != LicenseTierUnlicensed) {
//		_fc.Log.Error("ERROR: Cannot set license key twice - Should just initialize once")
//		return _g.New("license key already set")
//	}
//	_faf := _efgg()
//	_faf._bed = apiKey
//	_ga, _dfb := _faf.getStatus()
//	if _dfb != nil {
//		return _dfb
//	}
//	if !_ga.Valid {
//		return _g.New("key not valid")
//	}
//	_bbe := &LicenseKey{_fd: true, _faba: apiKey, _fda: true}
//	_cfd = _bbe
//	return nil
//}
//
//type MeteredStatus struct {
//	OK      bool
//	Credits int64
//	Used    int64
//}
//
//func SetMeteredKeyUsageLogVerboseMode(val bool) { _cfd._cd = val }
//
//var _baf = _gd.Date(2010, 1, 1, 0, 0, 0, 0, _gd.UTC)
//
//func _efc(_gec string, _be []byte) (string, error) {
//	_cg, _ := _ab.Decode([]byte(_gec))
//	if _cg == nil {
//		return "", _bgg.Errorf("PrivKey failed")
//	}
//	_ba, _bc := _fb.ParsePKCS1PrivateKey(_cg.Bytes)
//	if _bc != nil {
//		return "", _bc
//	}
//	_eb := _fbc.New()
//	_eb.Write(_be)
//	_gc := _eb.Sum(nil)
//	_ff, _bc := _dg.SignPKCS1v15(_cab.Reader, _ba, _bf.SHA512, _gc)
//	if _bc != nil {
//		return "", _bc
//	}
//	_efg := _f.StdEncoding.EncodeToString(_be)
//	_efg += "	+		"
//	_efg += _f.StdEncoding.EncodeToString(_ff)
//	return _efg, nil
//}
//
//func (_gef *meteredClient) checkinUsage(_bdf meteredUsageCheckinForm) (meteredUsageCheckinResp, error) {
//	_bdf.Package = "unipdf"
//	_bdf.PackageVersion = _fc.Version
//	var _ega meteredUsageCheckinResp
//	_ebaf := _gef._egb + "/metered/usage_checkin"
//	_gfe, _cga := _ge.Marshal(_bdf)
//	if _cga != nil {
//		return _ega, _cga
//	}
//	_eaf, _cga := _geed(_gfe)
//	if _cga != nil {
//		return _ega, _cga
//	}
//	_ggc, _cga := _bb.NewRequest("POST", _ebaf, _eaf)
//	if _cga != nil {
//		return _ega, _cga
//	}
//	_ggc.Header.Add("Content-Type", "application/json")
//	_ggc.Header.Add("Content-Encoding", "gzip")
//	_ggc.Header.Add("Accept-Encoding", "gzip")
//	_ggc.Header.Add("X-API-KEY", _gef._bed)
//	_bgc, _cga := _gef._ffg.Do(_ggc)
//	if _cga != nil {
//		return _ega, _cga
//	}
//	defer _bgc.Body.Close()
//	if _bgc.StatusCode != 200 {
//		_aa, _babg := _cge(_bgc)
//		if _babg != nil {
//			return _ega, _babg
//		}
//		_babg = _ge.Unmarshal(_aa, &_ega)
//		if _babg != nil {
//			return _ega, _babg
//		}
//		return _ega, _bgg.Errorf("failed to checkin, status code is: %d", _bgc.StatusCode)
//	}
//	_gefd := _bgc.Header.Get("X-UC-Signature")
//	_fccg := _dad(_bdf.MacAddress, string(_gfe))
//	if _fccg != _gefd {
//		_fc.Log.Error("Invalid response signature, set the license server to https://cloud.unidoc.io/api")
//		return _ega, _g.New("failed to checkin, invalid server response")
//	}
//	_gdb, _cga := _cge(_bgc)
//	if _cga != nil {
//		return _ega, _cga
//	}
//	_cga = _ge.Unmarshal(_gdb, &_ega)
//	if _cga != nil {
//		return _ega, _cga
//	}
//	return _ega, nil
//}
//
//func _geed(_bgd []byte) (_bg.Reader, error) {
//	_eecb := new(_e.Buffer)
//	_gfgd := _bgb.NewWriter(_eecb)
//	_gfgd.Write(_bgd)
//	_cgaa := _gfgd.Close()
//	if _cgaa != nil {
//		return nil, _cgaa
//	}
//	return _eecb, nil
//}
//
//func _ae(_fg string) (LicenseKey, error) {
//	var _ddf LicenseKey
//	_bce, _gce := _ege(_ac, _afc, _fg)
//	if _gce != nil {
//		return _ddf, _gce
//	}
//	_dgf, _gce := _egc(_bbdf, _bce)
//	if _gce != nil {
//		return _ddf, _gce
//	}
//	_gce = _ge.Unmarshal(_dgf, &_ddf)
//	if _gce != nil {
//		return _ddf, _gce
//	}
//	_ddf.CreatedAt = _gd.Unix(_ddf.CreatedAtInt, 0)
//	if _ddf.ExpiresAtInt > 0 {
//		_gecf := _gd.Unix(_ddf.ExpiresAtInt, 0)
//		_ddf.ExpiresAt = &_gecf
//	}
//	return _ddf, nil
//}
//
//var _eda map[string]int
//
//type meteredClient struct {
//	_egb string
//	_bed string
//	_ffg *_bb.Client
//}
//
//const _geg = "UNIPDF_LICENSE_PATH"
//
//func _bca(_acd string, _afa string, _bee string, _abf bool) error {
//	if _cfd == nil {
//		return _g.New("no license key")
//	}
//	if !_cfd._fd || len(_cfd._faba) == 0 {
//		return nil
//	}
//	if len(_acd) == 0 && !_abf {
//		return _g.New("docKey not set")
//	}
//	_gdba.Lock()
//	defer _gdba.Unlock()
//	if _aeg == nil {
//		_aeg = map[string]struct{}{}
//	}
//	if _eda == nil {
//		_eda = map[string]int{}
//	}
//	_dbe := 0
//	if len(_acd) > 0 {
//		_, _bec := _aeg[_acd]
//		if !_bec {
//			_aeg[_acd] = struct{}{}
//			_dbe++
//		}
//		if _cfd._cd {
//			_cac = append(_cac, map[string]interface{}{"time": _gd.Now().String(), "func": _afa, "ref": _acd[:8], "file": _bee, "cost": _dbe})
//			if _bec && _dbe == 0 {
//				_fc.Log.Info("%s Ref: %s | %s | No credit used", _gd.Now().String(), _acd[:8], _afa)
//			}
//		}
//	}
//	if _dbe == 0 && !_abf {
//		return nil
//	}
//	_eda[_afa]++
//	_gbf := _gd.Now()
//	_cbe, _fdf := _ged.loadState(_cfd._faba)
//	if _fdf != nil {
//		_fc.Log.Debug("ERROR: %v", _fdf)
//		return _fdf
//	}
//	_cbe.UsageLogs = append(_cbe.UsageLogs, _cac...)
//	if _cbe.Usage == nil {
//		_cbe.Usage = map[string]int{}
//	}
//	for _ceb, _debg := range _eda {
//		if _ceb != "" {
//			_cbe.Usage[_ceb] += _debg
//		}
//	}
//	_eda = nil
//	const _adg = 24 * _gd.Hour
//	const _dfe = 3 * 24 * _gd.Hour
//	if len(_cbe.Instance) == 0 || _gbf.Sub(_cbe.LastReported) > _adg || (_cbe.LimitDocs && _cbe.RemainingDocs <= _cbe.Docs+int64(_dbe)) || _abf {
//		_bge, _dgfa := _cb.Hostname()
//		if _dgfa != nil {
//			return _dgfa
//		}
//		_bcg := _cbe.Docs
//		_efccc, _fef, _dgfa := _feb()
//		if _dgfa != nil {
//			_fc.Log.Debug("Unable to get local address: %s", _dgfa.Error())
//			_efccc = append(_efccc, "information not available")
//			_fef = append(_fef, "information not available")
//		} else {
//			_bga.Strings(_fef)
//			_bga.Strings(_efccc)
//			_gfbc, _edb := _bfd()
//			if _edb != nil {
//				return _edb
//			}
//			_edd := false
//			for _, _gcb := range _fef {
//				if _gcb == _gfbc.String() {
//					_edd = true
//				}
//			}
//			if !_edd {
//				_fef = append(_fef, _gfbc.String())
//			}
//		}
//		_ebd := _efgg()
//		_ebd._bed = _cfd._faba
//		_bcg += int64(_dbe)
//		_agg := meteredUsageCheckinForm{Instance: _cbe.Instance, Next: _cbe.Next, UsageNumber: int(_bcg), NumFailed: _cbe.NumErrors, Hostname: _bge, LocalIP: _a.Join(_fef, ", "), MacAddress: _a.Join(_efccc, ", "), Package: "unipdf", PackageVersion: _fc.Version, Usage: _cbe.Usage, IsPersistentCache: _cfd._fda, Timestamp: _gbf.Unix()}
//		if len(_efccc) == 0 {
//			_agg.MacAddress = "none"
//		}
//		if _cfd._cd {
//			_agg.UsageLogs = _cbe.UsageLogs
//		}
//		_dbg := int64(0)
//		_adga := _cbe.NumErrors
//		_fee := _gbf
//		_bbd := 0
//		_cdc := _cbe.LimitDocs
//		_gefg, _dgfa := _ebd.checkinUsage(_agg)
//		if _dgfa != nil {
//			if _gbf.Sub(_cbe.LastReported) > _dfe {
//				if !_gefg.Success {
//					return _g.New(_gefg.Message)
//				}
//				return _g.New("too long since last successful checkin")
//			}
//			_dbg = _bcg
//			_adga++
//			_fee = _cbe.LastReported
//		} else {
//			_cdc = _gefg.LimitDocs
//			_bbd = _gefg.RemainingDocs
//			_adga = 0
//		}
//		if len(_gefg.Instance) == 0 {
//			_gefg.Instance = _agg.Instance
//		}
//		if len(_gefg.Next) == 0 {
//			_gefg.Next = _agg.Next
//		}
//		_dgfa = _ged.updateState(_ebd._bed, _gefg.Instance, _gefg.Next, int(_dbg), _cdc, _bbd, int(_adga), _fee, nil)
//		if _dgfa != nil {
//			return _dgfa
//		}
//		if !_gefg.Success {
//			return _bgg.Errorf("error: %s", _gefg.Message)
//		}
//	} else {
//		_fdf = _ged.updateState(_cfd._faba, _cbe.Instance, _cbe.Next, int(_cbe.Docs)+_dbe, _cbe.LimitDocs, int(_cbe.RemainingDocs), int(_cbe.NumErrors), _cbe.LastReported, _cbe.Usage, _cbe.UsageLogs...)
//		if _fdf != nil {
//			return _fdf
//		}
//	}
//	if _cfd._cd && len(_acd) > 0 {
//		_gfd := ""
//		if _bee != "" {
//			_gfd = _bgg.Sprintf("File %s |", _bee)
//		}
//		_fc.Log.Info("%s | %s Ref: %s | %s | %d credit(s) used", _gbf.String(), _gfd, _acd[:8], _afa, _dbe)
//	}
//	return nil
//}
//
//var _ged stateLoader = defaultStateHolder{}
//
//func _egc(_fcf string, _ce string) ([]byte, error) {
//	var (
//		_dfa int
//		_ad  string
//	)
//	for _, _ad = range []string{"		+			", "		+\r		", " + "} {		if _dfa = _a.Index(_ce, _ad); _dfa != -1 {
//		break
//	}
//	}
//	if _dfa == -1 {
//		return nil, _bgg.Errorf("invalid input, signature separator")
//	}
//	_ffc := _ce[:_dfa]
//	_dd := _dfa + len(_ad)
//	_ed := _ce[_dd:]
//	if _ffc == "" || _ed == "" {
//		return nil, _bgg.Errorf("invalid input, missing original or signature")
//	}
//	_baa, _fa := _f.StdEncoding.DecodeString(_ffc)
//	if _fa != nil {
//		return nil, _bgg.Errorf("invalid input original")
//	}
//	_bag, _fa := _f.StdEncoding.DecodeString(_ed)
//	if _fa != nil {
//		return nil, _bgg.Errorf("invalid input signature")
//	}
//	_acg, _ := _ab.Decode([]byte(_fcf))
//	if _acg == nil {
//		return nil, _bgg.Errorf("PubKey failed")
//	}
//	_fcc, _fa := _fb.ParsePKIXPublicKey(_acg.Bytes)
//	if _fa != nil {
//		return nil, _fa
//	}
//	_fcd := _fcc.(*_dg.PublicKey)
//	if _fcd == nil {
//		return nil, _bgg.Errorf("PubKey conversion failed")
//	}
//	_fab := _fbc.New()
//	_fab.Write(_baa)
//	_da := _fab.Sum(nil)
//	_fa = _dg.VerifyPKCS1v15(_fcd, _bf.SHA512, _da, _bag)
//	if _fa != nil {
//		return nil, _fa
//	}
//	return _baa, nil
//}
//
//func _fdae(_cfg, _daee []byte) ([]byte, error) {
//	_bdc := make([]byte, _f.URLEncoding.DecodedLen(len(_daee)))
//	_bcea, _fcdc := _f.URLEncoding.Decode(_bdc, _daee)
//	if _fcdc != nil {
//		return nil, _fcdc
//	}
//	_bdc = _bdc[:_bcea]
//	_agd, _fcdc := _af.NewCipher(_cfg)
//	if _fcdc != nil {
//		return nil, _fcdc
//	}
//	if len(_bdc) < _af.BlockSize {
//		return nil, _g.New("ciphertext too short")
//	}
//	_ggb := _bdc[:_af.BlockSize]
//	_bdc = _bdc[_af.BlockSize:]
//	_bac := _df.NewCFBDecrypter(_agd, _ggb)
//	_bac.XORKeyStream(_bdc, _bdc)
//	return _bdc, nil
//}
//
//var _cac []interface{}
//
//func (_gg *meteredClient) getStatus() (meteredStatusResp, error) {
//	var _eba meteredStatusResp
//	_cf := _gg._egb + "/metered/status"
//	var _cfe meteredStatusForm
//	_aec, _ee := _ge.Marshal(_cfe)
//	if _ee != nil {
//		return _eba, _ee
//	}
//	_bab, _ee := _geed(_aec)
//	if _ee != nil {
//		return _eba, _ee
//	}
//	_deb, _ee := _bb.NewRequest("POST", _cf, _bab)
//	if _ee != nil {
//		return _eba, _ee
//	}
//	_deb.Header.Add("Content-Type", "application/json")
//	_deb.Header.Add("Content-Encoding", "gzip")
//	_deb.Header.Add("Accept-Encoding", "gzip")
//	_deb.Header.Add("X-API-KEY", _gg._bed)
//	_gfb, _ee := _gg._ffg.Do(_deb)
//	if _ee != nil {
//		return _eba, _ee
//	}
//	defer _gfb.Body.Close()
//	if _gfb.StatusCode != 200 {
//		return _eba, _bgg.Errorf("failed to checkin, status code is: %d", _gfb.StatusCode)
//	}
//	_efgc, _ee := _cge(_gfb)
//	if _ee != nil {
//		return _eba, _ee
//	}
//	_ee = _ge.Unmarshal(_efgc, &_eba)
//	if _ee != nil {
//		return _eba, _ee
//	}
//	return _eba, nil
//}
//
//func (_ec *LicenseKey) isExpired() bool {
//	return _ec.getExpiryDateToCompare().After(*_ec.ExpiresAt)
//}
//
//var _bd = _gd.Date(2020, 1, 1, 0, 0, 0, 0, _gd.UTC)
//
//func (_gdc *LicenseKey) Validate() error {
//	if _gdc._fd {
//		return nil
//	}
//	if len(_gdc.LicenseId) < 10 {
//		return _bgg.Errorf("invalid license: License Id")
//	}
//	if len(_gdc.CustomerId) < 10 {
//		return _bgg.Errorf("invalid license: Customer Id")
//	}
//	if len(_gdc.CustomerName) < 1 {
//		return _bgg.Errorf("invalid license: Customer Name")
//	}
//	if _baf.After(_gdc.CreatedAt) {
//		return _bgg.Errorf("invalid license: Created At is invalid")
//	}
//	if _gdc.ExpiresAt == nil {
//		_fgc := _gdc.CreatedAt.AddDate(1, 0, 0)
//		if _bd.After(_fgc) {
//			_fgc = _bd
//		}
//		_gdc.ExpiresAt = &_fgc
//	}
//	if _gdc.CreatedAt.After(*_gdc.ExpiresAt) {
//		return _bgg.Errorf("invalid license: Created At cannot be Greater than Expires At")
//	}
//	if _gdc.isExpired() {
//		_daa := "The license has already expired.		" + "You may need to update the license key to the newest license key for your organization.		" + "To find your newest license key, go to https://cloud.unidoc.io and go to the license menu."
//		return _bgg.Errorf("invalid license: %s", _daa)
//	}
//	if len(_gdc.CreatorName) < 1 {
//		return _bgg.Errorf("invalid license: Creator name")
//	}
//	if len(_gdc.CreatorEmail) < 1 {
//		return _bgg.Errorf("invalid license: Creator email")
//	}
//	if _gdc.CreatedAt.After(_fe) {
//		if !_gdc.UniPDF {
//			return _bgg.Errorf("invalid license: This UniDoc key is invalid for UniPDF")
//		}
//	}
//	return nil
//}
//
//type meteredStatusForm struct{}
//
//func (_cbb *LicenseKey) getExpiryDateToCompare() _gd.Time {
//	if _cbb.Trial {
//		return _gd.Now().UTC()
//	}
//	return _fc.ReleasedAt
//}

func TrackUse(useKey string) {
	//if _cfd == nil {
	//	return
	//}
	//if !_cfd._fd || len(_cfd._faba) == 0 {
	//	return
	//}
	//if len(useKey) == 0 {
	//	return
	//}
	//_gdba.Lock()
	//defer _gdba.Unlock()
	//if _eda == nil {
	//	_eda = map[string]int{}
	//}
	//_eda[useKey]++
}
//
var _cfd = MakeUnlicensedKey()
//
//const (
//	_ac  = "-----BEGIN UNIDOC LICENSE KEY-----"
//	_afc = "-----END UNIDOC LICENSE KEY-----"
//)

func Track(docKey string, useKey string, docName string) error {
	return nil
	//return _bca(docKey, useKey, docName, !_cfd._fda)
}
//
//const _eec = "UNIPDF_CUSTOMER_NAME"
//
//func (_bae defaultStateHolder) updateState(_gab, _dca, _gca string, _bea int, _fde bool, _fec int, _db int, _aeb _gd.Time, _eca map[string]int, _age ...interface{}) error {
//	_dcag, _aag := _bbcf()
//	if _aag != nil {
//		return _aag
//	}
//	if len(_gab) < 20 {
//		return _g.New("invalid key")
//	}
//	_dcae := []byte(_gab)
//	_fecd := _fbc.Sum512_256(_dcae[:20])
//	_bba := _ef.EncodeToString(_fecd[:])
//	_bgbg := _d.Join(_dcag, _bba)
//	var _fafb reportState
//	_fafb.Docs = int64(_bea)
//	_fafb.NumErrors = int64(_db)
//	_fafb.LimitDocs = _fde
//	_fafb.RemainingDocs = int64(_fec)
//	_fafb.LastWritten = _gd.Now().UTC()
//	_fafb.LastReported = _aeb
//	_fafb.Instance = _dca
//	_fafb.Next = _gca
//	_fafb.Usage = _eca
//	_fafb.UsageLogs = _age
//	_aea, _aag := _ge.Marshal(_fafb)
//	if _aag != nil {
//		return _aag
//	}
//	const _gb = "ha9NK8]RbL*m4LKW"
//	_aea, _aag = _eged([]byte(_gb), _aea)
//	if _aag != nil {
//		return _aag
//	}
//	_aag = _cb.WriteFile(_bgbg, _aea, 0600)
//	if _aag != nil {
//		return _aag
//	}
//	return nil
//}
//
//func SetMeteredKeyPersistentCache(val bool) { _cfd._fda = val }
//
//type meteredStatusResp struct {
//	Valid        bool  `json:"valid"`
//	OrgCredits   int64 `json:"org_credits"`
//	OrgUsed      int64 `json:"org_used"`
//	OrgRemaining int64 `json:"org_remaining"`
//}
//
//const _gfc = "UNIDOC_LICENSE_DIR"

func (_bcf *LicenseKey) IsLicensed() bool {
	return true
	//return _bcf .Tier !=LicenseTierUnlicensed ||_bcf ._fd
}
//
//func (_afd defaultStateHolder) loadState(_ddff string) (reportState, error) {
//	_ggd, _ebad := _bbcf()
//	if _ebad != nil {
//		return reportState{}, _ebad
//	}
//	_ebad = _cb.MkdirAll(_ggd, 0777)
//	if _ebad != nil {
//		return reportState{}, _ebad
//	}
//	if len(_ddff) < 20 {
//		return reportState{}, _g.New("invalid key")
//	}
//	_aecc := []byte(_ddff)
//	_aba := _fbc.Sum512_256(_aecc[:20])
//	_dfd := _ef.EncodeToString(_aba[:])
//	_eac := _d.Join(_ggd, _dfd)
//	_ecgd, _ebad := _cb.ReadFile(_eac)
//	if _ebad != nil {
//		if _cb.IsNotExist(_ebad) {
//			return reportState{}, nil
//		}
//		_fc.Log.Debug("ERROR: %v", _ebad)
//		return reportState{}, _g.New("invalid data")
//	}
//	const _gad = "ha9NK8]RbL*m4LKW"
//	_ecgd, _ebad = _fdae([]byte(_gad), _ecgd)
//	if _ebad != nil {
//		return reportState{}, _ebad
//	}
//	var _gceg reportState
//	_ebad = _ge.Unmarshal(_ecgd, &_gceg)
//	if _ebad != nil {
//		_fc.Log.Debug("ERROR: Invalid data: %v", _ebad)
//		return reportState{}, _g.New("invalid data")
//	}
//	return _gceg, nil
//}
//
func MakeUnlicensedKey() *LicenseKey {
	_adc := LicenseKey{}
	_adc.CustomerName = "Unlicensed"
	//_adc.Tier = LicenseTierUnlicensed
	_adc.CreatedAt = _gd.Now().UTC()
	_adc.CreatedAtInt = _adc.CreatedAt.Unix()
	return &_adc
}
//
//func _dad(_ebcf, _ccf string) string {
//	_bbde := []byte(_ebcf)
//	_aeaa := _eg.New(_ea.New, _bbde)
//	_aeaa.Write([]byte(_ccf))
//	return _f.StdEncoding.EncodeToString(_aeaa.Sum(nil))
//}
//
//func _eged(_cbab, _fgec []byte) ([]byte, error) {
//	_bbdg, _bcb := _af.NewCipher(_cbab)
//	if _bcb != nil {
//		return nil, _bcb
//	}
//	_defd := make([]byte, _af.BlockSize+len(_fgec))
//	_bcfb := _defd[:_af.BlockSize]
//	if _, _dcaf := _bg.ReadFull(_cab.Reader, _bcfb); _dcaf != nil {
//		return nil, _dcaf
//	}
//	_ebae := _df.NewCFBEncrypter(_bbdg, _bcfb)
//	_ebae.XORKeyStream(_defd[_af.BlockSize:], _fgec)
//	_gdg := make([]byte, _f.URLEncoding.EncodedLen(len(_defd)))
//	_f.URLEncoding.Encode(_gdg, _defd)
//	return _gdg, nil
//}

func init() {
	//_bgac := _cb.Getenv(_geg)
	//_abg := _cb.Getenv(_eec)
	//if len(_bgac) == 0 || len(_abg) == 0 {
	//	return
	//}
	//_cgg, _cc := _cb.ReadFile(_bgac)
	//if _cc != nil {
	//	_fc.Log.Error("Unable to read license code file: %v", _cc)
	//	return
	//}
	//_cc = SetLicenseKey(string(_cgg), _abg)
	//if _cc != nil {
	//	_fc.Log.Error("Unable to load license code: %v", _cc)
	//	return
	//}
}
//
//func _bfd() (_ca.IP, error) {
//	_becc, _dae := _ca.Dial("udp", "8.8.8.8:80")
//	if _dae != nil {
//		return nil, _dae
//	}
//	defer _becc.Close()
//	_gee := _becc.LocalAddr().(*_ca.UDPAddr)
//	return _gee.IP, nil
//}
//
//type reportState struct {
//	Instance      string         `json:"inst"`
//	Next          string         `json:"n"`
//	Docs          int64          `json:"d"`
//	NumErrors     int64          `json:"e"`
//	LimitDocs     bool           `json:"ld"`
//	RemainingDocs int64          `json:"rd"`
//	LastReported  _gd.Time       `json:"lr"`
//	LastWritten   _gd.Time       `json:"lw"`
//	Usage         map[string]int `json:"u"`
//	UsageLogs     []interface{}  `json:"ul,omitempty"`
//}
//
//func SetLicenseKey(content string, customerName string) error {
//	_afea, _bgca := _ae(content)
//	if _bgca != nil {
//		_fc.Log.Error("License code decode error: %v", _bgca)
//		return _bgca
//	}
//	if !_a.EqualFold(_afea.CustomerName, customerName) {
//		_fc.Log.Error("License code issue - Customer name mismatch, expected '%s', but got '%s'", _afea.CustomerName, customerName)
//		return _bgg.Errorf("customer name mismatch, expected '%s', but got '%s'", _afea.CustomerName, customerName)
//	}
//	_bgca = _afea.Validate()
//	if _bgca != nil {
//		_fc.Log.Error("License code validation error: %v", _bgca)
//		return _bgca
//	}
//	_cfd = &_afea
//	return nil
//}
//
func GetLicenseKey() *LicenseKey {
	return nil
	if _cfd == nil {
		return nil
	}
	_cfb := *_cfd
	return &_cfb
}
//
//const (
//	LicenseTierUnlicensed = "unlicensed"
//	LicenseTierCommunity  = "community"
//	LicenseTierIndividual = "individual"
//	LicenseTierBusiness   = "business"
//)
//
//func _fge() string {
//	_bbcg := _cb.Getenv("HOME")
//	if len(_bbcg) == 0 {
//		_bbcg, _ = _cb.UserHomeDir()
//	}
//	return _bbcg
//}
//
func (_ebe *LicenseKey) TypeToString() string {
	//if _ebe._fd {
	//	return "Metered subscription"
	//}
	//if _ebe.Tier == LicenseTierUnlicensed {
	//	return "Unlicensed"
	//}
	//if _ebe.Tier == LicenseTierCommunity {
	//	return "AGPLv3 Open Source Community License"
	//}
	//if _ebe.Tier == LicenseTierIndividual || _ebe.Tier == "indie" {
	//	return "Commercial License - Individual"
	//}
	return "Commercial License - Business"
}
//
//const _bbdf = `
//-----BEGIN PUBLIC KEY-----
//MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmFUiyd7b5XjpkP5Rap4w
//Dc1dyzIQ4LekxrvytnEMpNUbo6iA74V8ruZOvrScsf2QeN9/qrUG8qEbUWdoEYq+
//otFNAFNxlGbxbDHcdGVaM0OXdXgDyL5aIEagL0c5pwjIdPGIn46f78eMJ+JkdcpD\nDJaqYXdrz5KeshjSiIaa7menBIAXS4UFxNfHhN0HCYZYqQG7bK+s5rRHonydNWEG
//H8Myvr2pya2KrMumfmAxUB6fenC/4O0Wr8gfPOU8RitmbDvQPIRXOL4vTBrBdbaA
//9nwNP+i//20MT2bxmeWB+gpcEhGpXZ733azQxrC3J4v3CZmENStDK/KDSPKUGfu6
//fwIDAQAB
//-----END PUBLIC KEY-----`
//
//func _cge(_dfea *_bb.Response) ([]byte, error) {
//	var _eab []byte
//	_dfda, _ecfe := _cae(_dfea)
//	if _ecfe != nil {
//		return _eab, _ecfe
//	}
//	return _bg.ReadAll(_dfda)
//}
