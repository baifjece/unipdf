//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package model provides an interface for working with high-level objects (models) in PDF files, including
// reading and writing documents.
//
// The document structure of a PDF is constructed of a hierarchy of data models, representing a tree
// of information starting from the Document catalog (Figure 5 p. 80).
// It is based on the core package which handles core functionality such as file i/o, parsing and
// handling of primitive PDF objects (core.PdfObject).
//
// As an example of the interface, the following snippet can read the PDF and output the number of pages:
//
//	f, err := os.Open(inputPath)
//		if err != nil {
//		return nil, err
//	}
//	defer f.Close()
//	pdfReader, err := unipdf.NewPdfReader(f)
//	if err != nil {
//		fmt.Printf("Failed to read PDF file: %v\n", err)
//		os.Exit(1)
//	}
//	numPages, err := pdfReader.GetNumPages()
//	if err != nil {
//		fmt.Printf("Failed to get number of pages: %v\n", err)
//		os.Exit(1)
//	}
//	fmt.Printf("The PDF file has %d pages\n", numPages)
//
// For more examples, see the unidoc-examples repository on GitHub: https://github.com/unidoc/unidoc-examples
package model

import (
	_dg "bufio"
	_ef "bytes"
	_af "crypto/md5"
	_ge "crypto/rand"
	_ga "crypto/sha1"
	_ed "crypto/x509"
	_bd "encoding/binary"
	_ab "encoding/hex"
	_deb "errors"
	_c "fmt"
	_be "github.com/gabriel-vasile/mimetype"
	_ggb "github.com/unidoc/freetype"
	_fg "github.com/unidoc/freetype/truetype"
	_ff "github.com/unidoc/pkcs7"
	_bcd "github.com/unidoc/unipdf/v3/common"
	_df "github.com/unidoc/unipdf/v3/core"
	_afc "github.com/unidoc/unipdf/v3/core/security"
	_bfb "github.com/unidoc/unipdf/v3/core/security/crypt"
	_dgf "github.com/unidoc/unipdf/v3/internal/cmap"
	_bge "github.com/unidoc/unipdf/v3/internal/imageutil"
	_abc "github.com/unidoc/unipdf/v3/internal/license"
	_aff "github.com/unidoc/unipdf/v3/internal/sampling"
	_abg "github.com/unidoc/unipdf/v3/internal/textencoding"
	_bbe "github.com/unidoc/unipdf/v3/internal/timeutils"
	_dbc "github.com/unidoc/unipdf/v3/internal/transform"
	_aa "github.com/unidoc/unipdf/v3/internal/uuid"
	_cb "github.com/unidoc/unipdf/v3/model/internal/docutil"
	_da "github.com/unidoc/unipdf/v3/model/internal/fonts"
	_ffc "github.com/unidoc/unipdf/v3/model/mdp"
	_fd "github.com/unidoc/unipdf/v3/model/sigutil"
	_eg "github.com/unidoc/unipdf/v3/ps"
	_cf "github.com/unidoc/unitype"
	_fb "golang.org/x/image/font"
	_db "golang.org/x/xerrors"
	_gg "hash"
	_cg "image"
	_b "image/color"
	_a "image/draw"
	_ "image/gif"
	_bb "image/png"
	_bdd "io"
	_faf "math"
	_ebf "math/rand"
	_bf "os"
	_bg "path/filepath"
	_eb "regexp"
	_f "sort"
	_bc "strconv"
	_gc "strings"
	_g "sync"
	_fa "time"
	_e "unicode"
	_ag "unicode/utf8"
)

// GetNumComponents returns the number of color components.
func (_eaadg *PdfColorspaceICCBased) GetNumComponents() int { return _eaadg.N }

func (_aebe *PdfReader) loadStructure() error {
	if _aebe._gfdaag.GetCrypter() != nil && !_aebe._gfdaag.IsAuthenticated() {
		return _c.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_egbad := _aebe._gfdaag.GetTrailer()
	if _egbad == nil {
		return _c.Errorf("\u006di\u0073s\u0069\u006e\u0067\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072")
	}
	_gaafc, _dabf := _egbad.Get("\u0052\u006f\u006f\u0074").(*_df.PdfObjectReference)
	if !_dabf {
		return _c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052\u006f\u006ft\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u003a \u0025\u0073\u0029", _egbad)
	}
	_beafd, _afdbe := _aebe._gfdaag.LookupByReference(*_gaafc)
	if _afdbe != nil {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u0072\u006f\u006f\u0074\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0025\u0073", _afdbe)
		return _afdbe
	}
	_ggfega, _dabf := _beafd.(*_df.PdfIndirectObject)
	if !_dabf {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0028\u0072\u006f\u006f\u0074\u0020\u0025\u0071\u0029\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u0020\u0025\u0073\u0029", _beafd, *_egbad)
		return _deb.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	_fdeda, _dabf := (*_ggfega).PdfObject.(*_df.PdfObjectDictionary)
	if !_dabf {
		_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020I\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u0061t\u0061\u006c\u006fg\u0020(\u0025\u0073\u0029", _ggfega.PdfObject)
		return _deb.New("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	_bcd.Log.Trace("C\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0025\u0073", _fdeda)
	_gfdf, _dabf := _fdeda.Get("\u0050\u0061\u0067e\u0073").(*_df.PdfObjectReference)
	if !_dabf {
		return _deb.New("\u0070\u0061\u0067\u0065\u0073\u0020\u0069\u006e\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020b\u0065\u0020\u0061\u0020\u0072e\u0066\u0065r\u0065\u006e\u0063\u0065")
	}
	_egbfb, _afdbe := _aebe._gfdaag.LookupByReference(*_gfdf)
	if _afdbe != nil {
		_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020F\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020r\u0065\u0061\u0064 \u0070a\u0067\u0065\u0073")
		return _afdbe
	}
	_fbcbf, _dabf := _egbfb.(*_df.PdfIndirectObject)
	if !_dabf {
		_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020P\u0061\u0067\u0065\u0073\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0069n\u0076a\u006c\u0069\u0064")
		_bcd.Log.Debug("\u006f\u0070\u003a\u0020\u0025\u0070", _fbcbf)
		return _deb.New("p\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0069\u006e\u0076al\u0069\u0064")
	}
	_beabc, _dabf := _fbcbf.PdfObject.(*_df.PdfObjectDictionary)
	if !_dabf {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0073\u0020\u006f\u0062j\u0065c\u0074\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0025\u0073\u0029", _fbcbf)
		return _deb.New("p\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0069\u006e\u0076al\u0069\u0064")
	}
	_baeaf, _dabf := _df.GetInt(_beabc.Get("\u0043\u006f\u0075n\u0074"))
	if !_dabf {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0050\u0061\u0067\u0065\u0073\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return _deb.New("\u0070\u0061\u0067\u0065s \u0063\u006f\u0075\u006e\u0074\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	if _, _dabf = _df.GetName(_beabc.Get("\u0054\u0079\u0070\u0065")); !_dabf {
		_bcd.Log.Debug("\u0050\u0061\u0067\u0065\u0073\u0020\u0064\u0069\u0063\u0074\u0020T\u0079\u0070\u0065\u0020\u0066\u0069\u0065\u006cd\u0020n\u006f\u0074\u0020\u0073\u0065\u0074\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0054\u0079p\u0065\u0020\u0074\u006f\u0020\u0050\u0061\u0067\u0065\u0073\u002e")
		_beabc.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0050\u0061\u0067e\u0073"))
	}
	if _bgfbb, _fccga := _df.GetInt(_beabc.Get("\u0052\u006f\u0074\u0061\u0074\u0065")); _fccga {
		_edbfc := int64(*_bgfbb)
		_aebe.Rotate = &_edbfc
	}
	_aebe._fbbegf = _gaafc
	_aebe._afbaf = _fdeda
	_aebe._dfcf = _beabc
	_aebe._gaadg = _fbcbf
	_aebe._dgcgb = int(*_baeaf)
	_aebe._dcfee = []*_df.PdfIndirectObject{}
	_befddf := map[_df.PdfObject]struct{}{}
	_afdbe = _aebe.buildPageList(_fbcbf, nil, _befddf)
	if _afdbe != nil {
		return _afdbe
	}
	_bcd.Log.Trace("\u002d\u002d\u002d")
	_bcd.Log.Trace("\u0054\u004f\u0043")
	_bcd.Log.Trace("\u0050\u0061\u0067e\u0073")
	_bcd.Log.Trace("\u0025\u0064\u003a\u0020\u0025\u0073", len(_aebe._dcfee), _aebe._dcfee)
	_aebe._baaeg, _afdbe = _aebe.loadOutlines()
	if _afdbe != nil {
		_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0062\u0075i\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065 t\u0072\u0065\u0065 \u0028%\u0073\u0029", _afdbe)
		return _afdbe
	}
	_aebe.AcroForm, _afdbe = _aebe.loadForms()
	if _afdbe != nil {
		return _afdbe
	}
	_aebe.DSS, _afdbe = _aebe.loadDSS()
	if _afdbe != nil {
		return _afdbe
	}
	_aebe._eaeee, _afdbe = _aebe.loadPerms()
	if _afdbe != nil {
		return _afdbe
	}
	return nil
}

func (_accba *PdfAppender) mergeResources(_cfga, _gdbc _df.PdfObject, _bgec map[_df.PdfObjectName]_df.PdfObjectName) _df.PdfObject {
	if _gdbc == nil && _cfga == nil {
		return nil
	}
	if _gdbc == nil {
		return _cfga
	}
	_geaef, _faga := _df.GetDict(_gdbc)
	if !_faga {
		return _cfga
	}
	if _cfga == nil {
		_fgff := _df.MakeDict()
		_fgff.Merge(_geaef)
		return _gdbc
	}
	_efed, _faga := _df.GetDict(_cfga)
	if !_faga {
		_bcd.Log.Error("\u0045\u0072\u0072or\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065 \u0069s\u0020n\u006ft\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
		_efed = _df.MakeDict()
	}
	for _, _ffcg := range _geaef.Keys() {
		if _abdfc, _bafa := _bgec[_ffcg]; _bafa {
			_efed.Set(_abdfc, _geaef.Get(_ffcg))
		} else {
			_efed.Set(_ffcg, _geaef.Get(_ffcg))
		}
	}
	return _efed
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components.
func (_dgfcg *PdfColorspaceSpecialPattern) ColorFromFloats(vals []float64) (PdfColor, error) {
	if _dgfcg.UnderlyingCS == nil {
		return nil, _deb.New("u\u006e\u0064\u0065\u0072\u006c\u0079i\u006e\u0067\u0020\u0043\u0053\u0020\u006e\u006f\u0074 \u0073\u0070\u0065c\u0069f\u0069\u0065\u0064")
	}
	return _dgfcg.UnderlyingCS.ColorFromFloats(vals)
}

// GetBorderWidth returns the border style's width.
func (_gdbb *PdfBorderStyle) GetBorderWidth() float64 {
	if _gdbb.W == nil {
		return 1
	}
	return *_gdbb.W
}

// AddOutlineTree adds outlines to a PDF file.
func (_degdb *PdfWriter) AddOutlineTree(outlineTree *PdfOutlineTreeNode) {
	_degdb._cfgeg = outlineTree
}

func _dbab(_gdbcd _df.PdfObject) (*PdfColorspaceDeviceN, error) {
	_bgfc := NewPdfColorspaceDeviceN()
	if _gaaf, _bcdb := _gdbcd.(*_df.PdfIndirectObject); _bcdb {
		_bgfc._dabgc = _gaaf
	}
	_gdbcd = _df.TraceToDirectObject(_gdbcd)
	_bcfd, _ffgd := _gdbcd.(*_df.PdfObjectArray)
	if !_ffgd {
		return nil, _c.Errorf("\u0064\u0065\u0076\u0069\u0063\u0065\u004e\u0020\u0043\u0053\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062j\u0065\u0063\u0074")
	}
	if _bcfd.Len() != 4 && _bcfd.Len() != 5 {
		return nil, _c.Errorf("\u0064\u0065\u0076ic\u0065\u004e\u0020\u0043\u0053\u003a\u0020\u0049\u006ec\u006fr\u0072e\u0063t\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068")
	}
	_gdbcd = _bcfd.Get(0)
	_gbcgf, _ffgd := _gdbcd.(*_df.PdfObjectName)
	if !_ffgd {
		return nil, _c.Errorf("\u0064\u0065\u0076i\u0063\u0065\u004e\u0020C\u0053\u003a\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	if *_gbcgf != "\u0044e\u0076\u0069\u0063\u0065\u004e" {
		return nil, _c.Errorf("\u0064\u0065v\u0069\u0063\u0065\u004e\u0020\u0043\u0053\u003a\u0020\u0077\u0072\u006f\u006e\u0067\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020na\u006d\u0065")
	}
	_gdbcd = _bcfd.Get(1)
	_gdbcd = _df.TraceToDirectObject(_gdbcd)
	_gggd, _ffgd := _gdbcd.(*_df.PdfObjectArray)
	if !_ffgd {
		return nil, _c.Errorf("\u0064\u0065\u0076i\u0063\u0065\u004e\u0020C\u0053\u003a\u0020\u0049\u006e\u0076\u0061l\u0069\u0064\u0020\u006e\u0061\u006d\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_bgfc.ColorantNames = _gggd
	_gdbcd = _bcfd.Get(2)
	_afdc, _fafgf := NewPdfColorspaceFromPdfObject(_gdbcd)
	if _fafgf != nil {
		return nil, _fafgf
	}
	_bgfc.AlternateSpace = _afdc
	_ecbb, _fafgf := _ddaac(_bcfd.Get(3))
	if _fafgf != nil {
		return nil, _fafgf
	}
	_bgfc.TintTransform = _ecbb
	if _bcfd.Len() == 5 {
		_abfc, _gega := _abec(_bcfd.Get(4))
		if _gega != nil {
			return nil, _gega
		}
		_bgfc.Attributes = _abfc
	}
	return _bgfc, nil
}

// GetIndirectObjectByNumber retrieves and returns a specific PdfObject by object number.
func (_fbfb *PdfReader) GetIndirectObjectByNumber(number int) (_df.PdfObject, error) {
	_edebcc, _fbcbc := _fbfb._gfdaag.LookupByNumber(number)
	return _edebcc, _fbcbc
}

// Has checks if flag fl is set in flag and returns true if so, false otherwise.
func (_becdd FieldFlag) Has(fl FieldFlag) bool { return (_becdd.Mask() & fl.Mask()) > 0 }

// NewPdfActionURI returns a new "Uri" action.
func NewPdfActionURI() *PdfActionURI {
	_bbef := NewPdfAction()
	_efd := &PdfActionURI{}
	_efd.PdfAction = _bbef
	_bbef.SetContext(_efd)
	return _efd
}

// ColorToRGB converts a CalRGB color to an RGB color.
func (_fgea *PdfColorspaceCalRGB) ColorToRGB(color PdfColor) (PdfColor, error) {
	_cgge, _daff := color.(*PdfColorCalRGB)
	if !_daff {
		_bcd.Log.Debug("\u0049\u006e\u0070ut\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0063\u0061\u006c\u0020\u0072\u0067\u0062")
		return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_ggge := _cgge.A()
	_daae := _cgge.B()
	_cafc := _cgge.C()
	X := _fgea.Matrix[0]*_faf.Pow(_ggge, _fgea.Gamma[0]) + _fgea.Matrix[3]*_faf.Pow(_daae, _fgea.Gamma[1]) + _fgea.Matrix[6]*_faf.Pow(_cafc, _fgea.Gamma[2])
	Y := _fgea.Matrix[1]*_faf.Pow(_ggge, _fgea.Gamma[0]) + _fgea.Matrix[4]*_faf.Pow(_daae, _fgea.Gamma[1]) + _fgea.Matrix[7]*_faf.Pow(_cafc, _fgea.Gamma[2])
	Z := _fgea.Matrix[2]*_faf.Pow(_ggge, _fgea.Gamma[0]) + _fgea.Matrix[5]*_faf.Pow(_daae, _fgea.Gamma[1]) + _fgea.Matrix[8]*_faf.Pow(_cafc, _fgea.Gamma[2])
	_bagd := 3.240479*X + -1.537150*Y + -0.498535*Z
	_gabd := -0.969256*X + 1.875992*Y + 0.041556*Z
	_aced := 0.055648*X + -0.204043*Y + 1.057311*Z
	_bagd = _faf.Min(_faf.Max(_bagd, 0), 1.0)
	_gabd = _faf.Min(_faf.Max(_gabd, 0), 1.0)
	_aced = _faf.Min(_faf.Max(_aced, 0), 1.0)
	return NewPdfColorDeviceRGB(_bagd, _gabd, _aced), nil
}

// GetStructRoot gets the StructTreeRoot object
func (_dgdca *PdfPage) GetStructTreeRoot() (*_df.PdfObject, bool) {
	_dfebg, _efffd := _dgdca._cgacg.GetCatalogStructTreeRoot()
	return &_dfebg, _efffd
}

// HasColorspaceByName checks if the colorspace with the specified name exists in the page resources.
func (_dfadc *PdfPageResources) HasColorspaceByName(keyName _df.PdfObjectName) bool {
	_acfg, _gabee := _dfadc.GetColorspaces()
	if _gabee != nil {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _gabee)
		return false
	}
	if _acfg == nil {
		return false
	}
	_, _geddfd := _acfg.Colorspaces[string(keyName)]
	return _geddfd
}

func (_cbfd *PdfReader) newPdfAnnotationHighlightFromDict(_dfbg *_df.PdfObjectDictionary) (*PdfAnnotationHighlight, error) {
	_bff := PdfAnnotationHighlight{}
	_adfe, _faag := _cbfd.newPdfAnnotationMarkupFromDict(_dfbg)
	if _faag != nil {
		return nil, _faag
	}
	_bff.PdfAnnotationMarkup = _adfe
	_bff.QuadPoints = _dfbg.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_bff, nil
}

// NewPdfColorspaceFromPdfObject loads a PdfColorspace from a PdfObject.  Returns an error if there is
// a failure in loading.
func NewPdfColorspaceFromPdfObject(obj _df.PdfObject) (PdfColorspace, error) {
	if obj == nil {
		return nil, nil
	}
	var _affa *_df.PdfIndirectObject
	var _baef *_df.PdfObjectName
	var _fadc *_df.PdfObjectArray
	if _abfbg, _gbbf := obj.(*_df.PdfIndirectObject); _gbbf {
		_affa = _abfbg
	}
	obj = _df.TraceToDirectObject(obj)
	switch _ada := obj.(type) {
	case *_df.PdfObjectArray:
		_fadc = _ada
	case *_df.PdfObjectName:
		_baef = _ada
	}
	if _baef != nil {
		switch *_baef {
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":
			return NewPdfColorspaceDeviceGray(), nil
		case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":
			return NewPdfColorspaceDeviceRGB(), nil
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
			return NewPdfColorspaceDeviceCMYK(), nil
		case "\u0050a\u0074\u0074\u0065\u0072\u006e":
			return NewPdfColorspaceSpecialPattern(), nil
		default:
			_bcd.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065 \u0025\u0073", *_baef)
			return nil, _badg
		}
	}
	if _fadc != nil && _fadc.Len() > 0 {
		var _gcbd _df.PdfObject = _affa
		if _affa == nil {
			_gcbd = _fadc
		}
		if _dedd, _faee := _df.GetName(_fadc.Get(0)); _faee {
			switch _dedd.String() {
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":
				if _fadc.Len() == 1 {
					return NewPdfColorspaceDeviceGray(), nil
				}
			case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":
				if _fadc.Len() == 1 {
					return NewPdfColorspaceDeviceRGB(), nil
				}
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
				if _fadc.Len() == 1 {
					return NewPdfColorspaceDeviceCMYK(), nil
				}
			case "\u0043a\u006c\u0047\u0072\u0061\u0079":
				return _cbeb(_gcbd)
			case "\u0043\u0061\u006c\u0052\u0047\u0042":
				return _cagf(_gcbd)
			case "\u004c\u0061\u0062":
				return _fbgf(_gcbd)
			case "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064":
				return _fefg(_gcbd)
			case "\u0050a\u0074\u0074\u0065\u0072\u006e":
				return _fdgdb(_gcbd)
			case "\u0049n\u0064\u0065\u0078\u0065\u0064":
				return _agdeg(_gcbd)
			case "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e":
				return _cgfc(_gcbd)
			case "\u0044e\u0076\u0069\u0063\u0065\u004e":
				return _dbab(_gcbd)
			default:
				_bcd.Log.Debug("A\u0072\u0072\u0061\u0079\u0020\u0077i\u0074\u0068\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u006e\u0061m\u0065:\u0020\u0025\u0073", *_dedd)
			}
		}
	}
	_bcd.Log.Debug("\u0050\u0044\u0046\u0020\u0046i\u006c\u0065\u0020\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0073", obj.String())
	return nil, ErrTypeCheck
}

func (_ffbbf *fontFile) parseASCIIPart(_eagda []byte) error {
	if len(_eagda) < 2 || string(_eagda[:2]) != "\u0025\u0021" {
		return _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0074a\u0072\u0074\u0020\u006f\u0066\u0020\u0041S\u0043\u0049\u0049\u0020\u0073\u0065\u0067\u006d\u0065\u006e\u0074")
	}
	_edddc, _gadad, _cafab := _gbgga(_eagda)
	if _cafab != nil {
		return _cafab
	}
	_dadag := _aedef(_edddc)
	_ffbbf._accbb = _dadag["\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065"]
	if _ffbbf._accbb == "" {
		_bcd.Log.Debug("\u0020\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0020\u0068a\u0073\u0020\u006e\u006f\u0020\u002f\u0046\u006f\u006e\u0074N\u0061\u006d\u0065")
	}
	if _gadad != "" {
		_gdbaf, _cafge := _acab(_gadad)
		if _cafge != nil {
			return _cafge
		}
		_deggd, _cafge := _abg.NewCustomSimpleTextEncoder(_gdbaf, nil)
		if _cafge != nil {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004fR\u0020\u003a\u0055\u004e\u004b\u004e\u004f\u0057\u004e\u0020G\u004cY\u0050\u0048\u003a\u0020\u0065\u0072\u0072=\u0025\u0076", _cafge)
			return nil
		}
		_ffbbf._dgacb = _deggd
	}
	return nil
}

// IsRadio returns true if the button field represents a radio button, false otherwise.
func (_bafad *PdfFieldButton) IsRadio() bool { return _bafad.GetType() == ButtonTypeRadio }

// ToPdfObject returns the PDF representation of the shading pattern.
func (_fcbcb *PdfShadingPattern) ToPdfObject() _df.PdfObject {
	_fcbcb.PdfPattern.ToPdfObject()
	_adgag := _fcbcb.getDict()
	if _fcbcb.Shading != nil {
		_adgag.Set("\u0053h\u0061\u0064\u0069\u006e\u0067", _fcbcb.Shading.ToPdfObject())
	}
	if _fcbcb.Matrix != nil {
		_adgag.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _fcbcb.Matrix)
	}
	if _fcbcb.ExtGState != nil {
		_adgag.Set("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _fcbcb.ExtGState)
	}
	return _fcbcb._cbce
}

// PdfColorspaceDeviceGray represents a grayscale colorspace.
type PdfColorspaceDeviceGray struct{}

const (
	NonFullScreenPageModeUseNone     NonFullScreenPageMode = "\u0055s\u0065\u004e\u006f\u006e\u0065"
	NonFullScreenPageModeUseOutlines NonFullScreenPageMode = "U\u0073\u0065\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073"
	NonFullScreenPageModeUseThumbs   NonFullScreenPageMode = "\u0055s\u0065\u0054\u0068\u0075\u006d\u0062s"
	NonFullScreenPageModeUseOC       NonFullScreenPageMode = "\u0055\u0073\u0065O\u0043"
	DirectionL2R                     Direction             = "\u004c\u0032\u0052"
	DirectionR2L                     Direction             = "\u0052\u0032\u004c"
	PageBoundaryMediaBox             PageBoundary          = "\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078"
	PageBoundaryCropBox              PageBoundary          = "\u0043r\u006f\u0070\u0042\u006f\u0078"
	PageBoundaryBleedBox             PageBoundary          = "\u0042\u006c\u0065\u0065\u0064\u0042\u006f\u0078"
	PageBoundaryTrimBox              PageBoundary          = "\u0054r\u0069\u006d\u0042\u006f\u0078"
	PageBoundaryArtBox               PageBoundary          = "\u0041\u0072\u0074\u0042\u006f\u0078"
	PrintScalingNone                 PrintScaling          = "\u004e\u006f\u006e\u0065"
	PrintScalingAppDefault           PrintScaling          = "\u0041\u0070\u0070\u0044\u0065\u0066\u0061\u0075\u006c\u0074"
	DuplexNone                       Duplex                = "\u006e\u006f\u006e\u0065"
	DuplexSimplex                    Duplex                = "\u0053i\u006d\u0070\u006c\u0065\u0078"
	DuplexFlipShortEdge              Duplex                = "\u0044\u0075\u0070\u006cex\u0046\u006c\u0069\u0070\u0053\u0068\u006f\u0072\u0074\u0045\u0064\u0067\u0065"
	DuplexFlipLongEdge               Duplex                = "\u0044u\u0070l\u0065\u0078\u0046\u006c\u0069p\u004c\u006fn\u0067\u0045\u0064\u0067\u0065"
)

func _acab(_aeed string) (map[_abg.CharCode]_abg.GlyphName, error) {
	_deeab := _gc.Split(_aeed, "\u000a")
	_febg := make(map[_abg.CharCode]_abg.GlyphName)
	for _, _fbcc := range _deeab {
		_bcdc := _bedda.FindStringSubmatch(_fbcc)
		if _bcdc == nil {
			continue
		}
		_dbef, _efaff := _bcdc[1], _bcdc[2]
		_cfde, _gegac := _bc.Atoi(_dbef)
		if _gegac != nil {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0042\u0061\u0064\u0020\u0065\u006e\u0063\u006fd\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u002e \u0025\u0071", _fbcc)
			return nil, _df.ErrTypeError
		}
		_febg[_abg.CharCode(_cfde)] = _abg.GlyphName(_efaff)
	}
	_bcd.Log.Trace("g\u0065\u0074\u0045\u006e\u0063\u006fd\u0069\u006e\u0067\u0073\u003a\u0020\u006b\u0065\u0079V\u0061\u006c\u0075e\u0073=\u0025\u0023\u0076", _febg)
	return _febg, nil
}

// GetTrailer returns the PDF's trailer dictionary.
func (_deeec *PdfReader) GetTrailer() (*_df.PdfObjectDictionary, error) {
	_fefga := _deeec._gfdaag.GetTrailer()
	if _fefga == nil {
		return nil, _deb.New("\u0074r\u0061i\u006c\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	return _fefga, nil
}

// PdfFunctionType2 defines an exponential interpolation of one input value and n
// output values:
//
//	f(x) = y_0, ..., y_(n-1)
//
// y_j = C0_j + x^N * (C1_j - C0_j); for 0 <= j < n
// When N=1 ; linear interpolation between C0 and C1.
type PdfFunctionType2 struct {
	Domain []float64
	Range  []float64
	C0     []float64
	C1     []float64
	N      float64
	_fffb  *_df.PdfIndirectObject
}

func (_gfffb *pdfFontSimple) updateStandard14Font() {
	_gbgg, _fdag := _gfffb.Encoder().(_abg.SimpleEncoder)
	if !_fdag {
		_bcd.Log.Error("\u0057\u0072\u006f\u006e\u0067\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0074y\u0070e\u003a\u0020\u0025\u0054\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u002e", _gfffb.Encoder(), _gfffb)
		return
	}
	_bgaf := _gbgg.Charcodes()
	_gfffb._ffefd = make(map[_abg.CharCode]float64, len(_bgaf))
	for _, _geba := range _bgaf {
		_dgeed, _ := _gbgg.CharcodeToRune(_geba)
		_abfbe, _ := _gfffb._aeeed.Read(_dgeed)
		_gfffb._ffefd[_geba] = _abfbe.Wx
	}
}

func (_bffg *PdfColorspaceSpecialSeparation) String() string {
	return "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e"
}

// NewPdfSignatureReferenceDocMDP returns PdfSignatureReference for the transformParams.
func NewPdfSignatureReferenceDocMDP(transformParams *PdfTransformParamsDocMDP) *PdfSignatureReference {
	return &PdfSignatureReference{Type: _df.MakeName("\u0053\u0069\u0067\u0052\u0065\u0066"), TransformMethod: _df.MakeName("\u0044\u006f\u0063\u004d\u0044\u0050"), TransformParams: transformParams.ToPdfObject()}
}

// NewPdfColorspaceSpecialPattern returns a new pattern color.
func NewPdfColorspaceSpecialPattern() *PdfColorspaceSpecialPattern {
	return &PdfColorspaceSpecialPattern{}
}

func _cbbgb(_ccedcg []byte) bool {
	if len(_ccedcg) < 4 {
		return true
	}
	for _ffcb := range _ccedcg[:4] {
		_ddfad := rune(_ffcb)
		if !_e.Is(_e.ASCII_Hex_Digit, _ddfad) && !_e.IsSpace(_ddfad) {
			return true
		}
	}
	return false
}

func _cgae(_eegff _df.PdfObject) (*_df.PdfObjectDictionary, *fontCommon, error) {
	_gbec := &fontCommon{}
	if _cgdc, _ddfdg := _eegff.(*_df.PdfIndirectObject); _ddfdg {
		_gbec._fceg = _cgdc.ObjectNumber
	}
	_afba, _bgga := _df.GetDict(_eegff)
	if !_bgga {
		_bcd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0067\u0069\u0076\u0065\u006e\u0020\u0062\u0079\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _eegff)
		return nil, nil, ErrFontNotSupported
	}
	_aegb, _bgga := _df.GetNameVal(_afba.Get("\u0054\u0079\u0070\u0065"))
	if !_bgga {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046o\u006e\u0074\u0020\u0049\u006ec\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u002e\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, nil, ErrRequiredAttributeMissing
	}
	if _aegb != "\u0046\u006f\u006e\u0074" {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0046\u006f\u006e\u0074\u0020\u0049\u006e\u0063\u006f\u006d\u0070\u0061t\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u002e\u0020\u0054\u0079\u0070\u0065\u003d\u0025\u0071\u002e\u0020\u0053\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0025\u0071.", _aegb, "\u0046\u006f\u006e\u0074")
		return nil, nil, _df.ErrTypeError
	}
	_fdeg, _bgga := _df.GetNameVal(_afba.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"))
	if !_bgga {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020F\u006f\u006e\u0074 \u0049\u006e\u0063o\u006d\u0070a\u0074\u0069\u0062\u0069\u006c\u0069t\u0079. \u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, nil, ErrRequiredAttributeMissing
	}
	_gbec._fgfae = _fdeg
	_bbccb, _bgga := _df.GetNameVal(_afba.Get("\u004e\u0061\u006d\u0065"))
	if _bgga {
		_gbec._ggad = _bbccb
	}
	_deddd := _afba.Get("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e")
	if _deddd != nil {
		_gbec._cdbgag = _df.TraceToDirectObject(_deddd)
		_dafdb, _eebfe := _eggf(_gbec._cdbgag, _gbec)
		if _eebfe != nil {
			return _afba, _gbec, _eebfe
		}
		_gbec._afcbd = _dafdb
	} else if _fdeg == "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030" || _fdeg == "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032" {
		_ddfa, _cgbgc := _dgf.NewCIDSystemInfo(_afba.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
		if _cgbgc != nil {
			return _afba, _gbec, _cgbgc
		}
		_dgcga := _c.Sprintf("\u0025\u0073\u002d\u0025\u0073\u002d\u0055\u0043\u0053\u0032", _ddfa.Registry, _ddfa.Ordering)
		if _dgf.IsPredefinedCMap(_dgcga) {
			_gbec._afcbd, _cgbgc = _dgf.LoadPredefinedCMap(_dgcga)
			if _cgbgc != nil {
				_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0070\u0072\u0065\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0043\u004d\u0061\u0070\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _dgcga, _cgbgc)
			}
		}
	}
	_bddcd := _afba.Get("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072")
	if _bddcd != nil {
		_ecca, _gecda := _fbee(_bddcd)
		if _gecda != nil {
			_bcd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0042\u0061\u0064\u0020\u0066\u006f\u006et\u0020d\u0065s\u0063r\u0069\u0070\u0074\u006f\u0072\u002e\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _gecda)
			return _afba, _gbec, _gecda
		}
		_gbec._agggb = _ecca
	}
	if _fdeg != "\u0054\u0079\u0070e\u0033" {
		_fbbc, _ebdfg := _df.GetNameVal(_afba.Get("\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074"))
		if !_ebdfg {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u006f\u006et\u0020\u0049\u006ec\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069t\u0079\u002e\u0020\u0042\u0061se\u0046\u006f\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
			return _afba, _gbec, ErrRequiredAttributeMissing
		}
		_gbec._gddcf = _fbbc
	}
	return _afba, _gbec, nil
}

// Field returns the parent form field of the widget annotation, if one exists.
// NOTE: the method returns nil if the parent form field has not been parsed.
func (_gdc *PdfAnnotationWidget) Field() *PdfField { return _gdc._aeaf }

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_eeecd *PdfShading) ToPdfObject() _df.PdfObject {
	_aggd := _eeecd._bgdag
	_ggebb, _gfebc := _eeecd.getShadingDict()
	if _gfebc != nil {
		_bcd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _eeecd.ShadingType != nil {
		_ggebb.Set("S\u0068\u0061\u0064\u0069\u006e\u0067\u0054\u0079\u0070\u0065", _eeecd.ShadingType)
	}
	if _eeecd.ColorSpace != nil {
		_ggebb.Set("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _eeecd.ColorSpace.ToPdfObject())
	}
	if _eeecd.Background != nil {
		_ggebb.Set("\u0042\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064", _eeecd.Background)
	}
	if _eeecd.BBox != nil {
		_ggebb.Set("\u0042\u0042\u006f\u0078", _eeecd.BBox.ToPdfObject())
	}
	if _eeecd.AntiAlias != nil {
		_ggebb.Set("\u0041n\u0074\u0069\u0041\u006c\u0069\u0061s", _eeecd.AntiAlias)
	}
	return _aggd
}

func (_ffaed *DSS) add(_gfdd *[]*_df.PdfObjectStream, _ceefe map[string]*_df.PdfObjectStream, _dbbdc [][]byte) ([]*_df.PdfObjectStream, error) {
	_cdbga := make([]*_df.PdfObjectStream, 0, len(_dbbdc))
	for _, _ggca := range _dbbdc {
		_bfded, _gdfc := _bgde(_ggca)
		if _gdfc != nil {
			return nil, _gdfc
		}
		_cfca, _dbac := _ceefe[string(_bfded)]
		if !_dbac {
			_cfca, _gdfc = _df.MakeStream(_ggca, _df.NewRawEncoder())
			if _gdfc != nil {
				return nil, _gdfc
			}
			_ceefe[string(_bfded)] = _cfca
			*_gfdd = append(*_gfdd, _cfca)
		}
		_cdbga = append(_cdbga, _cfca)
	}
	return _cdbga, nil
}

// NewCompositePdfFontFromTTFFile loads a composite font from a TTF font file. Composite fonts can
// be used to represent unicode fonts which can have multi-byte character codes, representing a wide
// range of values. They are often used for symbolic languages, including Chinese, Japanese and Korean.
// It is represented by a Type0 Font with an underlying CIDFontType2 and an Identity-H encoding map.
// TODO: May be extended in the future to support a larger variety of CMaps and vertical fonts.
// NOTE: For simple fonts, use NewPdfFontFromTTFFile.
func NewCompositePdfFontFromTTFFile(filePath string) (*PdfFont, error) {
	_bgdba, _fegcd := _bf.Open(filePath)
	if _fegcd != nil {
		_bcd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u006f\u0070\u0065\u006e\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0076", _fegcd)
		return nil, _fegcd
	}
	defer _bgdba.Close()
	return NewCompositePdfFontFromTTF(_bgdba)
}

func (_aeaa *PdfReader) newPdfAnnotationRichMediaFromDict(_ebce *_df.PdfObjectDictionary) (*PdfAnnotationRichMedia, error) {
	_ggfc := &PdfAnnotationRichMedia{}
	_ggfc.RichMediaSettings = _ebce.Get("\u0052\u0069\u0063\u0068\u004d\u0065\u0064\u0069\u0061\u0053\u0065\u0074t\u0069\u006e\u0067\u0073")
	_ggfc.RichMediaContent = _ebce.Get("\u0052\u0069c\u0068\u004d\u0065d\u0069\u0061\u0043\u006f\u006e\u0074\u0065\u006e\u0074")
	return _ggfc, nil
}

// PdfPageResources is a Page resources model.
// Implements PdfModel.
type PdfPageResources struct {
	ExtGState  _df.PdfObject
	ColorSpace _df.PdfObject
	Pattern    _df.PdfObject
	Shading    _df.PdfObject
	XObject    _df.PdfObject
	Font       _df.PdfObject
	ProcSet    _df.PdfObject
	Properties _df.PdfObject
	_cecgg     *_df.PdfObjectDictionary
	_eafae     *PdfPageResourcesColorspaces
}

// Subtype returns the font's "Subtype" field.
func (_dcfaa *PdfFont) Subtype() string {
	_feaa := _dcfaa.baseFields()._fgfae
	if _bbcba, _cgfaa := _dcfaa._eaeg.(*pdfFontType0); _cgfaa {
		_feaa = _feaa + "\u003a" + _bbcba.DescendantFont.Subtype()
	}
	return _feaa
}

// GetCatalogMarkInfo gets catalog MarkInfo object.
func (_ggaag *PdfReader) GetCatalogMarkInfo() (_df.PdfObject, bool) {
	if _ggaag._afbaf == nil {
		return nil, false
	}
	_cfggd := _ggaag._afbaf.Get("\u004d\u0061\u0072\u006b\u0049\u006e\u0066\u006f")
	return _cfggd, _cfggd != nil
}

// ToPdfObject implements interface PdfModel.
func (_fadb *PdfAnnotationText) ToPdfObject() _df.PdfObject {
	_fadb.PdfAnnotation.ToPdfObject()
	_ebee := _fadb._bfde
	_gegf := _ebee.PdfObject.(*_df.PdfObjectDictionary)
	if _fadb.PdfAnnotationMarkup != nil {
		_fadb.PdfAnnotationMarkup.appendToPdfDictionary(_gegf)
	}
	_gegf.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0054\u0065\u0078\u0074"))
	_gegf.SetIfNotNil("\u004f\u0070\u0065\u006e", _fadb.Open)
	_gegf.SetIfNotNil("\u004e\u0061\u006d\u0065", _fadb.Name)
	_gegf.SetIfNotNil("\u0053\u0074\u0061t\u0065", _fadb.State)
	_gegf.SetIfNotNil("\u0053\u0074\u0061\u0074\u0065\u004d\u006f\u0064\u0065\u006c", _fadb.StateModel)
	return _ebee
}

// PdfShadingType5 is a Lattice-form Gouraud-shaded triangle mesh.
type PdfShadingType5 struct {
	*PdfShading
	BitsPerCoordinate *_df.PdfObjectInteger
	BitsPerComponent  *_df.PdfObjectInteger
	VerticesPerRow    *_df.PdfObjectInteger
	Decode            *_df.PdfObjectArray
	Function          []PdfFunction
}

// NewPdfAppender creates a new Pdf appender from a Pdf reader.
func NewPdfAppender(reader *PdfReader) (*PdfAppender, error) {
	_ggfcd := &PdfAppender{_fggb: reader._fbacd, Reader: reader, _gecd: reader._gfdaag, _abba: reader._eebc}
	_fegbe, _bfe := _ggfcd._fggb.Seek(0, _bdd.SeekEnd)
	if _bfe != nil {
		return nil, _bfe
	}
	_ggfcd._bfgee = _fegbe
	if _, _bfe = _ggfcd._fggb.Seek(0, _bdd.SeekStart); _bfe != nil {
		return nil, _bfe
	}
	_ggfcd._abf, _bfe = NewPdfReader(_ggfcd._fggb)
	if _bfe != nil {
		return nil, _bfe
	}
	for _, _aag := range _ggfcd.Reader.GetObjectNums() {
		if _ggfcd._eadb < _aag {
			_ggfcd._eadb = _aag
		}
	}
	_ggfcd._bagc = _ggfcd._gecd.GetXrefTable()
	_ggfcd._cfeb = _ggfcd._gecd.GetXrefOffset()
	_ggfcd._dgac = append(_ggfcd._dgac, _ggfcd._abf.PageList...)
	_ggfcd._gceg = make(map[_df.PdfObject]struct{})
	_ggfcd._aggf = make(map[_df.PdfObject]int64)
	_ggfcd._bbba = make(map[_df.PdfObject]struct{})
	_ggfcd._ffe = _ggfcd._abf.AcroForm
	_ggfcd._cgebag = _ggfcd._abf.DSS
	return _ggfcd, nil
}

// ToPdfObject implements interface PdfModel.
func (_bbcc *PdfAnnotationInk) ToPdfObject() _df.PdfObject {
	_bbcc.PdfAnnotation.ToPdfObject()
	_bgbc := _bbcc._bfde
	_deda := _bgbc.PdfObject.(*_df.PdfObjectDictionary)
	_bbcc.PdfAnnotationMarkup.appendToPdfDictionary(_deda)
	_deda.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0049\u006e\u006b"))
	_deda.SetIfNotNil("\u0049n\u006b\u004c\u0069\u0073\u0074", _bbcc.InkList)
	_deda.SetIfNotNil("\u0042\u0053", _bbcc.BS)
	return _bgbc
}

// NewPdfAnnotationUnderline returns a new text underline annotation.
func NewPdfAnnotationUnderline() *PdfAnnotationUnderline {
	_cdd := NewPdfAnnotation()
	_gdac := &PdfAnnotationUnderline{}
	_gdac.PdfAnnotation = _cdd
	_gdac.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cdd.SetContext(_gdac)
	return _gdac
}

func (_fbgga *PdfReader) newPdfAnnotationSquareFromDict(_gee *_df.PdfObjectDictionary) (*PdfAnnotationSquare, error) {
	_bdgc := PdfAnnotationSquare{}
	_bga, _aeeb := _fbgga.newPdfAnnotationMarkupFromDict(_gee)
	if _aeeb != nil {
		return nil, _aeeb
	}
	_bdgc.PdfAnnotationMarkup = _bga
	_bdgc.BS = _gee.Get("\u0042\u0053")
	_bdgc.IC = _gee.Get("\u0049\u0043")
	_bdgc.BE = _gee.Get("\u0042\u0045")
	_bdgc.RD = _gee.Get("\u0052\u0044")
	return &_bdgc, nil
}

func (_caaa *PdfReader) newPdfActionTransFromDict(_dfa *_df.PdfObjectDictionary) (*PdfActionTrans, error) {
	return &PdfActionTrans{Trans: _dfa.Get("\u0054\u0072\u0061n\u0073")}, nil
}

// GetXObjectByName returns the XObject with the specified keyName and the object type.
func (_daadb *PdfPageResources) GetXObjectByName(keyName _df.PdfObjectName) (*_df.PdfObjectStream, XObjectType) {
	if _daadb.XObject == nil {
		return nil, XObjectTypeUndefined
	}
	_bcgdb, _befcb := _df.TraceToDirectObject(_daadb.XObject).(*_df.PdfObjectDictionary)
	if !_befcb {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0058\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _df.TraceToDirectObject(_daadb.XObject))
		return nil, XObjectTypeUndefined
	}
	if _cebde := _bcgdb.Get(keyName); _cebde != nil {
		_afgeg, _dbafg := _df.GetStream(_cebde)
		if !_dbafg {
			_bcd.Log.Debug("X\u004f\u0062\u006a\u0065\u0063\u0074 \u006e\u006f\u0074\u0020\u0070\u006fi\u006e\u0074\u0069\u006e\u0067\u0020\u0074o\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020%\u0054", _cebde)
			return nil, XObjectTypeUndefined
		}
		_bgaafg := _afgeg.PdfObjectDictionary
		_ebcab, _dbafg := _df.TraceToDirectObject(_bgaafg.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")).(*_df.PdfObjectName)
		if !_dbafg {
			_bcd.Log.Debug("\u0058\u004fbj\u0065\u0063\u0074 \u0053\u0075\u0062\u0074ype\u0020no\u0074\u0020\u0061\u0020\u004e\u0061\u006de,\u0020\u0064\u0069\u0063\u0074\u003a\u0020%\u0073", _bgaafg.String())
			return nil, XObjectTypeUndefined
		}
		if *_ebcab == "\u0049\u006d\u0061g\u0065" {
			return _afgeg, XObjectTypeImage
		} else if *_ebcab == "\u0046\u006f\u0072\u006d" {
			return _afgeg, XObjectTypeForm
		} else if *_ebcab == "\u0050\u0053" {
			return _afgeg, XObjectTypePS
		} else {
			_bcd.Log.Debug("\u0058\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0053\u0075b\u0074\u0079\u0070\u0065\u0020\u006e\u006ft\u0020\u006b\u006e\u006f\u0077\u006e\u0020\u0028\u0025\u0073\u0029", *_ebcab)
			return nil, XObjectTypeUndefined
		}
	} else {
		return nil, XObjectTypeUndefined
	}
}

func _gafgf(_dafeg _bdd.ReadSeeker, _beebb *ReaderOpts, _cfege bool, _ccdgf string) (*PdfReader, error) {
	if _beebb == nil {
		_beebb = NewReaderOpts()
	}
	_gfbcb := ""
	if _ccddb, _caaef := _dafeg.(*_bf.File); _caaef {
		_gfbcb = _ccddb.Name()
	}
	_eefc := *_beebb
	_cbgfc := &PdfReader{_fbacd: _dafeg, _eebc: map[_df.PdfObject]struct{}{}, _ceggc: _dacefe(), _edbbdf: _beebb.LazyLoad, _caece: _beebb.ComplianceMode, _aeec: _cfege, _cbcee: &_eefc, _effbb: _gfbcb}
	_fbecgd, _agfg := _cbdee("\u0072")
	if _agfg != nil {
		return nil, _agfg
	}
	_agfg = _abc.Track(_fbecgd, _ccdgf, _cbgfc._effbb)
	if _agfg != nil {
		return nil, _agfg
	}
	_cbgfc._bdcaa = _fbecgd
	var _fbdga *_df.PdfParser
	if !_cbgfc._caece {
		_fbdga, _agfg = _df.NewParser(_dafeg)
	} else {
		_fbdga, _agfg = _df.NewCompliancePdfParser(_dafeg)
	}
	if _agfg != nil {
		return nil, _agfg
	}
	_cbgfc._gfdaag = _fbdga
	_cbeed, _agfg := _cbgfc.IsEncrypted()
	if _agfg != nil {
		return nil, _agfg
	}
	if !_cbeed {
		_agfg = _cbgfc.loadStructure()
		if _agfg != nil {
			return nil, _agfg
		}
	} else if _cfege {
		_abbgg, _fgabbf := _cbgfc.Decrypt([]byte(_beebb.Password))
		if _fgabbf != nil {
			return nil, _fgabbf
		}
		if !_abbgg {
			return nil, _deb.New("\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0064\u0065c\u0072\u0079\u0070\u0074\u0020\u0070\u0061\u0073\u0073w\u006f\u0072\u0064\u0020p\u0072\u006f\u0074\u0065\u0063\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u002d\u0020\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0073\u0070\u0065\u0063\u0069\u0066y\u0020\u0070\u0061s\u0073\u0020\u0074\u006f\u0020\u0044\u0065\u0063\u0072\u0079\u0070\u0074")
		}
	}
	_cbgfc._aefcd = make(map[*PdfReader]*PdfReader)
	_cbgfc._cbga = make([]*PdfReader, _fbdga.GetRevisionNumber())
	return _cbgfc, nil
}

// NewXObjectImageFromStream builds the image xobject from a stream object.
// An image dictionary is the dictionary portion of a stream object representing an image XObject.
func NewXObjectImageFromStream(stream *_df.PdfObjectStream) (*XObjectImage, error) {
	_dbabb := &XObjectImage{}
	_dbabb._fgdgd = stream
	_baffe := *(stream.PdfObjectDictionary)
	_dedffb, _dcfab := _df.NewEncoderFromStream(stream)
	if _dcfab != nil {
		return nil, _dcfab
	}
	_dbabb.Filter = _dedffb
	if _cabde := _df.TraceToDirectObject(_baffe.Get("\u0057\u0069\u0064t\u0068")); _cabde != nil {
		_aeaggb, _cdbff := _cabde.(*_df.PdfObjectInteger)
		if !_cdbff {
			return nil, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0077\u0069\u0064\u0074\u0068\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		_abeef := int64(*_aeaggb)
		_dbabb.Width = &_abeef
	} else {
		return nil, _deb.New("\u0077\u0069\u0064\u0074\u0068\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	if _fadff := _df.TraceToDirectObject(_baffe.Get("\u0048\u0065\u0069\u0067\u0068\u0074")); _fadff != nil {
		_geeccd, _faagb := _fadff.(*_df.PdfObjectInteger)
		if !_faagb {
			return nil, _deb.New("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0069\u006d\u0061\u0067\u0065\u0020\u0068\u0065\u0069g\u0068\u0074\u0020o\u0062j\u0065\u0063\u0074")
		}
		_fccaff := int64(*_geeccd)
		_dbabb.Height = &_fccaff
	} else {
		return nil, _deb.New("\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
	}
	if _gcafd := _df.TraceToDirectObject(_baffe.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065")); _gcafd != nil {
		_dfffd, _bdae := NewPdfColorspaceFromPdfObject(_gcafd)
		if _bdae != nil {
			return nil, _bdae
		}
		_dbabb.ColorSpace = _dfffd
	} else {
		_bcd.Log.Debug("\u0058O\u0062\u006a\u0065c\u0074\u0020\u0049m\u0061ge\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u002d\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067 1\u0020c\u006f\u006c\u006f\u0072\u0020\u0063o\u006d\u0070\u006f\u006e\u0065n\u0074\u0020\u002d\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047r\u0061\u0079")
		_dbabb.ColorSpace = NewPdfColorspaceDeviceGray()
	}
	if _bcddf := _df.TraceToDirectObject(_baffe.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")); _bcddf != nil {
		_dfgga, _bdcecd := _bcddf.(*_df.PdfObjectInteger)
		if !_bdcecd {
			return nil, _deb.New("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0069\u006d\u0061\u0067\u0065\u0020\u0068\u0065\u0069g\u0068\u0074\u0020o\u0062j\u0065\u0063\u0074")
		}
		_acbd := int64(*_dfgga)
		_dbabb.BitsPerComponent = &_acbd
	}
	_dbabb.Intent = _baffe.Get("\u0049\u006e\u0074\u0065\u006e\u0074")
	_dbabb.ImageMask = _baffe.Get("\u0049m\u0061\u0067\u0065\u004d\u0061\u0073k")
	_dbabb.Mask = _baffe.Get("\u004d\u0061\u0073\u006b")
	_dbabb.Decode = _baffe.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	_dbabb.Interpolate = _baffe.Get("I\u006e\u0074\u0065\u0072\u0070\u006f\u006c\u0061\u0074\u0065")
	_dbabb.Alternatives = _baffe.Get("\u0041\u006c\u0074e\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0073")
	_dbabb.SMask = _baffe.Get("\u0053\u004d\u0061s\u006b")
	_dbabb.SMaskInData = _baffe.Get("S\u004d\u0061\u0073\u006b\u0049\u006e\u0044\u0061\u0074\u0061")
	_dbabb.Matte = _baffe.Get("\u004d\u0061\u0074t\u0065")
	_dbabb.Name = _baffe.Get("\u004e\u0061\u006d\u0065")
	_dbabb.StructParent = _baffe.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074")
	_dbabb.ID = _baffe.Get("\u0049\u0044")
	_dbabb.OPI = _baffe.Get("\u004f\u0050\u0049")
	_dbabb.Metadata = _baffe.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061")
	_dbabb.OC = _baffe.Get("\u004f\u0043")
	_dbabb.Stream = stream.Stream
	return _dbabb, nil
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element in
// range 0-1.
func (_fccg *PdfColorspaceDeviceGray) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bgbdc, _fecd := _df.GetNumbersAsFloat(objects)
	if _fecd != nil {
		return nil, _fecd
	}
	return _fccg.ColorFromFloats(_bgbdc)
}

// NewPdfShadingType3 creates an empty shading type 3 dictionary.
func NewPdfShadingType3() *PdfShadingType3 {
	_fbdea := &PdfShadingType3{}
	_fbdea.PdfShading = &PdfShading{}
	_fbdea.PdfShading._bgdag = _df.MakeIndirectObject(_df.MakeDict())
	_fbdea.PdfShading._dggab = _fbdea
	return _fbdea
}

// WriteToFile writes the Appender output to file specified by path.
func (_ecda *PdfAppender) WriteToFile(outputPath string) error {
	_bdf, _edgb := _bf.Create(outputPath)
	if _edgb != nil {
		return _edgb
	}
	defer _bdf.Close()
	return _ecda.Write(_bdf)
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_cagd *PdfPageResourcesColorspaces) ToPdfObject() _df.PdfObject {
	_fafa := _df.MakeDict()
	for _, _bggac := range _cagd.Names {
		_fafa.Set(_df.PdfObjectName(_bggac), _cagd.Colorspaces[_bggac].ToPdfObject())
	}
	if _cagd._bcbab != nil {
		_cagd._bcbab.PdfObject = _fafa
		return _cagd._bcbab
	}
	return _fafa
}

// ToPdfObject returns colorspace in a PDF object format [name dictionary]
func (_befb *PdfColorspaceCalRGB) ToPdfObject() _df.PdfObject {
	_baca := &_df.PdfObjectArray{}
	_baca.Append(_df.MakeName("\u0043\u0061\u006c\u0052\u0047\u0042"))
	_aeaae := _df.MakeDict()
	if _befb.WhitePoint != nil {
		_gdf := _df.MakeArray(_df.MakeFloat(_befb.WhitePoint[0]), _df.MakeFloat(_befb.WhitePoint[1]), _df.MakeFloat(_befb.WhitePoint[2]))
		_aeaae.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _gdf)
	} else {
		_bcd.Log.Error("\u0043\u0061l\u0052\u0047\u0042\u003a \u004d\u0069s\u0073\u0069\u006e\u0067\u0020\u0057\u0068\u0069t\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075i\u0072\u0065\u0064\u0029")
	}
	if _befb.BlackPoint != nil {
		_abbc := _df.MakeArray(_df.MakeFloat(_befb.BlackPoint[0]), _df.MakeFloat(_befb.BlackPoint[1]), _df.MakeFloat(_befb.BlackPoint[2]))
		_aeaae.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _abbc)
	}
	if _befb.Gamma != nil {
		_bgaac := _df.MakeArray(_df.MakeFloat(_befb.Gamma[0]), _df.MakeFloat(_befb.Gamma[1]), _df.MakeFloat(_befb.Gamma[2]))
		_aeaae.Set("\u0047\u0061\u006dm\u0061", _bgaac)
	}
	if _befb.Matrix != nil {
		_baad := _df.MakeArray(_df.MakeFloat(_befb.Matrix[0]), _df.MakeFloat(_befb.Matrix[1]), _df.MakeFloat(_befb.Matrix[2]), _df.MakeFloat(_befb.Matrix[3]), _df.MakeFloat(_befb.Matrix[4]), _df.MakeFloat(_befb.Matrix[5]), _df.MakeFloat(_befb.Matrix[6]), _df.MakeFloat(_befb.Matrix[7]), _df.MakeFloat(_befb.Matrix[8]))
		_aeaae.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _baad)
	}
	_baca.Append(_aeaae)
	if _befb._bbed != nil {
		_befb._bbed.PdfObject = _baca
		return _befb._bbed
	}
	return _baca
}

// HasPatternByName checks whether a pattern object is defined by the specified keyName.
func (_bbgbg *PdfPageResources) HasPatternByName(keyName _df.PdfObjectName) bool {
	_, _fdgeg := _bbgbg.GetPatternByName(keyName)
	return _fdgeg
}

// PdfAnnotationText represents Text annotations.
// (Section 12.5.6.4 p. 402).
type PdfAnnotationText struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Open       _df.PdfObject
	Name       _df.PdfObject
	State      _df.PdfObject
	StateModel _df.PdfObject
}

// NewPdfActionTrans returns a new "trans" action.
func NewPdfActionTrans() *PdfActionTrans {
	_ffb := NewPdfAction()
	_gce := &PdfActionTrans{}
	_gce.PdfAction = _ffb
	_ffb.SetContext(_gce)
	return _gce
}

func (_acgbd *LTV) buildCertChain(_edff, _fccef []*_ed.Certificate) ([]*_ed.Certificate, map[string]*_ed.Certificate, error) {
	_ddabd := map[string]*_ed.Certificate{}
	for _, _afceg := range _edff {
		_ddabd[_afceg.Subject.CommonName] = _afceg
	}
	_daega := _edff
	for _, _eadd := range _fccef {
		_fgagc := _eadd.Subject.CommonName
		if _, _cbfc := _ddabd[_fgagc]; _cbfc {
			continue
		}
		_ddabd[_fgagc] = _eadd
		_daega = append(_daega, _eadd)
	}
	if len(_daega) == 0 {
		return nil, nil, ErrSignNoCertificates
	}
	var _eeaff error
	for _fcafb := _daega[0]; _fcafb != nil && !_acgbd.CertClient.IsCA(_fcafb); {
		_cfcaf, _acfdb := _ddabd[_fcafb.Issuer.CommonName]
		if !_acfdb {
			if _cfcaf, _eeaff = _acgbd.CertClient.GetIssuer(_fcafb); _eeaff != nil {
				_bcd.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076", _eeaff)
				break
			}
			_ddabd[_fcafb.Issuer.CommonName] = _cfcaf
			_daega = append(_daega, _cfcaf)
		}
		_fcafb = _cfcaf
	}
	return _daega, _ddabd, nil
}

func _gbgga(_gcdc []byte) (_ecge, _fegg string, _bfgbe error) {
	_bcd.Log.Trace("g\u0065\u0074\u0041\u0053CI\u0049S\u0065\u0063\u0074\u0069\u006fn\u0073\u003a\u0020\u0025\u0064\u0020", len(_gcdc))
	_aedg := _ebdbe.FindIndex(_gcdc)
	if _aedg == nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0067\u0065\u0074\u0041\u0053\u0043\u0049\u0049\u0053\u0065\u0063\u0074\u0069o\u006e\u0073\u002e\u0020\u004e\u006f\u0020d\u0069\u0063\u0074\u002e")
		return "", "", _df.ErrTypeError
	}
	_adeg := _aedg[1]
	_fbeab := _gc.Index(string(_gcdc[_adeg:]), _feeb)
	if _fbeab < 0 {
		_ecge = string(_gcdc[_adeg:])
		return _ecge, "", nil
	}
	_aacgg := _adeg + _fbeab
	_ecge = string(_gcdc[_adeg:_aacgg])
	_gdadc := _aacgg
	_fbeab = _gc.Index(string(_gcdc[_gdadc:]), _dfda)
	if _fbeab < 0 {
		_bcd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0067e\u0074\u0041\u0053\u0043\u0049\u0049\u0053e\u0063\u0074\u0069\u006f\u006e\u0073\u002e\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _bfgbe)
		return "", "", _df.ErrTypeError
	}
	_fdce := _gdadc + _fbeab
	_fegg = string(_gcdc[_gdadc:_fdce])
	return _ecge, _fegg, nil
}

// SetRefObject sets the reference object for the KValue.
func (_ddadeb *KValue) SetRefObject(refObject _df.PdfObject) {
	_ddadeb.Clear()
	_ddadeb._ccgeg = refObject
}

// ToPdfObject returns the choice field dictionary within an indirect object (container).
func (_bbeg *PdfFieldChoice) ToPdfObject() _df.PdfObject {
	_bbeg.PdfField.ToPdfObject()
	_edge := _bbeg._cdbc
	_bfdc := _edge.PdfObject.(*_df.PdfObjectDictionary)
	_bfdc.Set("\u0046\u0054", _df.MakeName("\u0043\u0068"))
	if _bbeg.Opt != nil {
		_bfdc.Set("\u004f\u0070\u0074", _bbeg.Opt)
	}
	if _bbeg.TI != nil {
		_bfdc.Set("\u0054\u0049", _bbeg.TI)
	}
	if _bbeg.I != nil {
		_bfdc.Set("\u0049", _bbeg.I)
	}
	return _edge
}

// ToPdfObject returns a PDF object representation of the ViewerPreferences.
func (_cbcg *ViewerPreferences) ToPdfObject() _df.PdfObject {
	_daggd := _df.MakeDict()
	if _cbcg._bbfdd != nil {
		_daggd.Set("H\u0069\u0064\u0065\u0054\u006f\u006f\u006c\u0062\u0061\u0072", _df.MakeBool(*_cbcg._bbfdd))
	}
	if _cbcg._abebaec != nil {
		_daggd.Set("H\u0069\u0064\u0065\u004d\u0065\u006e\u0075\u0062\u0061\u0072", _df.MakeBool(*_cbcg._abebaec))
	}
	if _cbcg._dbfebfg != nil {
		_daggd.Set("\u0048\u0069\u0064e\u0057\u0069\u006e\u0064\u006f\u0077\u0055\u0049", _df.MakeBool(*_cbcg._dbfebfg))
	}
	if _cbcg._eadcd != nil {
		_daggd.Set("\u0046i\u0074\u0057\u0069\u006e\u0064\u006fw", _df.MakeBool(*_cbcg._eadcd))
	}
	if _cbcg._agceg != nil {
		_daggd.Set("\u0043\u0065\u006et\u0065\u0072\u0057\u0069\u006e\u0064\u006f\u0077", _df.MakeBool(*_cbcg._agceg))
	}
	if _cbcg._bfggg != nil {
		_daggd.Set("\u0044i\u0073p\u006c\u0061\u0079\u0044\u006f\u0063\u0054\u0069\u0074\u006c\u0065", _df.MakeBool(*_cbcg._bfggg))
	}
	if _cbcg._ebbf != "" {
		_daggd.Set("N\u006f\u006e\u0046\u0075ll\u0053c\u0072\u0065\u0065\u006e\u0050a\u0067\u0065\u004d\u006f\u0064\u0065", _df.MakeName(string(_cbcg._ebbf)))
	}
	if _cbcg._cggbe != "" {
		_daggd.Set("\u0044i\u0072\u0065\u0063\u0074\u0069\u006fn", _df.MakeName(string(_cbcg._cggbe)))
	}
	if _cbcg._ffbad != "" {
		_daggd.Set("\u0056\u0069\u0065\u0077\u0041\u0072\u0065\u0061", _df.MakeName(string(_cbcg._ffbad)))
	}
	if _cbcg._geabe != "" {
		_daggd.Set("\u0056\u0069\u0065\u0077\u0043\u006c\u0069\u0070", _df.MakeName(string(_cbcg._geabe)))
	}
	if _cbcg._fbede != "" {
		_daggd.Set("\u0050r\u0069\u006e\u0074\u0041\u0072\u0065a", _df.MakeName(string(_cbcg._fbede)))
	}
	if _cbcg._edeeb != "" {
		_daggd.Set("\u0050r\u0069\u006e\u0074\u0043\u006c\u0069p", _df.MakeName(string(_cbcg._edeeb)))
	}
	if _cbcg._faefa != "" {
		_daggd.Set("\u0050\u0072\u0069n\u0074\u0053\u0063\u0061\u006c\u0069\u006e\u0067", _df.MakeName(string(_cbcg._faefa)))
	}
	if _cbcg._aecfg != "" {
		_daggd.Set("\u0044\u0075\u0070\u006c\u0065\u0078", _df.MakeName(string(_cbcg._aecfg)))
	}
	if _cbcg._cgbe != nil {
		_daggd.Set("\u0050\u0069\u0063\u006b\u0054\u0072\u0061\u0079\u0042\u0079\u0050\u0044F\u0053\u0069\u007a\u0065", _df.MakeBool(*_cbcg._cgbe))
	}
	if _cbcg._dafbb != nil {
		_daggd.Set("\u0050\u0072\u0069\u006e\u0074\u0050\u0061\u0067\u0065R\u0061\u006e\u0067\u0065", _df.MakeArrayFromIntegers(_cbcg._dafbb))
	}
	if _cbcg._edded != 0 {
		_daggd.Set("\u004eu\u006d\u0043\u006f\u0070\u0069\u0065s", _df.MakeInteger(int64(_cbcg._edded)))
	}
	return _daggd
}

func (_gef *PdfReader) newPdfActionSoundFromDict(_fca *_df.PdfObjectDictionary) (*PdfActionSound, error) {
	return &PdfActionSound{Sound: _fca.Get("\u0053\u006f\u0075n\u0064"), Volume: _fca.Get("\u0056\u006f\u006c\u0075\u006d\u0065"), Synchronous: _fca.Get("S\u0079\u006e\u0063\u0068\u0072\u006f\u006e\u006f\u0075\u0073"), Repeat: _fca.Get("\u0052\u0065\u0070\u0065\u0061\u0074"), Mix: _fca.Get("\u004d\u0069\u0078")}, nil
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain three PdfObjectFloat elements representing
// the L, A and B components of the color.
func (_fbca *PdfColorspaceLab) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gfdg, _caga := _df.GetNumbersAsFloat(objects)
	if _caga != nil {
		return nil, _caga
	}
	return _fbca.ColorFromFloats(_gfdg)
}

func _gfdeg() string {
	_gcdec.Lock()
	defer _gcdec.Unlock()
	if len(_cgaca) > 0 {
		return _cgaca
	}
	return "\u0055n\u0069\u0044\u006f\u0063 \u002d\u0020\u0068\u0074\u0074p\u003a/\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069o"
}

func (_bgbfa *PdfColorspaceDeviceCMYK) String() string {
	return "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b"
}

// GetDocMDPPermission returns the DocMDP level of the restrictions
func (_acacc *PdfSignature) GetDocMDPPermission() (_ffc.DocMDPPermission, bool) {
	for _, _aeefa := range _acacc.Reference.Elements() {
		if _feeadb, _fecdd := _df.GetDict(_aeefa); _fecdd {
			if _cafcg, _acgbad := _df.GetNameVal(_feeadb.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064")); _acgbad && _cafcg == "\u0044\u006f\u0063\u004d\u0044\u0050" {
				if _gdbbd, _fgdc := _df.GetDict(_feeadb.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073")); _fgdc {
					if P, _cgfea := _df.GetIntVal(_gdbbd.Get("\u0050")); _cgfea {
						return _ffc.DocMDPPermission(P), true
					}
				}
			}
		}
	}
	return 0, false
}

// FileRelationship represents a attachment file relationship type.
type FileRelationship int

// XObjectForm (Table 95 in 8.10.2).
type XObjectForm struct {
	Filter        _df.StreamEncoder
	FormType      _df.PdfObject
	BBox          _df.PdfObject
	Matrix        _df.PdfObject
	Resources     *PdfPageResources
	Group         _df.PdfObject
	Ref           _df.PdfObject
	MetaData      _df.PdfObject
	PieceInfo     _df.PdfObject
	LastModified  _df.PdfObject
	StructParent  _df.PdfObject
	StructParents _df.PdfObject
	OPI           _df.PdfObject
	OC            _df.PdfObject
	Name          _df.PdfObject

	// Stream data.
	Stream []byte
	_bbfeg *_df.PdfObjectStream
}

// NewPdfAnnotationSquare returns a new square annotation.
func NewPdfAnnotationSquare() *PdfAnnotationSquare {
	_cfgd := NewPdfAnnotation()
	_dgdc := &PdfAnnotationSquare{}
	_dgdc.PdfAnnotation = _cfgd
	_dgdc.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cfgd.SetContext(_dgdc)
	return _dgdc
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_beeb *PdfColorspaceDeviceGray) ToPdfObject() _df.PdfObject {
	return _df.MakeName("\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079")
}

// DefaultFont returns the default font, which is currently the built in Helvetica.
func DefaultFont() *PdfFont {
	_ccegc, _fgfbg := _da.NewStdFontByName(HelveticaName)
	if !_fgfbg {
		panic("\u0048\u0065lv\u0065\u0074\u0069c\u0061\u0020\u0073\u0068oul\u0064 a\u006c\u0077\u0061\u0079\u0073\u0020\u0062e \u0061\u0076\u0061\u0069\u006c\u0061\u0062l\u0065")
	}
	_fddd := _acfc(_ccegc)
	return &PdfFont{_eaeg: &_fddd}
}

// NewPdfAcroForm returns a new PdfAcroForm with an initialized container (indirect object).
func NewPdfAcroForm() *PdfAcroForm {
	return &PdfAcroForm{Fields: &[]*PdfField{}, _cffeg: _df.MakeIndirectObject(_df.MakeDict())}
}

func (_bgeb *PdfReader) newPdfAnnotationTextFromDict(_eaa *_df.PdfObjectDictionary) (*PdfAnnotationText, error) {
	_aadf := PdfAnnotationText{}
	_baga, _ged := _bgeb.newPdfAnnotationMarkupFromDict(_eaa)
	if _ged != nil {
		return nil, _ged
	}
	_aadf.PdfAnnotationMarkup = _baga
	_aadf.Open = _eaa.Get("\u004f\u0070\u0065\u006e")
	_aadf.Name = _eaa.Get("\u004e\u0061\u006d\u0065")
	_aadf.State = _eaa.Get("\u0053\u0074\u0061t\u0065")
	_aadf.StateModel = _eaa.Get("\u0053\u0074\u0061\u0074\u0065\u004d\u006f\u0064\u0065\u006c")
	return &_aadf, nil
}

func (_ffbac *pdfFontType0) getFontDescriptor() *PdfFontDescriptor {
	if _ffbac._agggb == nil && _ffbac.DescendantFont != nil {
		return _ffbac.DescendantFont.FontDescriptor()
	}
	return _ffbac._agggb
}

// PdfAnnotationSquiggly represents Squiggly annotations.
// (Section 12.5.6.10).
type PdfAnnotationSquiggly struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _df.PdfObject
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_acee *PdfShadingType1) ToPdfObject() _df.PdfObject {
	_acee.PdfShading.ToPdfObject()
	_eabae, _bbeed := _acee.getShadingDict()
	if _bbeed != nil {
		_bcd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _acee.Domain != nil {
		_eabae.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _acee.Domain)
	}
	if _acee.Matrix != nil {
		_eabae.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _acee.Matrix)
	}
	if _acee.Function != nil {
		if len(_acee.Function) == 1 {
			_eabae.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _acee.Function[0].ToPdfObject())
		} else {
			_addae := _df.MakeArray()
			for _, _dbfdg := range _acee.Function {
				_addae.Append(_dbfdg.ToPdfObject())
			}
			_eabae.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _addae)
		}
	}
	return _acee._bgdag
}

// NewKDictionary creates a new K dictionary object.
func NewKDictionary() *KDict { return &KDict{_dacfd: make([]*KValue, 0), _cabee: -1} }

// ToPdfObject implements interface PdfModel.
func (_afg *PdfActionGoTo3DView) ToPdfObject() _df.PdfObject {
	_afg.PdfAction.ToPdfObject()
	_ad := _afg._gcf
	_dae := _ad.PdfObject.(*_df.PdfObjectDictionary)
	_dae.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeGoTo3DView)))
	_dae.SetIfNotNil("\u0054\u0041", _afg.TA)
	_dae.SetIfNotNil("\u0056", _afg.V)
	return _ad
}

// GetOutlines returns a high-level Outline object, based on the outline tree
// of the reader.
func (_ddge *PdfReader) GetOutlines() (*Outline, error) {
	if _ddge == nil {
		return nil, _deb.New("\u0063\u0061n\u006e\u006f\u0074\u0020c\u0072\u0065a\u0074\u0065\u0020\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0066\u0072\u006f\u006d\u0020\u006e\u0069\u006c\u0020\u0072e\u0061\u0064\u0065\u0072")
	}
	_acfed := _ddge.GetOutlineTree()
	if _acfed == nil {
		return nil, _deb.New("\u0074\u0068\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u0064\u006f\u0065\u0073\u0020n\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u006e\u0020o\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065")
	}
	var _agab func(_aefcc *PdfOutlineTreeNode, _cfgfc *[]*OutlineItem)
	_agab = func(_bgag *PdfOutlineTreeNode, _fdfgg *[]*OutlineItem) {
		if _bgag == nil {
			return
		}
		if _bgag._dcgc == nil {
			_bcd.Log.Debug("\u0045\u0052RO\u0052\u003a\u0020m\u0069\u0073\u0073\u0069ng \u006fut\u006c\u0069\u006e\u0065\u0020\u0065\u006etr\u0079\u0020\u0063\u006f\u006e\u0074\u0065x\u0074")
			return
		}
		var _dfaec *OutlineItem
		if _fcabe, _dadbf := _bgag._dcgc.(*PdfOutlineItem); _dadbf {
			_efbea := _fcabe.Dest
			if (_efbea == nil || _df.IsNullObject(_efbea)) && _fcabe.A != nil {
				if _eadgc, _bedff := _df.GetDict(_fcabe.A); _bedff {
					if _bcagf, _gfgeb := _df.GetArray(_eadgc.Get("\u0044")); _gfgeb {
						_efbea = _bcagf
					} else {
						_cdgcb, _cgbdb := _df.GetString(_eadgc.Get("\u0044"))
						if !_cgbdb {
							return
						}
						_cbfgb, _cgbdb := _ddge._afbaf.Get("\u004e\u0061\u006de\u0073").(*_df.PdfObjectReference)
						if !_cgbdb {
							return
						}
						_ebebd, _abdag := _ddge._gfdaag.LookupByReference(*_cbfgb)
						if _abdag != nil {
							_bcd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u006e\u0061\u006d\u0065\u0073\u0020\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0020\u0028\u0025\u0073\u0029", _abdag.Error())
							return
						}
						_bcae, _cgbdb := _ebebd.(*_df.PdfIndirectObject)
						if !_cgbdb {
							return
						}
						_fdgfcb := map[_df.PdfObject]struct{}{}
						_abdag = _ddge.buildNameNodes(_bcae, _fdgfcb)
						if _abdag != nil {
							_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006ea\u006d\u0065\u0020\u006e\u006fd\u0065\u0073 \u0028\u0025\u0073\u0029", _abdag.Error())
							return
						}
						for _ddafb := range _fdgfcb {
							_cgab, _eggc := _df.GetDict(_ddafb)
							if !_eggc {
								continue
							}
							_bbccdf, _eggc := _df.GetArray(_cgab.Get("\u004e\u0061\u006de\u0073"))
							if !_eggc {
								continue
							}
							for _acaaa, _gffde := range _bbccdf.Elements() {
								switch _gffde.(type) {
								case *_df.PdfObjectString:
									if _gffde.String() == _cdgcb.String() {
										if _bdcab := _bbccdf.Get(_acaaa + 1); _bdcab != nil {
											if _adda, _dgbdc := _df.GetDict(_bdcab); _dgbdc {
												_efbea = _adda.Get("\u0044")
												break
											}
										}
									}
								}
							}
						}
					}
				}
			}
			var _gdada OutlineDest
			if _efbea != nil && !_df.IsNullObject(_efbea) {
				if _bcgebf, _gacg := _dbgee(_efbea, _ddge); _gacg == nil {
					_gdada = *_bcgebf
				} else {
					_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020p\u0061\u0072\u0073\u0065\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0064\u0065\u0073\u0074\u0020\u0028\u0025\u0076\u0029\u003a\u0020\u0025\u0076", _efbea, _gacg)
				}
			}
			_dfaec = NewOutlineItem(_fcabe.Title.Decoded(), _gdada)
			*_fdfgg = append(*_fdfgg, _dfaec)
			if _fcabe.Next != nil {
				_agab(_fcabe.Next, _fdfgg)
			}
		}
		if _bgag.First != nil {
			if _dfaec != nil {
				_fdfgg = &_dfaec.Entries
			}
			_agab(_bgag.First, _fdfgg)
		}
	}
	_edgbe := NewOutline()
	_agab(_acfed, &_edgbe.Entries)
	return _edgbe, nil
}

// ToPdfObject implements interface PdfModel.
func (_fcd *PdfAnnotationScreen) ToPdfObject() _df.PdfObject {
	_fcd.PdfAnnotation.ToPdfObject()
	_fec := _fcd._bfde
	_cff := _fec.PdfObject.(*_df.PdfObjectDictionary)
	_cff.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0053\u0063\u0072\u0065\u0065\u006e"))
	_cff.SetIfNotNil("\u0054", _fcd.T)
	_cff.SetIfNotNil("\u004d\u004b", _fcd.MK)
	_cff.SetIfNotNil("\u0041", _fcd.A)
	_cff.SetIfNotNil("\u0041\u0041", _fcd.AA)
	return _fec
}

// GetAttachedFiles retrieves all the attached files info and content.
func (_ecegb *PdfReader) GetAttachedFiles() ([]*EmbeddedFile, error) {
	_agacdb := []*EmbeddedFile{}
	_babab, _eeaa := _ecegb.GetNameDictionary()
	if _eeaa != nil {
		return nil, _eeaa
	}
	if _babab == nil {
		return _agacdb, nil
	}
	_feef := _fcgd(_babab)
	if _feef.EmbeddedFiles == nil {
		return nil, nil
	}
	_dbgab := _feef.EmbeddedFiles.Get("\u004e\u0061\u006de\u0073")
	_bafegc, _gbcge := _dbgab.(*_df.PdfObjectArray)
	if !_gbcge {
		return nil, _deb.New("\u0049\u006e\u0076\u0061li\u0064\u0020\u004e\u0061\u006d\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	for _bgbbb := 1; _bgbbb < len(_bafegc.Elements()); _bgbbb += 2 {
		if _bgbbb%2 != 0 {
			_fcecc := _bafegc.Get(_bgbbb)
			_eaggg, _gdcbe := NewPdfFilespecFromObj(_fcecc)
			if _gdcbe != nil {
				return nil, _gdcbe
			}
			_caffff, _gdcbe := NewEmbeddedFileFromObject(_eaggg.EF)
			if _gdcbe != nil {
				return nil, _gdcbe
			}
			_ccde, _gegdg := _eaggg.F.(*_df.PdfObjectString)
			if _gegdg {
				_caffff.Name = _ccde.Str()
			}
			_caffff.Description = _eaggg.Desc.WriteString()
			_caffff.Relationship = RelationshipUnspecified
			if _eaggg.AFRelationship != nil {
				switch _eaggg.AFRelationship.WriteString() {
				case "\u0053\u006f\u0075\u0072\u0063\u0065":
					_caffff.Relationship = RelationshipSource
				case "\u0044\u0061\u0074\u0061":
					_caffff.Relationship = RelationshipData
				case "A\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065":
					_caffff.Relationship = RelationshipAlternative
				case "\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074":
					_caffff.Relationship = RelationshipSupplement
				default:
					_caffff.Relationship = RelationshipUnspecified
				}
			}
			_agacdb = append(_agacdb, _caffff)
		}
	}
	return _agacdb, nil
}

func _baec(_fdbe *fontCommon) *pdfCIDFontType2 { return &pdfCIDFontType2{fontCommon: *_fdbe} }

// K returns the value of the key component of the color.
func (_gccc *PdfColorDeviceCMYK) K() float64 { return _gccc[3] }

// SetAlpha sets the alpha layer for the image.
func (_baac *Image) SetAlpha(alpha []byte) { _baac._gebab = alpha }

// PdfColorspaceICCBased format [/ICCBased stream]
//
// The stream shall contain the ICC profile.
// A conforming reader shall support ICC.1:2004:10 as required by PDF 1.7, which will enable it
// to properly render all embedded ICC profiles regardless of the PDF version
//
// In the current implementation, we rely on the alternative colormap provided.
type PdfColorspaceICCBased struct {
	N         int
	Alternate PdfColorspace

	// If omitted ICC not supported: then use DeviceGray,
	// DeviceRGB or DeviceCMYK for N=1,3,4 respectively.
	Range    []float64
	Metadata *_df.PdfObjectStream
	Data     []byte
	_cdggfa  *_df.PdfIndirectObject
	_gdgeg   *_df.PdfObjectStream
}

func _fdba(_dddg []byte) []byte {
	const _gfeab = 52845
	const _dgcgf = 22719
	_ddacg := 55665
	for _, _gcegf := range _dddg[:4] {
		_ddacg = (int(_gcegf)+_ddacg)*_gfeab + _dgcgf
	}
	_eafgc := make([]byte, len(_dddg)-4)
	for _abbg, _caef := range _dddg[4:] {
		_eafgc[_abbg] = byte(int(_caef) ^ _ddacg>>8)
		_ddacg = (int(_caef)+_ddacg)*_gfeab + _dgcgf
	}
	return _eafgc
}

const (
	RelationshipSource FileRelationship = iota
	RelationshipData
	RelationshipAlternative
	RelationshipSupplement
	RelationshipUnspecified
)

// SetImage updates XObject Image with new image data.
func (_cdbge *XObjectImage) SetImage(img *Image, cs PdfColorspace) error {
	_cdbge.Filter.UpdateParams(img.GetParamsDict())
	_fbcbe, _caaagb := _cdbge.Filter.EncodeBytes(img.Data)
	if _caaagb != nil {
		return _caaagb
	}
	_cdbge.Stream = _fbcbe
	_dcdae := img.Width
	_cdbge.Width = &_dcdae
	_facae := img.Height
	_cdbge.Height = &_facae
	_ebbec := img.BitsPerComponent
	_cdbge.BitsPerComponent = &_ebbec
	if cs == nil {
		if img.ColorComponents == 1 {
			_cdbge.ColorSpace = NewPdfColorspaceDeviceGray()
		} else if img.ColorComponents == 3 {
			_cdbge.ColorSpace = NewPdfColorspaceDeviceRGB()
		} else if img.ColorComponents == 4 {
			_cdbge.ColorSpace = NewPdfColorspaceDeviceCMYK()
		} else {
			return _deb.New("c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020u\u006e\u0064\u0065\u0066in\u0065\u0064")
		}
	} else {
		_cdbge.ColorSpace = cs
	}
	return nil
}

const (
	RC4_128bit = EncryptionAlgorithm(iota)
	AES_128bit
	AES_256bit
)

// PdfPage represents a page in a PDF document. (7.7.3.3 - Table 30).
type PdfPage struct {
	Parent               _df.PdfObject
	LastModified         *PdfDate
	Resources            *PdfPageResources
	CropBox              *PdfRectangle
	MediaBox             *PdfRectangle
	BleedBox             *PdfRectangle
	TrimBox              *PdfRectangle
	ArtBox               *PdfRectangle
	BoxColorInfo         _df.PdfObject
	Contents             _df.PdfObject
	Rotate               *int64
	Group                _df.PdfObject
	Thumb                _df.PdfObject
	B                    _df.PdfObject
	Dur                  _df.PdfObject
	Trans                _df.PdfObject
	AA                   _df.PdfObject
	Metadata             _df.PdfObject
	PieceInfo            _df.PdfObject
	StructParents        _df.PdfObject
	ID                   _df.PdfObject
	PZ                   _df.PdfObject
	SeparationInfo       _df.PdfObject
	Tabs                 _df.PdfObject
	TemplateInstantiated _df.PdfObject
	PresSteps            _df.PdfObject
	UserUnit             _df.PdfObject
	VP                   _df.PdfObject
	Annots               _df.PdfObject
	_adef                []*PdfAnnotation
	_gfcee               *_df.PdfObjectDictionary
	_gcced               *_df.PdfIndirectObject
	_agacd               _df.PdfObjectDictionary
	_cgacg               *PdfReader
}

// Initialize initializes the PdfSignature.
func (_cbfce *PdfSignature) Initialize() error {
	if _cbfce.Handler == nil {
		return _deb.New("\u0073\u0069\u0067n\u0061\u0074\u0075\u0072e\u0020\u0068\u0061\u006e\u0064\u006c\u0065r\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c")
	}
	return _cbfce.Handler.InitSignature(_cbfce)
}

// CharcodesToUnicode converts the character codes `charcodes` to a slice of runes.
// How it works:
//  1. Use the ToUnicode CMap if there is one.
//  2. Use the underlying font's encoding.
func (_dccc *PdfFont) CharcodesToUnicode(charcodes []_abg.CharCode) []rune {
	_dffd, _, _ := _dccc.CharcodesToUnicodeWithStats(charcodes)
	return _dffd
}

func (_gbbe *PdfReader) newPdfAnnotationScreenFromDict(_fcfda *_df.PdfObjectDictionary) (*PdfAnnotationScreen, error) {
	_cgce := PdfAnnotationScreen{}
	_cgce.T = _fcfda.Get("\u0054")
	_cgce.MK = _fcfda.Get("\u004d\u004b")
	_cgce.A = _fcfda.Get("\u0041")
	_cgce.AA = _fcfda.Get("\u0041\u0041")
	return &_cgce, nil
}

// PdfFieldButton represents a button field which includes push buttons, checkboxes, and radio buttons.
type PdfFieldButton struct {
	*PdfField
	Opt   *_df.PdfObjectArray
	_addf *Image
}

// ToPdfObject implements interface PdfModel.
func (_cd *PdfActionGoToE) ToPdfObject() _df.PdfObject {
	_cd.PdfAction.ToPdfObject()
	_gaf := _cd._gcf
	_bca := _gaf.PdfObject.(*_df.PdfObjectDictionary)
	_bca.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeGoToE)))
	if _cd.F != nil {
		_bca.Set("\u0046", _cd.F.ToPdfObject())
	}
	_bca.SetIfNotNil("\u0044", _cd.D)
	_bca.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _cd.NewWindow)
	_bca.SetIfNotNil("\u0054", _cd.T)
	return _gaf
}

// CharcodeBytesToUnicode converts PDF character codes `data` to a Go unicode string.
//
// 9.10 Extraction of Text Content (page 292)
// The process of finding glyph descriptions in OpenType fonts by a conforming reader shall be the following:
//   - For Type 1 fonts using “CFF” tables, the process shall be as described in 9.6.6.2, "Encodings
//     for Type 1 Fonts".
//   - For TrueType fonts using “glyf” tables, the process shall be as described in 9.6.6.4,
//     "Encodings for TrueType Fonts". Since this process sometimes produces ambiguous results,
//     conforming writers, instead of using a simple font, shall use a Type 0 font with an Identity-H
//     encoding and use the glyph indices as character codes, as described following Table 118.
func (_eabda *PdfFont) CharcodeBytesToUnicode(data []byte) (string, int, int) {
	_aged, _, _ddba := _eabda.CharcodesToUnicodeWithStats(_eabda.BytesToCharcodes(data))
	_fbfcf := _abg.ExpandLigatures(_aged)
	return _fbfcf, _ag.RuneCountInString(_fbfcf), _ddba
}

// StdFontName represents name of a standard font.
type StdFontName = _da.StdFontName

// SetContext sets the sub annotation (context).
func (_cfec *PdfAnnotation) SetContext(ctx PdfModel) { _cfec._afaa = ctx }

// NewPdfActionNamed returns a new "named" action.
func NewPdfActionNamed() *PdfActionNamed {
	_ac := NewPdfAction()
	_gdg := &PdfActionNamed{}
	_gdg.PdfAction = _ac
	_ac.SetContext(_gdg)
	return _gdg
}

// NewPdfAnnotationHighlight returns a new text highlight annotation.
func NewPdfAnnotationHighlight() *PdfAnnotationHighlight {
	_ebde := NewPdfAnnotation()
	_gccb := &PdfAnnotationHighlight{}
	_gccb.PdfAnnotation = _ebde
	_gccb.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_ebde.SetContext(_gccb)
	return _gccb
}

// PdfFieldSignature signature field represents digital signatures and optional data for authenticating
// the name of the signer and verifying document contents.
type PdfFieldSignature struct {
	*PdfField
	*PdfAnnotationWidget
	V    *PdfSignature
	Lock *_df.PdfIndirectObject
	SV   *_df.PdfIndirectObject
}

// IsEncrypted returns true if the PDF file is encrypted.
func (_dgfb *PdfReader) IsEncrypted() (bool, error) { return _dgfb._gfdaag.IsEncrypted() }

// GetPatternByName gets the pattern specified by keyName. Returns nil if not existing.
// The bool flag indicated whether it was found or not.
func (_abaee *PdfPageResources) GetPatternByName(keyName _df.PdfObjectName) (*PdfPattern, bool) {
	if _abaee.Pattern == nil {
		return nil, false
	}
	_edage, _gafgcf := _df.TraceToDirectObject(_abaee.Pattern).(*_df.PdfObjectDictionary)
	if !_gafgcf {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074t\u0065\u0072\u006e\u0020\u0065\u006e\u0074r\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _abaee.Pattern)
		return nil, false
	}
	if _bafbb := _edage.Get(keyName); _bafbb != nil {
		_fefbc, _ffgda := _cagef(_bafbb)
		if _ffgda != nil {
			_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020f\u0061\u0069l\u0065\u0064\u0020\u0074\u006f\u0020\u006c\u006fa\u0064\u0020\u0070\u0064\u0066\u0020\u0070\u0061\u0074\u0074\u0065\u0072n\u003a\u0020\u0025\u0076", _ffgda)
			return nil, false
		}
		return _fefbc, true
	}
	return nil, false
}

// SetSubtype sets the Subtype S for given PdfOutputIntent.
func (_bfcaf *PdfOutputIntent) SetSubtype(subtype PdfOutputIntentType) error {
	if !subtype.IsValid() {
		return _deb.New("\u0070\u0072o\u0076\u0069\u0064\u0065d\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u004f\u0075t\u0070\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074\u0020\u0053\u0075b\u0054\u0079\u0070\u0065")
	}
	_bfcaf.S = subtype
	return nil
}

func (_bbcgf *LTV) generateVRIKey(_aedfa *PdfSignature) (string, error) {
	_eccb, _ggggf := _bgde(_aedfa.Contents.Bytes())
	if _ggggf != nil {
		return "", _ggggf
	}
	return _gc.ToUpper(_ab.EncodeToString(_eccb)), nil
}

// NewPdfPageResources returns a new PdfPageResources object.
func NewPdfPageResources() *PdfPageResources {
	_abgd := &PdfPageResources{}
	_abgd._cecgg = _df.MakeDict()
	return _abgd
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// A, B and C components of the color. The values of the elements should be
// between 0 and 1.
func (_dbcg *PdfColorspaceCalRGB) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ecfe := vals[0]
	if _ecfe < 0.0 || _ecfe > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _ecfe)
		return nil, ErrColorOutOfRange
	}
	_bdeg := vals[1]
	if _bdeg < 0.0 || _bdeg > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _bdeg)
		return nil, ErrColorOutOfRange
	}
	_ebfb := vals[2]
	if _ebfb < 0.0 || _ebfb > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _ebfb)
		return nil, ErrColorOutOfRange
	}
	_cgeg := NewPdfColorCalRGB(_ecfe, _bdeg, _ebfb)
	return _cgeg, nil
}

func (_fgaf *PdfReader) newPdfPageFromDict(_dcaec *_df.PdfObjectDictionary) (*PdfPage, error) {
	_bcgdf := NewPdfPage()
	_bcgdf._gfcee = _dcaec
	_bcgdf._agacd = *_dcaec
	_bfege := *_dcaec
	_dacd, _dcaecc := _bfege.Get("\u0054\u0079\u0070\u0065").(*_df.PdfObjectName)
	if !_dcaecc {
		return nil, _deb.New("\u006d\u0069ss\u0069\u006e\u0067/\u0069\u006e\u0076\u0061lid\u0020Pa\u0067\u0065\u0020\u0064\u0069\u0063\u0074io\u006e\u0061\u0072\u0079\u0020\u0054\u0079p\u0065")
	}
	if *_dacd != "\u0050\u0061\u0067\u0065" {
		return nil, _deb.New("\u0070\u0061\u0067\u0065 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079 \u0054y\u0070\u0065\u0020\u0021\u003d\u0020\u0050a\u0067\u0065")
	}
	if _gefge := _bfege.Get("\u0050\u0061\u0072\u0065\u006e\u0074"); _gefge != nil {
		_bcgdf.Parent = _gefge
	}
	if _bceec := _bfege.Get("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064"); _bceec != nil {
		_cffbdg, _gcegc := _df.GetString(_bceec)
		if !_gcegc {
			return nil, _deb.New("\u0070\u0061\u0067\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u004c\u0061\u0073\u0074\u004d\u006f\u0064\u0069f\u0069\u0065\u0064\u0020\u0021=\u0020\u0073t\u0072\u0069\u006e\u0067")
		}
		_gbca, _dabac := NewPdfDate(_cffbdg.Str())
		if _dabac != nil {
			return nil, _dabac
		}
		_bcgdf.LastModified = &_gbca
	}
	if _fdcda := _bfege.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _fdcda != nil && !_df.IsNullObject(_fdcda) {
		_aedfb, _egbcca := _df.GetDict(_fdcda)
		if !_egbcca {
			return nil, _c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063e\u0020d\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _fdcda)
		}
		var _fdgga error
		_bcgdf.Resources, _fdgga = NewPdfPageResourcesFromDict(_aedfb)
		if _fdgga != nil {
			return nil, _fdgga
		}
	} else {
		_cdgee, _fgfgd := _bcgdf.getParentResources()
		if _fgfgd != nil {
			return nil, _fgfgd
		}
		if _cdgee == nil {
			_cdgee = NewPdfPageResources()
		}
		_bcgdf.Resources = _cdgee
	}
	if _fdggae := _bfege.Get("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078"); _fdggae != nil {
		_aefcg, _dbcab := _df.GetArray(_fdggae)
		if !_dbcab {
			return nil, _deb.New("\u0070\u0061\u0067\u0065\u0020\u004d\u0065\u0064\u0069\u0061\u0042o\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079")
		}
		var _bdebg error
		_bcgdf.MediaBox, _bdebg = NewPdfRectangle(*_aefcg)
		if _bdebg != nil {
			return nil, _bdebg
		}
	}
	if _fdegb := _bfege.Get("\u0043r\u006f\u0070\u0042\u006f\u0078"); _fdegb != nil {
		_eafb, _ebed := _df.GetArray(_fdegb)
		if !_ebed {
			return nil, _deb.New("\u0070a\u0067\u0065\u0020\u0043r\u006f\u0070\u0042\u006f\u0078 \u006eo\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061y")
		}
		var _afacg error
		_bcgdf.CropBox, _afacg = NewPdfRectangle(*_eafb)
		if _afacg != nil {
			return nil, _afacg
		}
	}
	if _cdcfd := _bfege.Get("\u0042\u006c\u0065\u0065\u0064\u0042\u006f\u0078"); _cdcfd != nil {
		_agbgd, _dgaag := _df.GetArray(_cdcfd)
		if !_dgaag {
			return nil, _deb.New("\u0070\u0061\u0067\u0065\u0020\u0042\u006c\u0065\u0065\u0064\u0042o\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079")
		}
		var _bfaeg error
		_bcgdf.BleedBox, _bfaeg = NewPdfRectangle(*_agbgd)
		if _bfaeg != nil {
			return nil, _bfaeg
		}
	}
	if _acfbc := _bfege.Get("\u0054r\u0069\u006d\u0042\u006f\u0078"); _acfbc != nil {
		_bagab, _eafbc := _df.GetArray(_acfbc)
		if !_eafbc {
			return nil, _deb.New("\u0070a\u0067\u0065\u0020\u0054r\u0069\u006d\u0042\u006f\u0078 \u006eo\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061y")
		}
		var _cecg error
		_bcgdf.TrimBox, _cecg = NewPdfRectangle(*_bagab)
		if _cecg != nil {
			return nil, _cecg
		}
	}
	if _eafcef := _bfege.Get("\u0041\u0072\u0074\u0042\u006f\u0078"); _eafcef != nil {
		_dcdfb, _dfega := _df.GetArray(_eafcef)
		if !_dfega {
			return nil, _deb.New("\u0070a\u0067\u0065\u0020\u0041\u0072\u0074\u0042\u006f\u0078\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
		}
		var _gacfe error
		_bcgdf.ArtBox, _gacfe = NewPdfRectangle(*_dcdfb)
		if _gacfe != nil {
			return nil, _gacfe
		}
	}
	if _gggec := _bfege.Get("\u0042\u006f\u0078C\u006f\u006c\u006f\u0072\u0049\u006e\u0066\u006f"); _gggec != nil {
		_bcgdf.BoxColorInfo = _gggec
	}
	if _bgdcd := _bfege.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"); _bgdcd != nil {
		_bcgdf.Contents = _bgdcd
	}
	if _dfbbf := _bfege.Get("\u0052\u006f\u0074\u0061\u0074\u0065"); _dfbbf != nil {
		_dgca, _fgafd := _df.GetNumberAsInt64(_dfbbf)
		if _fgafd != nil {
			return nil, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0067e\u0020\u0052\u006f\u0074\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		_bcgdf.Rotate = &_dgca
	}
	if _cdgaa := _bfege.Get("\u0047\u0072\u006fu\u0070"); _cdgaa != nil {
		_bcgdf.Group = _cdgaa
	}
	if _abfbec := _bfege.Get("\u0054\u0068\u0075m\u0062"); _abfbec != nil {
		_bcgdf.Thumb = _abfbec
	}
	if _dfefgg := _bfege.Get("\u0042"); _dfefgg != nil {
		_bcgdf.B = _dfefgg
	}
	if _gcddc := _bfege.Get("\u0044\u0075\u0072"); _gcddc != nil {
		_bcgdf.Dur = _gcddc
	}
	if _facbe := _bfege.Get("\u0054\u0072\u0061n\u0073"); _facbe != nil {
		_bcgdf.Trans = _facbe
	}
	if _dgagb := _bfege.Get("\u0041\u0041"); _dgagb != nil {
		_bcgdf.AA = _dgagb
	}
	if _ggcde := _bfege.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _ggcde != nil {
		_bcgdf.Metadata = _ggcde
	}
	if _fadfc := _bfege.Get("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o"); _fadfc != nil {
		_bcgdf.PieceInfo = _fadfc
	}
	if _aacbcg := _bfege.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073"); _aacbcg != nil {
		_bcgdf.StructParents = _aacbcg
	}
	if _eafe := _bfege.Get("\u0049\u0044"); _eafe != nil {
		_bcgdf.ID = _eafe
	}
	if _cgga := _bfege.Get("\u0050\u005a"); _cgga != nil {
		_bcgdf.PZ = _cgga
	}
	if _cfabd := _bfege.Get("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006fn\u0049\u006e\u0066\u006f"); _cfabd != nil {
		_bcgdf.SeparationInfo = _cfabd
	}
	if _fbadf := _bfege.Get("\u0054\u0061\u0062\u0073"); _fbadf != nil {
		_bcgdf.Tabs = _fbadf
	}
	if _dfbcc := _bfege.Get("T\u0065m\u0070\u006c\u0061\u0074\u0065\u0049\u006e\u0073t\u0061\u006e\u0074\u0069at\u0065\u0064"); _dfbcc != nil {
		_bcgdf.TemplateInstantiated = _dfbcc
	}
	if _bbefa := _bfege.Get("\u0050r\u0065\u0073\u0053\u0074\u0065\u0070s"); _bbefa != nil {
		_bcgdf.PresSteps = _bbefa
	}
	if _bgacg := _bfege.Get("\u0055\u0073\u0065\u0072\u0055\u006e\u0069\u0074"); _bgacg != nil {
		_bcgdf.UserUnit = _bgacg
	}
	if _cdacg := _bfege.Get("\u0056\u0050"); _cdacg != nil {
		_bcgdf.VP = _cdacg
	}
	if _addg := _bfege.Get("\u0041\u006e\u006e\u006f\u0074\u0073"); _addg != nil {
		_bcgdf.Annots = _addg
	}
	_bcgdf._cgacg = _fgaf
	return _bcgdf, nil
}

func _cgfc(_cfffb _df.PdfObject) (*PdfColorspaceSpecialSeparation, error) {
	_bdddf := NewPdfColorspaceSpecialSeparation()
	if _bgdb, _fdga := _cfffb.(*_df.PdfIndirectObject); _fdga {
		_bdddf._afad = _bgdb
	}
	_cfffb = _df.TraceToDirectObject(_cfffb)
	_ddgd, _gadgg := _cfffb.(*_df.PdfObjectArray)
	if !_gadgg {
		return nil, _c.Errorf("\u0073\u0065p\u0061\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062je\u0063\u0074")
	}
	if _ddgd.Len() != 4 {
		return nil, _c.Errorf("\u0073\u0065p\u0061\u0072\u0061\u0074i\u006f\u006e \u0043\u0053\u003a\u0020\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006ce\u006e\u0067\u0074\u0068")
	}
	_cfffb = _ddgd.Get(0)
	_eebad, _gadgg := _cfffb.(*_df.PdfObjectName)
	if !_gadgg {
		return nil, _c.Errorf("\u0073\u0065\u0070ar\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a \u0069n\u0076a\u006ci\u0064\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	if *_eebad != "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e" {
		return nil, _c.Errorf("\u0073\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a\u0020w\u0072o\u006e\u0067\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	_cfffb = _ddgd.Get(1)
	_eebad, _gadgg = _cfffb.(*_df.PdfObjectName)
	if !_gadgg {
		return nil, _c.Errorf("\u0073\u0065pa\u0072\u0061\u0074i\u006f\u006e\u0020\u0043S: \u0049nv\u0061\u006c\u0069\u0064\u0020\u0063\u006flo\u0072\u0061\u006e\u0074\u0020\u006e\u0061m\u0065")
	}
	_bdddf.ColorantName = _eebad
	_cfffb = _ddgd.Get(2)
	_gadb, _agfa := NewPdfColorspaceFromPdfObject(_cfffb)
	if _agfa != nil {
		return nil, _agfa
	}
	_bdddf.AlternateSpace = _gadb
	_bgdce, _agfa := _ddaac(_ddgd.Get(3))
	if _agfa != nil {
		return nil, _agfa
	}
	_bdddf.TintTransform = _bgdce
	return _bdddf, nil
}

type pdfCIDFontType2 struct {
	fontCommon
	_agee *_df.PdfIndirectObject
	_adfa _abg.TextEncoder

	// Table 117 – Entries in a CIDFont dictionary (page 269)
	// Dictionary that defines the character collection of the CIDFont (required).
	// See Table 116.
	CIDSystemInfo *_df.PdfObjectDictionary

	// Glyph metrics fields (optional).
	DW  _df.PdfObject
	W   _df.PdfObject
	DW2 _df.PdfObject
	W2  _df.PdfObject

	// CIDs to glyph indices mapping (optional).
	CIDToGIDMap _df.PdfObject
	_ddggg      map[_abg.CharCode]float64
	_feab       float64
	_dbcecg     map[rune]int
}

func (_gfdad *PdfWriter) writeOutlines() error {
	if _gfdad._cfgeg == nil {
		return nil
	}
	_bcd.Log.Trace("\u004f\u0075t\u006c\u0069\u006ee\u0054\u0072\u0065\u0065\u003a\u0020\u0025\u002b\u0076", _gfdad._cfgeg)
	_affb := _gfdad._cfgeg.ToPdfObject()
	_bcd.Log.Trace("\u004fu\u0074\u006c\u0069\u006e\u0065\u0073\u003a\u0020\u0025\u002b\u0076 \u0028\u0025\u0054\u002c\u0020\u0070\u003a\u0025\u0070\u0029", _affb, _affb, _affb)
	_gfdad._gdee.Set("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073", _affb)
	_bdcbe := _gfdad.addObjects(_affb)
	if _bdcbe != nil {
		return _bdcbe
	}
	return nil
}

// Clear clears the KValue.
func (_edcea *KValue) Clear() { _edcea._eebde = nil; _edcea._ccgeg = nil; _edcea._dfca = nil }

// PdfAnnotationPolyLine represents PolyLine annotations.
// (Section 12.5.6.9).
type PdfAnnotationPolyLine struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Vertices _df.PdfObject
	LE       _df.PdfObject
	BS       _df.PdfObject
	IC       _df.PdfObject
	BE       _df.PdfObject
	IT       _df.PdfObject
	Measure  _df.PdfObject
}

// Evaluate runs the function on the passed in slice and returns the results.
func (_afcgf *PdfFunctionType2) Evaluate(x []float64) ([]float64, error) {
	if len(x) != 1 {
		_bcd.Log.Error("\u004f\u006e\u006c\u0079 o\u006e\u0065\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0061\u006c\u006c\u006f\u0077e\u0064")
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dgebg := []float64{0.0}
	if _afcgf.C0 != nil {
		_dgebg = _afcgf.C0
	}
	_cdec := []float64{1.0}
	if _afcgf.C1 != nil {
		_cdec = _afcgf.C1
	}
	var _gdacf []float64
	for _ebdbc := 0; _ebdbc < len(_dgebg); _ebdbc++ {
		_eaae := _dgebg[_ebdbc] + _faf.Pow(x[0], _afcgf.N)*(_cdec[_ebdbc]-_dgebg[_ebdbc])
		_gdacf = append(_gdacf, _eaae)
	}
	return _gdacf, nil
}

// PdfShadingType6 is a Coons patch mesh.
type PdfShadingType6 struct {
	*PdfShading
	BitsPerCoordinate *_df.PdfObjectInteger
	BitsPerComponent  *_df.PdfObjectInteger
	BitsPerFlag       *_df.PdfObjectInteger
	Decode            *_df.PdfObjectArray
	Function          []PdfFunction
}

// NewPdfFontFromTTF loads a TTF font and returns a PdfFont type that can be
// used in text styling functions.
// Uses a WinAnsiTextEncoder and loads only character codes 32-255.
// NOTE: For composite fonts such as used in symbolic languages, use NewCompositePdfFontFromTTF.
func NewPdfFontFromTTF(r _bdd.ReadSeeker) (*PdfFont, error) {
	const _ceefb = _abg.CharCode(32)
	const _edcfc = _abg.CharCode(255)
	_afcgbd, _bdde := _bdd.ReadAll(r)
	if _bdde != nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074s\u003a\u0020\u0025\u0076", _bdde)
		return nil, _bdde
	}
	_eagbd, _bdde := _da.TtfParse(_ef.NewReader(_afcgbd))
	if _bdde != nil {
		_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020l\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0054\u0054F\u0020\u0066\u006fn\u0074:\u0020\u0025\u0076", _bdde)
		return nil, _bdde
	}
	_fefdg := &pdfFontSimple{_ffefd: make(map[_abg.CharCode]float64), fontCommon: fontCommon{_fgfae: "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065"}}
	_fefdg._ebgg = _abg.NewWinAnsiEncoder()
	_fefdg._gddcf = _eagbd.PostScriptName
	_fefdg.FirstChar = _df.MakeInteger(int64(_ceefb))
	_fefdg.LastChar = _df.MakeInteger(int64(_edcfc))
	_dcaa := 1000.0 / float64(_eagbd.UnitsPerEm)
	if len(_eagbd.Widths) <= 0 {
		return nil, _deb.New("\u0045\u0052\u0052O\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u0028\u0057\u0069\u0064\u0074\u0068\u0073\u0029")
	}
	_ccfcb := _dcaa * float64(_eagbd.Widths[0])
	_gfegd := make([]float64, 0, _edcfc-_ceefb+1)
	for _eecg := _ceefb; _eecg <= _edcfc; _eecg++ {
		_bdfbd, _abbe := _fefdg.Encoder().CharcodeToRune(_eecg)
		if !_abbe {
			_bcd.Log.Debug("\u0052u\u006e\u0065\u0020\u006eo\u0074\u0020\u0066\u006f\u0075n\u0064 \u0028c\u006f\u0064\u0065\u003a\u0020\u0025\u0064)", _eecg)
			_gfegd = append(_gfegd, _ccfcb)
			continue
		}
		_cbfff, _deab := _eagbd.Chars[_bdfbd]
		if !_deab {
			_bcd.Log.Debug("R\u0075\u006e\u0065\u0020no\u0074 \u0069\u006e\u0020\u0054\u0054F\u0020\u0043\u0068\u0061\u0072\u0073")
			_gfegd = append(_gfegd, _ccfcb)
			continue
		}
		_abfe := _dcaa * float64(_eagbd.Widths[_cbfff])
		_gfegd = append(_gfegd, _abfe)
	}
	_fefdg.Widths = _df.MakeIndirectObject(_df.MakeArrayFromFloats(_gfegd))
	if len(_gfegd) < int(_edcfc-_ceefb+1) {
		_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u006f\u0066\u0020\u0077\u0069\u0064\u0074\u0068s,\u0020\u0025\u0064 \u003c \u0025\u0064", len(_gfegd), 255-32+1)
		return nil, _df.ErrRangeError
	}
	for _aaba := _ceefb; _aaba <= _edcfc; _aaba++ {
		_fefdg._ffefd[_aaba] = _gfegd[_aaba-_ceefb]
	}
	_fefdg.Encoding = _df.MakeName("\u0057i\u006eA\u006e\u0073\u0069\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067")
	_dfdg := &PdfFontDescriptor{}
	_dfdg.FontName = _df.MakeName(_eagbd.PostScriptName)
	_dfdg.Ascent = _df.MakeFloat(_dcaa * float64(_eagbd.TypoAscender))
	_dfdg.Descent = _df.MakeFloat(_dcaa * float64(_eagbd.TypoDescender))
	_dfdg.CapHeight = _df.MakeFloat(_dcaa * float64(_eagbd.CapHeight))
	_dfdg.FontBBox = _df.MakeArrayFromFloats([]float64{_dcaa * float64(_eagbd.Xmin), _dcaa * float64(_eagbd.Ymin), _dcaa * float64(_eagbd.Xmax), _dcaa * float64(_eagbd.Ymax)})
	_dfdg.ItalicAngle = _df.MakeFloat(_eagbd.ItalicAngle)
	_dfdg.MissingWidth = _df.MakeFloat(_dcaa * float64(_eagbd.Widths[0]))
	_bbcgb, _bdde := _df.MakeStream(_afcgbd, _df.NewFlateEncoder())
	if _bdde != nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074o\u0020m\u0061\u006b\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _bdde)
		return nil, _bdde
	}
	_bbcgb.PdfObjectDictionary.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _df.MakeInteger(int64(len(_afcgbd))))
	_dfdg.FontFile2 = _bbcgb
	if _eagbd.Bold {
		_dfdg.StemV = _df.MakeInteger(120)
	} else {
		_dfdg.StemV = _df.MakeInteger(70)
	}
	_ggaeg := _fgdde
	if _eagbd.IsFixedPitch {
		_ggaeg |= _cfef
	}
	if _eagbd.ItalicAngle != 0 {
		_ggaeg |= _aacc
	}
	_dfdg.Flags = _df.MakeInteger(int64(_ggaeg))
	_fefdg._agggb = _dfdg
	_bbded := &PdfFont{_eaeg: _fefdg}
	return _bbded, nil
}

func (_dcefg *PdfWriter) writeXRefStreams(_eddeg int, _aeeba int64) error {
	_gcafc := _eddeg + 1
	_dcefg._cdgd[_gcafc] = crossReference{Type: 1, ObjectNumber: _gcafc, Offset: _aeeba}
	_fcdeg := _ef.NewBuffer(nil)
	_bgfbgd := _df.MakeArray()
	for _fecda := 0; _fecda <= _eddeg; {
		for ; _fecda <= _eddeg; _fecda++ {
			_dfcbb, _gagga := _dcefg._cdgd[_fecda]
			if _gagga && (!_dcefg._gebfg || _dcefg._gebfg && (_dfcbb.Type == 1 && _dfcbb.Offset >= _dcefg._acfdce || _dfcbb.Type == 0)) {
				break
			}
		}
		var _babd int
		for _babd = _fecda + 1; _babd <= _eddeg; _babd++ {
			_cfcafa, _gddea := _dcefg._cdgd[_babd]
			if _gddea && (!_dcefg._gebfg || _dcefg._gebfg && (_cfcafa.Type == 1 && _cfcafa.Offset > _dcefg._acfdce)) {
				continue
			}
			break
		}
		_bgfbgd.Append(_df.MakeInteger(int64(_fecda)), _df.MakeInteger(int64(_babd-_fecda)))
		for _eacd := _fecda; _eacd < _babd; _eacd++ {
			_bddaf := _dcefg._cdgd[_eacd]
			switch _bddaf.Type {
			case 0:
				_bd.Write(_fcdeg, _bd.BigEndian, byte(0))
				_bd.Write(_fcdeg, _bd.BigEndian, uint32(0))
				_bd.Write(_fcdeg, _bd.BigEndian, uint16(0xFFFF))
			case 1:
				_bd.Write(_fcdeg, _bd.BigEndian, byte(1))
				_bd.Write(_fcdeg, _bd.BigEndian, uint32(_bddaf.Offset))
				_bd.Write(_fcdeg, _bd.BigEndian, uint16(_bddaf.Generation))
			case 2:
				_bd.Write(_fcdeg, _bd.BigEndian, byte(2))
				_bd.Write(_fcdeg, _bd.BigEndian, uint32(_bddaf.ObjectNumber))
				_bd.Write(_fcdeg, _bd.BigEndian, uint16(_bddaf.Index))
			}
		}
		_fecda = _babd + 1
	}
	_fdbbc, _ddaed := _df.MakeStream(_fcdeg.Bytes(), _df.NewFlateEncoder())
	if _ddaed != nil {
		return _ddaed
	}
	_fdbbc.ObjectNumber = int64(_gcafc)
	_fdbbc.PdfObjectDictionary.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0058\u0052\u0065\u0066"))
	_fdbbc.PdfObjectDictionary.Set("\u0057", _df.MakeArray(_df.MakeInteger(1), _df.MakeInteger(4), _df.MakeInteger(2)))
	_fdbbc.PdfObjectDictionary.Set("\u0049\u006e\u0064e\u0078", _bgfbgd)
	_fdbbc.PdfObjectDictionary.Set("\u0053\u0069\u007a\u0065", _df.MakeInteger(int64(_gcafc)))
	_fdbbc.PdfObjectDictionary.Set("\u0049\u006e\u0066\u006f", _dcefg._caefe)
	_fdbbc.PdfObjectDictionary.Set("\u0052\u006f\u006f\u0074", _dcefg._aaag)
	if _dcefg._gebfg && _dcefg._ebfcba > 0 {
		_fdbbc.PdfObjectDictionary.Set("\u0050\u0072\u0065\u0076", _df.MakeInteger(_dcefg._ebfcba))
	}
	if _dcefg._fcdg != nil {
		_fdbbc.Set("\u0045n\u0063\u0072\u0079\u0070\u0074", _dcefg._deega)
	}
	if _dcefg._fgdf == nil && _dcefg._aadde != "" && _dcefg._addee != "" {
		_dcefg._fgdf = _df.MakeArray(_df.MakeHexString(_dcefg._aadde), _df.MakeHexString(_dcefg._addee))
	}
	if _dcefg._fgdf != nil {
		_bcd.Log.Trace("\u0049d\u0073\u003a\u0020\u0025\u0073", _dcefg._fgdf)
		_fdbbc.Set("\u0049\u0044", _dcefg._fgdf)
	}
	_dcefg.writeObject(int(_fdbbc.ObjectNumber), _fdbbc)
	return nil
}

// NewPdfShadingType2 creates an empty shading type 2 dictionary.
func NewPdfShadingType2() *PdfShadingType2 {
	_cbbfg := &PdfShadingType2{}
	_cbbfg.PdfShading = &PdfShading{}
	_cbbfg.PdfShading._bgdag = _df.MakeIndirectObject(_df.MakeDict())
	_cbbfg.PdfShading._dggab = _cbbfg
	return _cbbfg
}

// AddPage adds a page to the PDF file. The new page should be an indirect object.
func (_aegdc *PdfWriter) AddPage(page *PdfPage) error {
	const _agfe = "\u006d\u006f\u0064el\u003a\u0050\u0064\u0066\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065"
	_dfdde(page)
	_cgcba := page.ToPdfObject()
	_bcd.Log.Trace("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d")
	_bcd.Log.Trace("\u0041p\u0070\u0065\u006e\u0064i\u006e\u0067\u0020\u0074\u006f \u0070a\u0067e\u0020\u006c\u0069\u0073\u0074\u0020\u0025T", _cgcba)
	_dfdbg, _bagca := _df.GetIndirect(_cgcba)
	if !_bagca {
		return _deb.New("\u0070\u0061\u0067\u0065\u0020\u0073h\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006fb\u006a\u0065\u0063\u0074")
	}
	_bcd.Log.Trace("\u0025\u0073", _dfdbg)
	_bcd.Log.Trace("\u0025\u0073", _dfdbg.PdfObject)
	_ebgef, _bagca := _df.GetDict(_dfdbg.PdfObject)
	if !_bagca {
		return _deb.New("\u0070\u0061\u0067e \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0068o\u0075l\u0064 \u0062e\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_dgabg, _bagca := _df.GetName(_ebgef.Get("\u0054\u0079\u0070\u0065"))
	if !_bagca {
		return _c.Errorf("\u0070\u0061\u0067\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054y\u0070\u0065\u0020\u006b\u0065\u0079\u0020\u0077\u0069t\u0068\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u006f\u0066\u0020t\u0079\u0070\u0065\u0020\u006e\u0061m\u0065\u0020\u0028%\u0054\u0029", _ebgef.Get("\u0054\u0079\u0070\u0065"))
	}
	if _dgabg.String() != "\u0050\u0061\u0067\u0065" {
		return _deb.New("\u0066\u0069e\u006c\u0064\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020\u0050\u0061\u0067\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069re\u0064\u0029")
	}
	_agbdde := []_df.PdfObjectName{"\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", "\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", "\u0043r\u006f\u0070\u0042\u006f\u0078", "\u0052\u006f\u0074\u0061\u0074\u0065"}
	_ccbcbc, _ccfff := _df.GetIndirect(_ebgef.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
	_bcd.Log.Trace("P\u0061g\u0065\u0020\u0050\u0061\u0072\u0065\u006e\u0074:\u0020\u0025\u0054\u0020(%\u0076\u0029", _ebgef.Get("\u0050\u0061\u0072\u0065\u006e\u0074"), _ccfff)
	for _ccfff {
		_bcd.Log.Trace("\u0050a\u0067e\u0020\u0050\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _ccbcbc)
		_feba, _gdeb := _df.GetDict(_ccbcbc.PdfObject)
		if !_gdeb {
			return _deb.New("i\u006e\u0076\u0061\u006cid\u0020P\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
		}
		for _, _ddbgf := range _agbdde {
			_bcd.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _ddbgf)
			if _ebgef.Get(_ddbgf) != nil {
				_bcd.Log.Trace("\u002d \u0070a\u0067\u0065\u0020\u0068\u0061s\u0020\u0061l\u0072\u0065\u0061\u0064\u0079")
				continue
			}
			if _fbeae := _feba.Get(_ddbgf); _fbeae != nil {
				_bcd.Log.Trace("\u0049\u006e\u0068\u0065ri\u0074\u0069\u006e\u0067\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _ddbgf)
				_ebgef.Set(_ddbgf, _fbeae)
			}
		}
		_ccbcbc, _ccfff = _df.GetIndirect(_feba.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
		_bcd.Log.Trace("\u004ee\u0078t\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _feba.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
	}
	_bcd.Log.Trace("\u0054\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c \u0064\u006f\u006e\u0065")
	_ebgef.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _aegdc._ggdac)
	_dfdbg.PdfObject = _ebgef
	_dbdfc, _bagca := _df.GetDict(_aegdc._ggdac.PdfObject)
	if !_bagca {
		return _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0020(\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0029")
	}
	_eagag, _bagca := _df.GetArray(_dbdfc.Get("\u004b\u0069\u0064\u0073"))
	if !_bagca {
		return _deb.New("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0050\u0061g\u0065\u0073\u0020\u004b\u0069\u0064\u0073\u0020o\u0062\u006a\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079\u0029")
	}
	_eagag.Append(_dfdbg)
	_aegdc._fddef[_ebgef] = struct{}{}
	_aegdc._aaadf = append(_aegdc._aaadf, _dfdbg)
	_dfgdf, _bagca := _df.GetInt(_dbdfc.Get("\u0043\u006f\u0075n\u0074"))
	if !_bagca {
		return _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u0050\u0061\u0067e\u0073\u0020\u0043\u006fu\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0029")
	}
	*_dfgdf = *_dfgdf + 1
	if page._cgacg == nil {
		_eadfc := _abc.Track(_aegdc._gcfcfa, _agfe, _aegdc._bfbb)
		if _eadfc != nil {
			return _eadfc
		}
	} else {
		_eadbgf := _abc.Track(page._cgacg._bdcaa, _agfe, page._cgacg._effbb)
		if _eadbgf != nil {
			return _eadbgf
		}
	}
	_aegdc.addObject(_dfdbg)
	_fcfedb := _aegdc.addObjects(_ebgef)
	if _fcfedb != nil {
		return _fcfedb
	}
	return nil
}

func _egebb(_gdcgb *_df.PdfObjectArray) (float64, error) {
	_aaceb, _cgfbe := _gdcgb.ToFloat64Array()
	if _cgfbe != nil {
		_bcd.Log.Debug("\u0042\u0061\u0064\u0020\u004d\u0061\u0074\u0074\u0065\u0020\u0061\u0072\u0072\u0061\u0079:\u0020m\u0061\u0074\u0074\u0065\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _gdcgb, _cgfbe)
	}
	switch len(_aaceb) {
	case 1:
		return _aaceb[0], nil
	case 3:
		_defd := PdfColorspaceDeviceRGB{}
		_cgacd, _dbfgc := _defd.ColorFromFloats(_aaceb)
		if _dbfgc != nil {
			return 0.0, _dbfgc
		}
		return _cgacd.(*PdfColorDeviceRGB).ToGray().Val(), nil
	case 4:
		_bfbf := PdfColorspaceDeviceCMYK{}
		_bcfdf, _dcabd := _bfbf.ColorFromFloats(_aaceb)
		if _dcabd != nil {
			return 0.0, _dcabd
		}
		_eabdf, _dcabd := _bfbf.ColorToRGB(_bcfdf.(*PdfColorDeviceCMYK))
		if _dcabd != nil {
			return 0.0, _dcabd
		}
		return _eabdf.(*PdfColorDeviceRGB).ToGray().Val(), nil
	}
	_cgfbe = _deb.New("\u0062a\u0064 \u004d\u0061\u0074\u0074\u0065\u0020\u0063\u006f\u006c\u006f\u0072")
	_bcd.Log.Error("\u0074\u006f\u0047ra\u0079\u003a\u0020\u006d\u0061\u0074\u0074\u0065\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _gdcgb, _cgfbe)
	return 0.0, _cgfbe
}

// DecodeArray returns the component range values for the Indexed colorspace.
func (_fbggb *PdfColorspaceSpecialIndexed) DecodeArray() []float64 {
	return []float64{0, float64(_fbggb.HiVal)}
}

var _cefee = map[string]string{"\u0053\u0079\u006d\u0062\u006f\u006c": "\u0053\u0079\u006d\u0062\u006f\u006c\u0045\u006e\u0063o\u0064\u0069\u006e\u0067", "\u005a\u0061\u0070f\u0044\u0069\u006e\u0067\u0062\u0061\u0074\u0073": "Z\u0061p\u0066\u0044\u0069\u006e\u0067\u0062\u0061\u0074s\u0045\u006e\u0063\u006fdi\u006e\u0067"}

func (_cebb *PdfReader) newPdfAnnotationRedactFromDict(_eebg *_df.PdfObjectDictionary) (*PdfAnnotationRedact, error) {
	_fed := PdfAnnotationRedact{}
	_dffc, _edfe := _cebb.newPdfAnnotationMarkupFromDict(_eebg)
	if _edfe != nil {
		return nil, _edfe
	}
	_fed.PdfAnnotationMarkup = _dffc
	_fed.QuadPoints = _eebg.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	_fed.IC = _eebg.Get("\u0049\u0043")
	_fed.RO = _eebg.Get("\u0052\u004f")
	_fed.OverlayText = _eebg.Get("O\u0076\u0065\u0072\u006c\u0061\u0079\u0054\u0065\u0078\u0074")
	_fed.Repeat = _eebg.Get("\u0052\u0065\u0070\u0065\u0061\u0074")
	_fed.DA = _eebg.Get("\u0044\u0041")
	_fed.Q = _eebg.Get("\u0051")
	return &_fed, nil
}

func (_ede *PdfReader) newPdfAnnotationMovieFromDict(_aba *_df.PdfObjectDictionary) (*PdfAnnotationMovie, error) {
	_bbgc := PdfAnnotationMovie{}
	_bbgc.T = _aba.Get("\u0054")
	_bbgc.Movie = _aba.Get("\u004d\u006f\u0076i\u0065")
	_bbgc.A = _aba.Get("\u0041")
	return &_bbgc, nil
}

// PdfAnnotationPopup represents Popup annotations.
// (Section 12.5.6.14).
type PdfAnnotationPopup struct {
	*PdfAnnotation
	Parent _df.PdfObject
	Open   _df.PdfObject
}

// ToPdfObject generates a PdfObject representation of the Names struct.
func (_deaef *Names) ToPdfObject() _df.PdfObject {
	_babbe := _deaef._dfag
	_baegb, _cegee := _babbe.PdfObject.(*_df.PdfObjectDictionary)
	if !_cegee {
		_bcd.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006fb\u006a\u0065\u0063\u0074")
		return _babbe
	}
	if _deaef.EmbeddedFiles != nil {
		_baegb.Set("\u0045\u006d\u0062\u0065\u0064\u0064\u0065\u0064\u0046\u0069\u006c\u0065\u0073", _df.MakeIndirectObject(_deaef.EmbeddedFiles))
	}
	return _babbe
}

// NewOutlineBookmark returns an initialized PdfOutlineItem for a given bookmark title and page.
func NewOutlineBookmark(title string, page *_df.PdfIndirectObject) *PdfOutlineItem {
	_fdcba := PdfOutlineItem{}
	_fdcba._dcgc = &_fdcba
	_fdcba.Title = _df.MakeString(title)
	_dddd := _df.MakeArray()
	_dddd.Append(page)
	_dddd.Append(_df.MakeName("\u0046\u0069\u0074"))
	_fdcba.Dest = _dddd
	return &_fdcba
}

// ToPdfObject implements interface PdfModel.
// Note: Call the sub-annotation's ToPdfObject to set both the generic and non-generic information.
func (_edeb *PdfAnnotation) ToPdfObject() _df.PdfObject {
	_bbbf := _edeb._bfde
	_afbb := _bbbf.PdfObject.(*_df.PdfObjectDictionary)
	_afbb.Clear()
	_afbb.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0041\u006e\u006eo\u0074"))
	_afbb.SetIfNotNil("\u0052\u0065\u0063\u0074", _edeb.Rect)
	_afbb.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _edeb.Contents)
	_afbb.SetIfNotNil("\u0050", _edeb.P)
	_afbb.SetIfNotNil("\u004e\u004d", _edeb.NM)
	_afbb.SetIfNotNil("\u004d", _edeb.M)
	_afbb.SetIfNotNil("\u0046", _edeb.F)
	_afbb.SetIfNotNil("\u0041\u0050", _edeb.AP)
	_afbb.SetIfNotNil("\u0041\u0053", _edeb.AS)
	_afbb.SetIfNotNil("\u0042\u006f\u0072\u0064\u0065\u0072", _edeb.Border)
	_afbb.SetIfNotNil("\u0043", _edeb.C)
	_afbb.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _edeb.StructParent)
	_afbb.SetIfNotNil("\u004f\u0043", _edeb.OC)
	return _bbbf
}

// GetNumComponents returns the number of color components (1 for Separation).
func (_eedef *PdfColorspaceSpecialSeparation) GetNumComponents() int { return 1 }

func (_efdd *PdfColorspaceDeviceGray) String() string {
	return "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079"
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components.
func (_dfeg *PdfColorspaceICCBased) ColorFromFloats(vals []float64) (PdfColor, error) {
	if _dfeg.Alternate == nil {
		if _dfeg.N == 1 {
			_adea := NewPdfColorspaceDeviceGray()
			return _adea.ColorFromFloats(vals)
		} else if _dfeg.N == 3 {
			_edde := NewPdfColorspaceDeviceRGB()
			return _edde.ColorFromFloats(vals)
		} else if _dfeg.N == 4 {
			_bgfe := NewPdfColorspaceDeviceCMYK()
			return _bgfe.ColorFromFloats(vals)
		} else {
			return nil, _deb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	return _dfeg.Alternate.ColorFromFloats(vals)
}

// NewPdfAnnotationWidget returns an initialized annotation widget.
func NewPdfAnnotationWidget() *PdfAnnotationWidget {
	_fcg := NewPdfAnnotation()
	_dcbg := &PdfAnnotationWidget{}
	_dcbg.PdfAnnotation = _fcg
	_fcg.SetContext(_dcbg)
	return _dcbg
}

// Size returns the width and the height of the page. The method reports
// the page dimensions as displayed by a PDF viewer (i.e. page rotation is
// taken into account).
func (_acgbe *PdfPage) Size() (float64, float64, error) {
	_cabbcd, _adbfe := _acgbe.GetMediaBox()
	if _adbfe != nil {
		return 0, 0, _adbfe
	}
	_dbgc, _eegfe := _cabbcd.Width(), _cabbcd.Height()
	_cddce, _adbfe := _acgbe.GetRotate()
	if _adbfe != nil {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a", _adbfe.Error())
	}
	if _ddfac := _cddce; _ddfac%360 != 0 && _ddfac%90 == 0 {
		if _dfeaa := (360 + _ddfac%360) % 360; _dfeaa == 90 || _dfeaa == 270 {
			_dbgc, _eegfe = _eegfe, _dbgc
		}
	}
	return _dbgc, _eegfe, nil
}

// SetXObjectFormByName adds the provided XObjectForm to the page resources.
// The added XObjectForm is identified by the specified name.
func (_aded *PdfPageResources) SetXObjectFormByName(keyName _df.PdfObjectName, xform *XObjectForm) error {
	_dcaf := xform.ToPdfObject().(*_df.PdfObjectStream)
	_gaffa := _aded.SetXObjectByName(keyName, _dcaf)
	return _gaffa
}

func _ddeec(_gdef _df.PdfObject) (*PdfFunctionType2, error) {
	_fggde := &PdfFunctionType2{}
	var _gaad *_df.PdfObjectDictionary
	if _bfacc, _dbcbc := _gdef.(*_df.PdfIndirectObject); _dbcbc {
		_cbfaf, _bdce := _bfacc.PdfObject.(*_df.PdfObjectDictionary)
		if !_bdce {
			return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_fggde._fffb = _bfacc
		_gaad = _cbfaf
	} else if _gebf, _egbcce := _gdef.(*_df.PdfObjectDictionary); _egbcce {
		_gaad = _gebf
	} else {
		return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_bcd.Log.Trace("\u0046U\u004e\u0043\u0032\u003a\u0020\u0025s", _gaad.String())
	_efgf, _ccdf := _df.TraceToDirectObject(_gaad.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_df.PdfObjectArray)
	if !_ccdf {
		_bcd.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _deb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _efgf.Len() < 0 || _efgf.Len()%2 != 0 {
		_bcd.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u0072\u0061\u006e\u0067e\u0020\u0069\u006e\u0076al\u0069\u0064")
		return nil, _deb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_acfdc, _bdff := _efgf.ToFloat64Array()
	if _bdff != nil {
		return nil, _bdff
	}
	_fggde.Domain = _acfdc
	_efgf, _ccdf = _df.TraceToDirectObject(_gaad.Get("\u0052\u0061\u006eg\u0065")).(*_df.PdfObjectArray)
	if _ccdf {
		if _efgf.Len() < 0 || _efgf.Len()%2 != 0 {
			return nil, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_addda, _gdcga := _efgf.ToFloat64Array()
		if _gdcga != nil {
			return nil, _gdcga
		}
		_fggde.Range = _addda
	}
	_efgf, _ccdf = _df.TraceToDirectObject(_gaad.Get("\u0043\u0030")).(*_df.PdfObjectArray)
	if _ccdf {
		_gbadg, _eccee := _efgf.ToFloat64Array()
		if _eccee != nil {
			return nil, _eccee
		}
		_fggde.C0 = _gbadg
	}
	_efgf, _ccdf = _df.TraceToDirectObject(_gaad.Get("\u0043\u0031")).(*_df.PdfObjectArray)
	if _ccdf {
		_fdfa, _fgefd := _efgf.ToFloat64Array()
		if _fgefd != nil {
			return nil, _fgefd
		}
		_fggde.C1 = _fdfa
	}
	if len(_fggde.C0) != len(_fggde.C1) {
		_bcd.Log.Error("\u0043\u0030\u0020\u0061nd\u0020\u0043\u0031\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0074\u0063\u0068\u0069n\u0067")
		return nil, _df.ErrRangeError
	}
	N, _bdff := _df.GetNumberAsFloat(_df.TraceToDirectObject(_gaad.Get("\u004e")))
	if _bdff != nil {
		_bcd.Log.Error("\u004e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020o\u0072\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u002c\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073", _gaad.String())
		return nil, _bdff
	}
	_fggde.N = N
	return _fggde, nil
}

func (_ddceg *PdfPage) loadFont(_dgdcc string) (*_fg.Font, error) {
	_fdgb, _deadd := _bf.ReadFile(_dgdcc)
	if _deadd != nil {
		return nil, _deadd
	}
	_acecf, _deadd := _ggb.ParseFont(_fdgb)
	if _deadd != nil {
		return nil, _deadd
	}
	return _acecf, nil
}

// GetOCProperties returns the optional content properties PdfObject.
func (_ddgag *PdfReader) GetOCProperties() (_df.PdfObject, error) {
	_adeb := _ddgag._afbaf
	_ggabe := _adeb.Get("\u004f\u0043\u0050r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073")
	_ggabe = _df.ResolveReference(_ggabe)
	if !_ddgag._edbbdf {
		_fbccf := _ddgag.traverseObjectData(_ggabe)
		if _fbccf != nil {
			return nil, _fbccf
		}
	}
	return _ggabe, nil
}

// PdfShadingPatternType2 is shading patterns that will use a Type 2 shading pattern (Axial).
type PdfShadingPatternType2 struct {
	*PdfPattern
	Shading   *PdfShadingType2
	Matrix    *_df.PdfObjectArray
	ExtGState _df.PdfObject
}

// ToPdfObject implements interface PdfModel.
func (_aaec *PdfAnnotationCircle) ToPdfObject() _df.PdfObject {
	_aaec.PdfAnnotation.ToPdfObject()
	_eagc := _aaec._bfde
	_ebac := _eagc.PdfObject.(*_df.PdfObjectDictionary)
	_aaec.PdfAnnotationMarkup.appendToPdfDictionary(_ebac)
	_ebac.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0043\u0069\u0072\u0063\u006c\u0065"))
	_ebac.SetIfNotNil("\u0042\u0053", _aaec.BS)
	_ebac.SetIfNotNil("\u0049\u0043", _aaec.IC)
	_ebac.SetIfNotNil("\u0042\u0045", _aaec.BE)
	_ebac.SetIfNotNil("\u0052\u0044", _aaec.RD)
	return _eagc
}

// SetPageLabels sets the PageLabels entry in the PDF catalog.
// See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
func (_dfdbc *PdfWriter) SetPageLabels(pageLabels _df.PdfObject) error {
	if pageLabels == nil {
		return nil
	}
	_bcd.Log.Trace("\u0053\u0065t\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006cs.\u002e\u002e")
	_dfdbc._gdee.Set("\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006c\u0073", pageLabels)
	return _dfdbc.addObjects(pageLabels)
}

// ToPdfObject implements interface PdfModel.
func (_fdbc *PdfAnnotationSquiggly) ToPdfObject() _df.PdfObject {
	_fdbc.PdfAnnotation.ToPdfObject()
	_aadg := _fdbc._bfde
	_gcb := _aadg.PdfObject.(*_df.PdfObjectDictionary)
	_fdbc.PdfAnnotationMarkup.appendToPdfDictionary(_gcb)
	_gcb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0053\u0071\u0075\u0069\u0067\u0067\u006c\u0079"))
	_gcb.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _fdbc.QuadPoints)
	return _aadg
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// red, green and blue components of the color. The values of the elements
// should be between 0 and 1.
func (_eabd *PdfColorspaceDeviceRGB) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bcaa := vals[0]
	if _bcaa < 0.0 || _bcaa > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _bcaa)
		return nil, ErrColorOutOfRange
	}
	_aadbe := vals[1]
	if _aadbe < 0.0 || _aadbe > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _bcaa)
		return nil, ErrColorOutOfRange
	}
	_fcab := vals[2]
	if _fcab < 0.0 || _fcab > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _bcaa)
		return nil, ErrColorOutOfRange
	}
	_cfdca := NewPdfColorDeviceRGB(_bcaa, _aadbe, _fcab)
	return _cfdca, nil
}

func (_aabc *PdfReader) newPdfSignatureReferenceFromDict(_acgg *_df.PdfObjectDictionary) (*PdfSignatureReference, error) {
	if _bcgdbd, _gaffg := _aabc._ceggc.GetModelFromPrimitive(_acgg).(*PdfSignatureReference); _gaffg {
		return _bcgdbd, nil
	}
	_bbgeg := &PdfSignatureReference{_fabaf: _acgg, Data: _acgg.Get("\u0044\u0061\u0074\u0061")}
	var _dffdg bool
	_bbgeg.Type, _ = _df.GetName(_acgg.Get("\u0054\u0079\u0070\u0065"))
	_bbgeg.TransformMethod, _dffdg = _df.GetName(_acgg.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"))
	if !_dffdg {
		_bcd.Log.Error("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069g\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0054\u0072\u0061\u006e\u0073\u0066o\u0072\u006dM\u0065\u0074h\u006f\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020in\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0072\u0020m\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	_bbgeg.TransformParams, _ = _df.GetDict(_acgg.Get("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"))
	_bbgeg.DigestMethod, _ = _df.GetName(_acgg.Get("\u0044\u0069\u0067e\u0073\u0074\u004d\u0065\u0074\u0068\u006f\u0064"))
	return _bbgeg, nil
}

func (_dcd *PdfReader) newPdfActionGotoFromDict(_dac *_df.PdfObjectDictionary) (*PdfActionGoTo, error) {
	return &PdfActionGoTo{D: _dac.Get("\u0044")}, nil
}

// Duplex returns the value of the duplex.
func (_bdfbc *ViewerPreferences) Duplex() Duplex { return _bdfbc._aecfg }

// PdfOutlineTreeNode contains common fields used by the outline and outline
// item objects.
type PdfOutlineTreeNode struct {
	_dcgc interface{}
	First *PdfOutlineTreeNode
	Last  *PdfOutlineTreeNode
}

func (_bedc *PdfAcroForm) fill(_feffa FieldValueProvider, _gadef FieldAppearanceGenerator) error {
	if _bedc == nil {
		return nil
	}
	_gbfag, _bfdcg := _feffa.FieldValues()
	if _bfdcg != nil {
		return _bfdcg
	}
	for _, _agfcf := range _bedc.AllFields() {
		_edac := _agfcf.PartialName()
		_beda, _fcbee := _gbfag[_edac]
		if !_fcbee {
			if _ebbb, _aeagf := _agfcf.FullName(); _aeagf == nil {
				_beda, _fcbee = _gbfag[_ebbb]
			}
		}
		if !_fcbee {
			_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020f\u006f\u0072\u006d \u0066\u0069\u0065l\u0064\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u0069n \u0074\u0068\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e", _edac)
			continue
		}
		if _cabbf := _bcfg(_agfcf, _beda); _cabbf != nil {
			return _cabbf
		}
		if _gadef == nil {
			continue
		}
		for _, _deegb := range _agfcf.Annotations {
			_gbbfd, _eagce := _gadef.GenerateAppearanceDict(_bedc, _agfcf, _deegb)
			if _eagce != nil {
				return _eagce
			}
			_deegb.AP = _gbbfd
			_deegb.ToPdfObject()
		}
	}
	return nil
}

// NewPdfColorPattern returns an empty color pattern.
func NewPdfColorPattern() *PdfColorPattern { _adde := &PdfColorPattern{}; return _adde }

// Encoder returns the font's text encoder.
func (_fabad *PdfFont) Encoder() _abg.TextEncoder {
	_aacgb := _fabad.actualFont()
	if _aacgb == nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0045n\u0063\u006f\u0064er\u0020\u006e\u006f\u0074\u0020\u0069m\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0066o\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003d%\u0023\u0054", _fabad._eaeg)
		return nil
	}
	return _aacgb.Encoder()
}

// Outline represents a PDF outline dictionary (Table 152 - p. 376).
// Currently, the Outline object can only be used to construct PDF outlines.
type Outline struct {
	Entries []*OutlineItem `json:"entries,omitempty"`
}

// Image interface is a basic representation of an image used in PDF.
// The colorspace is not specified, but must be known when handling the image.
type Image struct {
	Width            int64
	Height           int64
	BitsPerComponent int64
	ColorComponents  int
	Data             []byte
	_gebab           []byte
	_bebgb           []float64
}

// NewBorderStyle returns an initialized PdfBorderStyle.
func NewBorderStyle() *PdfBorderStyle { _dfg := &PdfBorderStyle{}; return _dfg }

// ToPdfObject sets the common field elements.
// Note: Call the more field context's ToPdfObject to set both the generic and
// non-generic information.
func (_efbf *PdfField) ToPdfObject() _df.PdfObject {
	_ggef := _efbf._cdbc
	_eaca := _ggef.PdfObject.(*_df.PdfObjectDictionary)
	_bfda := _df.MakeArray()
	for _, _ggcd := range _efbf.Kids {
		_bfda.Append(_ggcd.ToPdfObject())
	}
	for _, _abeca := range _efbf.Annotations {
		if _abeca._bfde != _efbf._cdbc {
			_bfda.Append(_abeca.GetContext().ToPdfObject())
		}
	}
	if _efbf.Parent != nil {
		_eaca.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _efbf.Parent.GetContainingPdfObject())
	}
	if _bfda.Len() > 0 {
		_eaca.Set("\u004b\u0069\u0064\u0073", _bfda)
	}
	_eaca.SetIfNotNil("\u0046\u0054", _efbf.FT)
	_eaca.SetIfNotNil("\u0054", _efbf.T)
	_eaca.SetIfNotNil("\u0054\u0055", _efbf.TU)
	_eaca.SetIfNotNil("\u0054\u004d", _efbf.TM)
	_eaca.SetIfNotNil("\u0046\u0066", _efbf.Ff)
	_eaca.SetIfNotNil("\u0056", _efbf.V)
	_eaca.SetIfNotNil("\u0044\u0056", _efbf.DV)
	_eaca.SetIfNotNil("\u0041\u0041", _efbf.AA)
	if _efbf.VariableText != nil {
		_eaca.SetIfNotNil("\u0044\u0041", _efbf.VariableText.DA)
		_eaca.SetIfNotNil("\u0051", _efbf.VariableText.Q)
		_eaca.SetIfNotNil("\u0044\u0053", _efbf.VariableText.DS)
		_eaca.SetIfNotNil("\u0052\u0056", _efbf.VariableText.RV)
	}
	return _ggef
}

var _ pdfFont = (*pdfCIDFontType2)(nil)

// ToPdfObject returns the PDF representation of the function.
func (_gdbcc *PdfFunctionType4) ToPdfObject() _df.PdfObject {
	_geaefc := _gdbcc._ebea
	if _geaefc == nil {
		_gdbcc._ebea = &_df.PdfObjectStream{}
		_geaefc = _gdbcc._ebea
	}
	_cafff := _df.MakeDict()
	_cafff.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _df.MakeInteger(4))
	_fedfd := &_df.PdfObjectArray{}
	for _, _cfccc := range _gdbcc.Domain {
		_fedfd.Append(_df.MakeFloat(_cfccc))
	}
	_cafff.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _fedfd)
	_ggedb := &_df.PdfObjectArray{}
	for _, _eagfe := range _gdbcc.Range {
		_ggedb.Append(_df.MakeFloat(_eagfe))
	}
	_cafff.Set("\u0052\u0061\u006eg\u0065", _ggedb)
	if _gdbcc._acbe == nil && _gdbcc.Program != nil {
		_gdbcc._acbe = []byte(_gdbcc.Program.String())
	}
	_cafff.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _df.MakeInteger(int64(len(_gdbcc._acbe))))
	_geaefc.Stream = _gdbcc._acbe
	_geaefc.PdfObjectDictionary = _cafff
	return _geaefc
}

// NewPdfFieldSignature returns an initialized signature field.
func NewPdfFieldSignature(signature *PdfSignature) *PdfFieldSignature {
	_cgcac := &PdfFieldSignature{}
	_cgcac.PdfField = NewPdfField()
	_cgcac.PdfField.SetContext(_cgcac)
	_cgcac.PdfAnnotationWidget = NewPdfAnnotationWidget()
	_cgcac.PdfAnnotationWidget.SetContext(_cgcac)
	_cgcac.PdfAnnotationWidget._bfde = _cgcac.PdfField._cdbc
	_cgcac.T = _df.MakeString("")
	_cgcac.F = _df.MakeInteger(132)
	_cgcac.V = signature
	return _cgcac
}

// ToPdfObject converts the structure tree root to a PDF object.
func (_dbebb *StructTreeRoot) ToPdfObject() _df.PdfObject {
	_fbgce := _dbebb._cgea
	if _fbgce == nil {
		_fbgce = &_df.PdfIndirectObject{}
		_fbgce.PdfObject = _df.MakeDict()
	}
	_cccdc := _fbgce.PdfObject.(*_df.PdfObjectDictionary)
	var _geddc _df.PdfObject
	if len(_dbebb.K) == 1 {
		_geddc = _df.MakeIndirectObject(_dbebb.K[0].ToPdfObject())
	} else {
		_baefbf := _df.MakeArray()
		for _, K := range _dbebb.K {
			_baefbf.Append(_df.MakeIndirectObject(K.ToPdfObject()))
		}
		_geddc = _baefbf
	}
	var (
		_fbfcd  = []_df.PdfObject{}
		_cddgge = map[_df.PdfObject][]_df.PdfObject{}
		_bcgae  = map[string]_df.PdfObject{}
	)
	_adab(_geddc, _fbgce, _cddgge, _bcgae, &_fbfcd)
	_cccdc.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065e\u0052\u006f\u006f\u0074"))
	_cccdc.Set("\u004b", _geddc)
	if _dbebb.IDTree != nil {
		_cccdc.Set("\u0049\u0044\u0054\u0072\u0065\u0065", _df.MakeIndirectObject(_dbebb.IDTree.ToPdfObject()))
	} else if len(_bcgae) > 0 {
		_gfgab := _df.MakeArray()
		_ecfab := make([]string, 0, len(_bcgae))
		for _dgggf := range _bcgae {
			_ecfab = append(_ecfab, _dgggf)
		}
		_f.Strings(_ecfab)
		for _, _fbaedf := range _ecfab {
			_gfgab.Append(_df.MakeString(_fbaedf))
			_gfgab.Append(_bcgae[_fbaedf])
		}
		_dbebb.IDTree = &IDTree{Names: _gfgab, Limits: _df.MakeArray(_df.MakeString(_ecfab[0]), _df.MakeString(_ecfab[len(_ecfab)-1]))}
		_cccdc.Set("\u0049\u0044\u0054\u0072\u0065\u0065", _df.MakeIndirectObject(_dbebb.IDTree.ToPdfObject()))
	}
	if _dbebb.ParentTree != nil {
		_cccdc.Set("\u0050\u0061\u0072\u0065\u006e\u0074\u0054\u0072\u0065\u0065", _df.MakeIndirectObject(_dbebb.ParentTree))
	} else if len(_cddgge) > 0 || len(_fbfcd) > 0 {
		_cffbf := _df.MakeArray()
		_geffa := 0
		for _cgfeb, _fcfa := range _cddgge {
			_gcaf := _df.MakeArray()
			for _, _bbdfd := range _fcfa {
				_gcaf.Append(_bbdfd)
			}
			_daddgc := _df.MakeInteger(int64(_geffa))
			_cffbf.Append(_daddgc)
			_cffbf.Append(_df.MakeIndirectObject(_gcaf))
			if _aefff, _afcge := _df.GetIndirect(_cgfeb); _afcge {
				if _ggcegd, _cgaa := _df.GetDict(_aefff.PdfObject); _cgaa {
					_bcbgcb := _ggcegd.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073")
					if _bcbgcb != nil {
						if _fedgb, _fdac := _df.GetIntVal(_bcbgcb); _fdac {
							if _geffa < _fedgb {
								_ggcegd.Set("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _daddgc)
							}
						}
					} else {
						_ggcegd.Set("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _daddgc)
					}
				}
			}
			_geffa++
		}
		_ffeda := func(_cdbf _df.PdfObject, _dagdc *_df.PdfObjectDictionary) bool {
			if _fbagf := _dagdc.Get("\u004f\u0062\u006a"); _fbagf != nil {
				if _gdcdg, _dafdbe := _df.GetDict(_fbagf); _dafdbe {
					_acaba := _gdcdg.Get("\u0054\u0079\u0070\u0065")
					_faabc := _gdcdg.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")
					if _acaba != nil && _acaba.String() == "\u0041\u006e\u006eo\u0074" && _faabc != nil && _faabc.String() == "\u004c\u0069\u006e\u006b" {
						_dacda := _df.MakeInteger(int64(_geffa))
						_gdcdg.Set("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _dacda)
						_cffbf.Append(_dacda)
						_cffbf.Append(_cdbf)
						_geffa++
						return true
					}
				}
			}
			return false
		}
		for _, _baeeef := range _fbfcd {
			if _fcgcde, _accca := _df.GetDict(_baeeef); _accca {
				if _gdgbc := _fcgcde.Get("\u0053"); _gdgbc != nil {
					if _aecf, _ebdbcf := _df.GetNameVal(_gdgbc); _ebdbcf && _aecf == StructureTypeLink {
						if _feggb := _fcgcde.Get("\u004b"); _feggb != nil {
							if _eggfc, _bgbgd := _df.GetArray(_feggb); _bgbgd {
								for _, _cgdb := range _eggfc.Elements() {
									if _gdfgd, _eadge := _df.GetDict(_cgdb); _eadge {
										_ffeda(_baeeef, _gdfgd)
									}
								}
							} else if _dgfeab, _cfdde := _df.GetDict(_feggb); _cfdde {
								_ffeda(_baeeef, _dgfeab)
							}
						}
					}
				}
			}
		}
		_dbebb.ParentTree = _df.MakeDict()
		_dbebb.ParentTree.Set("\u004e\u0075\u006d\u0073", _cffbf)
		_dbebb.ParentTreeNextKey = int64(_geffa)
		_cccdc.Set("\u0050\u0061\u0072\u0065\u006e\u0074\u0054\u0072\u0065\u0065", _df.MakeIndirectObject(_dbebb.ParentTree))
	}
	_cccdc.Set("\u0050\u0061\u0072\u0065\u006e\u0074\u0054\u0072\u0065\u0065\u004e\u0065x\u0074\u004b\u0065\u0079", _df.MakeInteger(_dbebb.ParentTreeNextKey))
	if _dbebb.RoleMap != nil {
		_cccdc.Set("\u0052o\u006c\u0065\u004d\u0061\u0070", _dbebb.RoleMap)
	}
	if _dbebb.ClassMap != nil {
		_cccdc.Set("\u0043\u006c\u0061\u0073\u0073\u004d\u0061\u0070", _dbebb.ClassMap)
	}
	return _fbgce
}

// SetContentStreams sets the content streams based on a string array. Will make
// 1 object stream for each string and reference from the page Contents.
// Each stream will be encoded using the encoding specified by the StreamEncoder,
// if empty, will use identity encoding (raw data).
func (_fgafb *PdfPage) SetContentStreams(cStreams []string, encoder _df.StreamEncoder) error {
	if len(cStreams) == 0 {
		_fgafb.Contents = nil
		return nil
	}
	if encoder == nil {
		encoder = _df.NewRawEncoder()
	}
	var _dgcd []*_df.PdfObjectStream
	for _, _badeb := range cStreams {
		_gcgdb := &_df.PdfObjectStream{}
		_ddcegd := encoder.MakeStreamDict()
		_dgega, _feddc := encoder.EncodeBytes([]byte(_badeb))
		if _feddc != nil {
			return _feddc
		}
		_ddcegd.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _df.MakeInteger(int64(len(_dgega))))
		_gcgdb.PdfObjectDictionary = _ddcegd
		_gcgdb.Stream = _dgega
		_dgcd = append(_dgcd, _gcgdb)
	}
	if len(_dgcd) == 1 {
		_fgafb.Contents = _dgcd[0]
	} else {
		_bagecg := _df.MakeArray()
		for _, _befgd := range _dgcd {
			_bagecg.Append(_befgd)
		}
		_fgafb.Contents = _bagecg
	}
	return nil
}

// SetHideToolbar sets the value of the hideToolbar flag.
func (_gdcf *ViewerPreferences) SetHideToolbar(hideToolbar bool) { _gdcf._bbfdd = &hideToolbar }

// NewPdfAnnotationStrikeOut returns a new text strikeout annotation.
func NewPdfAnnotationStrikeOut() *PdfAnnotationStrikeOut {
	_dgg := NewPdfAnnotation()
	_ceag := &PdfAnnotationStrikeOut{}
	_ceag.PdfAnnotation = _dgg
	_ceag.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_dgg.SetContext(_ceag)
	return _ceag
}

const (
	TrappedUnknown PdfInfoTrapped = "\u0055n\u006b\u006e\u006f\u0077\u006e"
	TrappedTrue    PdfInfoTrapped = "\u0054\u0072\u0075\u0065"
	TrappedFalse   PdfInfoTrapped = "\u0046\u0061\u006cs\u0065"
)

// NonFullScreenPageMode represents the document’s page mode when exiting
// full-screen mode.
type NonFullScreenPageMode string

// FullName returns the full name of the field as in rootname.parentname.partialname.
func (_fada *PdfField) FullName() (string, error) {
	var _ddfc _ef.Buffer
	_daede := []string{}
	if _fada.T != nil {
		_daede = append(_daede, _fada.T.Decoded())
	}
	_egcca := map[*PdfField]bool{}
	_egcca[_fada] = true
	_gbcf := _fada.Parent
	for _gbcf != nil {
		if _, _egfff := _egcca[_gbcf]; _egfff {
			return _ddfc.String(), _deb.New("\u0072\u0065\u0063\u0075rs\u0069\u0076\u0065\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c")
		}
		if _gbcf.T == nil {
			return _ddfc.String(), _deb.New("\u0066\u0069el\u0064\u0020\u0070a\u0072\u0074\u0069\u0061l n\u0061me\u0020\u0028\u0054\u0029\u0020\u006e\u006ft \u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064")
		}
		_daede = append(_daede, _gbcf.T.Decoded())
		_egcca[_gbcf] = true
		_gbcf = _gbcf.Parent
	}
	for _bbcbb := len(_daede) - 1; _bbcbb >= 0; _bbcbb-- {
		_ddfc.WriteString(_daede[_bbcbb])
		if _bbcbb > 0 {
			_ddfc.WriteString("\u002e")
		}
	}
	return _ddfc.String(), nil
}

func _acfc(_edbca _da.StdFont) pdfFontSimple {
	_dffba := _edbca.Descriptor()
	return pdfFontSimple{fontCommon: fontCommon{_fgfae: "\u0054\u0079\u0070e\u0031", _gddcf: _edbca.Name()}, _aeeed: _edbca.GetMetricsTable(), _abegg: &PdfFontDescriptor{FontName: _df.MakeName(string(_dffba.Name)), FontFamily: _df.MakeName(_dffba.Family), FontWeight: _df.MakeFloat(float64(_dffba.Weight)), Flags: _df.MakeInteger(int64(_dffba.Flags)), FontBBox: _df.MakeArrayFromFloats(_dffba.BBox[:]), ItalicAngle: _df.MakeFloat(_dffba.ItalicAngle), Ascent: _df.MakeFloat(_dffba.Ascent), Descent: _df.MakeFloat(_dffba.Descent), CapHeight: _df.MakeFloat(_dffba.CapHeight), XHeight: _df.MakeFloat(_dffba.XHeight), StemV: _df.MakeFloat(_dffba.StemV), StemH: _df.MakeFloat(_dffba.StemH)}, _geecc: _edbca.Encoder()}
}

func (_babc *PdfWriter) setDocumentIDs(_bddce, _efade string) {
	_babc._fgdf = _df.MakeArray(_df.MakeHexString(_bddce), _df.MakeHexString(_efade))
}

func _ccff(_bfdf *_df.PdfObjectDictionary) *VRI {
	_becdb, _ := _df.GetString(_bfdf.Get("\u0054\u0055"))
	_befc, _ := _df.GetString(_bfdf.Get("\u0054\u0053"))
	return &VRI{Cert: _ddega(_bfdf.Get("\u0043\u0065\u0072\u0074")), OCSP: _ddega(_bfdf.Get("\u004f\u0043\u0053\u0050")), CRL: _ddega(_bfdf.Get("\u0043\u0052\u004c")), TU: _becdb, TS: _befc}
}

// OutlineDest represents the destination of an outline item.
// It holds the page and the position on the page an outline item points to.
type OutlineDest struct {
	PageObj *_df.PdfIndirectObject `json:"-"`
	Page    int64                  `json:"page"`
	Mode    string                 `json:"mode"`
	X       float64                `json:"x"`
	Y       float64                `json:"y"`
	Zoom    float64                `json:"zoom"`
}

// B returns the value of the blue component of the color.
func (_dedaf *PdfColorDeviceRGB) B() float64 { return _dedaf[2] }

// SetContext sets the sub pattern (context).  Either PdfTilingPattern or PdfShadingPattern.
func (_baface *PdfPattern) SetContext(ctx PdfModel) { _baface._ecfde = ctx }

// ImageHandler interface implements common image loading and processing tasks.
// Implementing as an interface allows for the possibility to use non-standard libraries for faster
// loading and processing of images.
type ImageHandler interface {

	// Read any image type and load into a new Image object.
	Read(_cecca _bdd.Reader) (*Image, error)

	// NewImageFromGoImage loads a NRGBA32 unidoc Image from a standard Go image structure.
	NewImageFromGoImage(_eggda _cg.Image) (*Image, error)

	// NewGrayImageFromGoImage loads a grayscale unidoc Image from a standard Go image structure.
	NewGrayImageFromGoImage(_dafdbb _cg.Image) (*Image, error)

	// Compress an image.
	Compress(_aabgg *Image, _gdadf int64) (*Image, error)
}

// GetContentStreamObjs returns a slice of PDF objects containing the content
// streams of the page.
func (_eedac *PdfPage) GetContentStreamObjs() []_df.PdfObject {
	if _eedac.Contents == nil {
		return nil
	}
	_gfddc := _df.TraceToDirectObject(_eedac.Contents)
	if _afbfb, _bfacb := _gfddc.(*_df.PdfObjectArray); _bfacb {
		return _afbfb.Elements()
	}
	return []_df.PdfObject{_gfddc}
}

// NewPdfField returns an initialized PdfField.
func NewPdfField() *PdfField { return &PdfField{_cdbc: _df.MakeIndirectObject(_df.MakeDict())} }

// PdfAppender appends new PDF content to an existing PDF document via incremental updates.
type PdfAppender struct {
	_fggb   _bdd.ReadSeeker
	_gecd   *_df.PdfParser
	_abf    *PdfReader
	Reader  *PdfReader
	_dgac   []*PdfPage
	_ffe    *PdfAcroForm
	_cgebag *DSS
	_gfedf  *Permissions
	_bagc   _df.XrefTable
	_cfeb   int64
	_eadb   int
	_eaad   []_df.PdfObject
	_gceg   map[_df.PdfObject]struct{}
	_aggf   map[_df.PdfObject]int64
	_bbba   map[_df.PdfObject]struct{}
	_abba   map[_df.PdfObject]struct{}
	_bfgee  int64
	_gafb   bool
	_aadbf  string
	_aeg    *EncryptOptions
	_fbdb   *PdfInfo
}

// NewPdfActionRendition returns a new "rendition" action.
func NewPdfActionRendition() *PdfActionRendition {
	_gcc := NewPdfAction()
	_bag := &PdfActionRendition{}
	_bag.PdfAction = _gcc
	_gcc.SetContext(_bag)
	return _bag
}

func (_gaga PdfFont) actualFont() pdfFont {
	if _gaga._eaeg == nil {
		_bcd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0061\u0063\u0074\u0075\u0061\u006c\u0046\u006f\u006e\u0074\u002e\u0020\u0063\u006f\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c.\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _gaga)
	}
	return _gaga._eaeg
}

// ToPdfObject implements interface PdfModel.
func (_dgbe *PdfAnnotationRichMedia) ToPdfObject() _df.PdfObject {
	_dgbe.PdfAnnotation.ToPdfObject()
	_cab := _dgbe._bfde
	_aed := _cab.PdfObject.(*_df.PdfObjectDictionary)
	_aed.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0052i\u0063\u0068\u004d\u0065\u0064\u0069a"))
	_aed.SetIfNotNil("\u0052\u0069\u0063\u0068\u004d\u0065\u0064\u0069\u0061\u0053\u0065\u0074t\u0069\u006e\u0067\u0073", _dgbe.RichMediaSettings)
	_aed.SetIfNotNil("\u0052\u0069c\u0068\u004d\u0065d\u0069\u0061\u0043\u006f\u006e\u0074\u0065\u006e\u0074", _dgbe.RichMediaContent)
	return _cab
}

// Duplex represents the paper handling option that shall be used when printing
// the file from the print dialog.
type Duplex string

func _aaee(_eaac *_df.PdfIndirectObject, _cbag *_df.PdfObjectDictionary) (*DSS, error) {
	if _eaac == nil {
		_eaac = _df.MakeIndirectObject(nil)
	}
	_eaac.PdfObject = _df.MakeDict()
	_gcgaa := map[string]*VRI{}
	if _bbabe, _ccaa := _df.GetDict(_cbag.Get("\u0056\u0052\u0049")); _ccaa {
		for _, _accgb := range _bbabe.Keys() {
			if _dfaa, _bgbg := _df.GetDict(_bbabe.Get(_accgb)); _bgbg {
				_gcgaa[_gc.ToUpper(_accgb.String())] = _ccff(_dfaa)
			}
		}
	}
	return &DSS{Certs: _ddega(_cbag.Get("\u0043\u0065\u0072t\u0073")), OCSPs: _ddega(_cbag.Get("\u004f\u0043\u0053P\u0073")), CRLs: _ddega(_cbag.Get("\u0043\u0052\u004c\u0073")), VRI: _gcgaa, _dbdf: _eaac}, nil
}

// PdfAnnotationLine represents Line annotations.
// (Section 12.5.6.7).
type PdfAnnotationLine struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	L       _df.PdfObject
	BS      _df.PdfObject
	LE      _df.PdfObject
	IC      _df.PdfObject
	LL      _df.PdfObject
	LLE     _df.PdfObject
	Cap     _df.PdfObject
	IT      _df.PdfObject
	LLO     _df.PdfObject
	CP      _df.PdfObject
	Measure _df.PdfObject
	CO      _df.PdfObject
}

// Add appends an outline item as a child of the current outline item.
func (_ceebb *OutlineItem) Add(item *OutlineItem) { _ceebb.Entries = append(_ceebb.Entries, item) }

// ToPdfObject implements interface PdfModel.
func (_daa *PdfActionSubmitForm) ToPdfObject() _df.PdfObject {
	_daa.PdfAction.ToPdfObject()
	_gfg := _daa._gcf
	_eef := _gfg.PdfObject.(*_df.PdfObjectDictionary)
	_eef.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeSubmitForm)))
	if _daa.F != nil {
		_eef.Set("\u0046", _daa.F.ToPdfObject())
	}
	_eef.SetIfNotNil("\u0046\u0069\u0065\u006c\u0064\u0073", _daa.Fields)
	_eef.SetIfNotNil("\u0046\u006c\u0061g\u0073", _daa.Flags)
	return _gfg
}

// NewPdfFontFromTTFFile loads a TTF font file and returns a PdfFont type
// that can be used in text styling functions.
// Uses a WinAnsiTextEncoder and loads only character codes 32-255.
// NOTE: For composite fonts such as used in symbolic languages, use NewCompositePdfFontFromTTFFile.
func NewPdfFontFromTTFFile(filePath string) (*PdfFont, error) {
	_gfgaa, _bege := _bf.Open(filePath)
	if _bege != nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020T\u0054F\u0020\u0066\u006f\u006e\u0074\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0076", _bege)
		return nil, _bege
	}
	defer _gfgaa.Close()
	return NewPdfFontFromTTF(_gfgaa)
}

// ToPdfOutline returns a low level PdfOutline object, based on the current
// instance.
func (_fbaa *Outline) ToPdfOutline() *PdfOutline {
	_gedcf := NewPdfOutline()
	var _fgdb []*PdfOutlineItem
	var _daccgf int64
	var _aaeeg *PdfOutlineItem
	for _, _agebb := range _fbaa.Entries {
		_afbee, _acfaa := _agebb.ToPdfOutlineItem()
		_afbee.Parent = &_gedcf.PdfOutlineTreeNode
		if _aaeeg != nil {
			_aaeeg.Next = &_afbee.PdfOutlineTreeNode
			_afbee.Prev = &_aaeeg.PdfOutlineTreeNode
		}
		_fgdb = append(_fgdb, _afbee)
		_daccgf += _acfaa
		_aaeeg = _afbee
	}
	_gcab := int64(len(_fgdb))
	_daccgf += _gcab
	if _gcab > 0 {
		_gedcf.First = &_fgdb[0].PdfOutlineTreeNode
		_gedcf.Last = &_fgdb[_gcab-1].PdfOutlineTreeNode
		_gedcf.Count = &_daccgf
	}
	return _gedcf
}

func _cbcce(_gbbc *_df.PdfObjectDictionary, _gdfcc *fontCommon) (*pdfFontType0, error) {
	_dgbbc, _dgda := _df.GetArray(_gbbc.Get("\u0044e\u0073c\u0065\u006e\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073"))
	if !_dgda {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049n\u0076\u0061\u006cid\u0020\u0044\u0065\u0073\u0063\u0065n\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073\u0020\u002d\u0020\u006e\u006f\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079 \u0025\u0073", _gdfcc)
		return nil, _df.ErrRangeError
	}
	if _dgbbc.Len() != 1 {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0041\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020(%\u0064\u0029", _dgbbc.Len())
		return nil, _df.ErrRangeError
	}
	_ddeb, _ggadcc := _fafcf(_dgbbc.Get(0), false)
	if _ggadcc != nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046a\u0069\u006c\u0065d \u006c\u006f\u0061\u0064\u0069\u006eg\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u0020\u0066\u006f\u006et\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076 \u0025\u0073", _ggadcc, _gdfcc)
		return nil, _ggadcc
	}
	_dedfe := _gbbc.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067")
	_fcbde := ""
	_ffgbc := _egbe(_gdfcc)
	_ffgbc.DescendantFont = _ddeb
	switch _deeaa := _dedfe.(type) {
	case *_df.PdfObjectName:
		_fcbde, _dgda = _df.GetNameVal(_dedfe)
		if _dgda {
			if _fcbde == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0048" || _fcbde == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0056" {
				_ffgbc._gdbg = _abg.NewIdentityTextEncoder(_fcbde)
			} else if _dgf.IsPredefinedCMap(_fcbde) {
				_ffgbc._eabf, _ggadcc = _dgf.LoadPredefinedCMap(_fcbde)
				if _ggadcc != nil {
					_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0070\u0072\u0065\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0043\u004d\u0061\u0070\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _fcbde, _ggadcc)
				}
			} else {
				_bcd.Log.Debug("\u0055\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u0063\u006da\u0070\u0020\u0025\u0071", _fcbde)
			}
		}
	case *_df.PdfObjectStream:
		if _ffgbc._cdbgag == nil {
			_agdbb, _acae := _dgf.NewCIDSystemInfo(_deeaa.PdfObjectDictionary.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
			if _acae != nil {
				_bcd.Log.Debug("\u0055\u006e\u0061b\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0043\u0049D\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f\u003a\u0020\u0025\u0076", _acae)
			}
			_ebgc := _c.Sprintf("\u0025\u0073\u002d\u0025\u0073\u002d\u0055\u0043\u0053\u0032", _agdbb.Registry, _agdbb.Ordering)
			if _dgf.IsPredefinedCMap(_ebgc) {
				_ffgbc._eabf, _acae = _dgf.LoadPredefinedCMap(_ebgc)
				if _acae != nil {
					_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0070\u0072\u0065\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0043\u004d\u0061\u0070\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _ebgc, _acae)
				}
			} else {
				_ebgc = _deeaa.PdfObjectDictionary.Get("\u0043\u004d\u0061\u0070\u004e\u0061\u006d\u0065").String()
				_egbb, _ddeda := _df.DecodeStream(_deeaa)
				if _ddeda != nil {
					_bcd.Log.Debug("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0064\u0065\u0063\u006f\u0064\u0065\u0020s\u0074\u0072\u0065a\u006d:\u0020\u0025\u0076", _ddeda)
					return _ffgbc, _ddeda
				}
				if _ecbf := _ebgc == "\u004f\u006ee\u0042\u0079\u0074e\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u0048" || _ebgc == "\u004f\u006ee\u0042\u0079\u0074e\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u0056"; _ecbf {
					_ffgbc._eabf, _ddeda = _dgf.LoadCmapFromData(_egbb, _ecbf)
					if _ddeda != nil {
						_bcd.Log.Debug("\u0055\u006e\u0061\u0062\u006ce\u0020\u0074\u006f\u0020\u006c\u006f\u0061\u0064\u0020\u0043\u004d\u0061\u0070 \u0066\u0072\u006f\u006d\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076\u0020\u002d\u002d\u0020\u0025\u0076", _ddeda, string(_egbb))
						return _ffgbc, _ddeda
					}
					_fedccc := make(map[_dgf.CharCode]rune, 256)
					for _aageg := 0x00; _aageg <= 0xFF; _aageg++ {
						_fedccc[_dgf.CharCode(_aageg)] = rune(_aageg)
					}
					_ffgbc._afcbd = _dgf.NewToUnicodeCMap(_fedccc)
				}
			}
		}
	}
	if _gegc := _ddeb.baseFields()._afcbd; _gegc != nil {
		if _fdgg := _gegc.Name(); _fdgg == "\u0041d\u006fb\u0065\u002d\u0043\u004e\u0053\u0031\u002d\u0055\u0043\u0053\u0032" || _fdgg == "\u0041\u0064\u006f\u0062\u0065\u002d\u0047\u0042\u0031-\u0055\u0043\u0053\u0032" || _fdgg == "\u0041\u0064\u006f\u0062\u0065\u002d\u004a\u0061\u0070\u0061\u006e\u0031-\u0055\u0043\u0053\u0032" || _fdgg == "\u0041\u0064\u006f\u0062\u0065\u002d\u004b\u006f\u0072\u0065\u0061\u0031-\u0055\u0043\u0053\u0032" {
			_ffgbc._gdbg = _abg.NewCMapEncoder(_fcbde, _ffgbc._eabf, _gegc)
		}
	}
	return _ffgbc, nil
}

// PdfColorLab represents a color in the L*, a*, b* 3 component colorspace.
// Each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorLab [3]float64

func _abfge(_ecff *PdfField, _fcgb _df.PdfObject) {
	for _, _faffe := range _ecff.Annotations {
		_faffe.AS = _fcgb
		_faffe.ToPdfObject()
	}
}

// SetShadingByName sets a shading resource specified by keyName.
func (_abede *PdfPageResources) SetShadingByName(keyName _df.PdfObjectName, shadingObj _df.PdfObject) error {
	if _abede.Shading == nil {
		_abede.Shading = _df.MakeDict()
	}
	_bebea, _cdbbg := _df.GetDict(_abede.Shading)
	if !_cdbbg {
		return _df.ErrTypeError
	}
	_bebea.Set(keyName, shadingObj)
	return nil
}

// multiFontEncoder implements a an Encoder that holds a list of fonts provided.
type MultipleFontEncoder struct {
	_fbeed      []*PdfFont
	CurrentFont *PdfFont
}

// Enable LTV enables the specified signature. The signing certificate
// chain is extracted from the signature dictionary. Optionally, additional
// certificates can be specified through the `extraCerts` parameter.
// The LTV client attempts to build the certificate chain up to a trusted root
// by downloading any missing certificates.
func (_geecb *LTV) Enable(sig *PdfSignature, extraCerts []*_ed.Certificate) error {
	if _ecafd := _geecb.validateSig(sig); _ecafd != nil {
		return _ecafd
	}
	_dacfb, _fcefe := _geecb.generateVRIKey(sig)
	if _fcefe != nil {
		return _fcefe
	}
	if _, _bdfff := _geecb._dfcg.VRI[_dacfb]; _bdfff && _geecb.SkipExisting {
		return nil
	}
	_ggbgd, _fcefe := sig.GetCerts()
	if _fcefe != nil {
		return _fcefe
	}
	return _geecb.enable(_ggbgd, extraCerts, _dacfb)
}

// CheckAccessRights checks access rights and permissions for a specified password.  If either user/owner
// password is specified,  full rights are granted, otherwise the access rights are specified by the
// Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_abca *PdfReader) CheckAccessRights(password []byte) (bool, _afc.Permissions, error) {
	return _abca._gfdaag.CheckAccessRights(password)
}

// PdfActionType represents an action type in PDF (section 12.6.4 p. 417).
type PdfActionType string

// SetContentStream sets the pattern cell's content stream.
func (_facca *PdfTilingPattern) SetContentStream(content []byte, encoder _df.StreamEncoder) error {
	_dabdbe, _fgfcf := _facca._cbce.(*_df.PdfObjectStream)
	if !_fgfcf {
		_bcd.Log.Debug("\u0054\u0069l\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _facca._cbce)
		return _df.ErrTypeError
	}
	if encoder == nil {
		encoder = _df.NewRawEncoder()
	}
	_fbegc := _dabdbe.PdfObjectDictionary
	_gaabb := encoder.MakeStreamDict()
	_fbegc.Merge(_gaabb)
	_ecgcg, _ffedc := encoder.EncodeBytes(content)
	if _ffedc != nil {
		return _ffedc
	}
	_fbegc.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _df.MakeInteger(int64(len(_ecgcg))))
	_dabdbe.Stream = _ecgcg
	return nil
}

// GetRuneMetrics returns the character metrics for the rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_eeeag pdfFontSimple) GetRuneMetrics(r rune) (_da.CharMetrics, bool) {
	if _eeeag._aeeed != nil {
		_gcfb, _ddab := _eeeag._aeeed.Read(r)
		if _ddab {
			return _gcfb, true
		}
	}
	_cbed := _eeeag.Encoder()
	if _cbed == nil {
		_bcd.Log.Debug("\u004e\u006f\u0020en\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0073\u003d\u0025\u0073", _eeeag)
		return _da.CharMetrics{}, false
	}
	_fgfbd, _ggfca := _cbed.RuneToCharcode(r)
	if !_ggfca {
		if r != ' ' {
			_bcd.Log.Trace("\u004e\u006f\u0020c\u0068\u0061\u0072\u0063o\u0064\u0065\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u003d\u0025\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", r, _eeeag)
		}
		return _da.CharMetrics{}, false
	}
	_fbecg, _deca := _eeeag.GetCharMetrics(_fgfbd)
	return _fbecg, _deca
}

// Y returns the value of the yellow component of the color.
func (_gcga *PdfColorDeviceCMYK) Y() float64 { return _gcga[2] }

// SetMCID sets the MCID for the KValue.
func (_ceeff *KValue) SetMCID(mcid int) { _ceeff.Clear(); _ceeff._dfca = &mcid }

// ToPdfObject implements interface PdfModel.
func (_aef *PdfActionTrans) ToPdfObject() _df.PdfObject {
	_aef.PdfAction.ToPdfObject()
	_bgc := _aef._gcf
	_dabc := _bgc.PdfObject.(*_df.PdfObjectDictionary)
	_dabc.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeTrans)))
	_dabc.SetIfNotNil("\u0054\u0072\u0061n\u0073", _aef.Trans)
	return _bgc
}

func _bcfg(_eegdc *PdfField, _edaf _df.PdfObject) error {
	switch _eegdc.GetContext().(type) {
	case *PdfFieldText:
		switch _bced := _edaf.(type) {
		case *_df.PdfObjectName:
			_bfca := _bced
			_bcd.Log.Debug("\u0055\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u003a\u0020\u0047\u006f\u0074 \u0056\u0020\u0061\u0073\u0020\u006e\u0061\u006d\u0065\u0020\u002d\u003e\u0020c\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0074\u006f s\u0074\u0072\u0069\u006e\u0067\u0020\u0027\u0025\u0073\u0027", _bfca.String())
			_eegdc.V = _df.MakeEncodedString(_bced.String(), true)
		case *_df.PdfObjectString:
			_eegdc.V = _df.MakeEncodedString(_bced.String(), true)
		default:
			_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0056\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u0028\u0025\u0023\u0076\u0029", _bced, _bced)
		}
	case *PdfFieldButton:
		switch _edaf.(type) {
		case *_df.PdfObjectName:
			if len(_edaf.String()) > 0 {
				_eegdc.V = _edaf
				_abfge(_eegdc, _edaf)
			}
		case *_df.PdfObjectString:
			if len(_edaf.String()) > 0 {
				_eegdc.V = _df.MakeName(_edaf.String())
				_abfge(_eegdc, _eegdc.V)
			}
		default:
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u004e\u0045\u0058P\u0045\u0043\u0054\u0045\u0044\u0020\u0025\u0073\u0020\u002d>\u0020\u0025\u0076", _eegdc.PartialName(), _edaf)
			_eegdc.V = _edaf
		}
	case *PdfFieldChoice:
		switch _edaf.(type) {
		case *_df.PdfObjectName:
			if len(_edaf.String()) > 0 {
				_eegdc.V = _df.MakeString(_edaf.String())
				_abfge(_eegdc, _edaf)
			}
		case *_df.PdfObjectString:
			if len(_edaf.String()) > 0 {
				_eegdc.V = _edaf
				_abfge(_eegdc, _df.MakeName(_edaf.String()))
			}
		default:
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u004e\u0045\u0058P\u0045\u0043\u0054\u0045\u0044\u0020\u0025\u0073\u0020\u002d>\u0020\u0025\u0076", _eegdc.PartialName(), _edaf)
			_eegdc.V = _edaf
		}
	case *PdfFieldSignature:
		_bcd.Log.Debug("\u0054\u004f\u0044\u004f\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0061\u0070\u0070e\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0079\u0065\u0074\u003a\u0020\u0025\u0073\u002f\u0025v", _eegdc.PartialName(), _edaf)
	}
	return nil
}

// ImageToRGB convert an indexed image to RGB.
func (_ddagf *PdfColorspaceSpecialIndexed) ImageToRGB(img Image) (Image, error) {
	N := _ddagf.Base.GetNumComponents()
	if N < 1 {
		return Image{}, _c.Errorf("\u0062\u0061d \u0062\u0061\u0073e\u0020\u0063\u006f\u006cors\u0070ac\u0065\u0020\u004e\u0075\u006d\u0043\u006fmp\u006f\u006e\u0065\u006e\u0074\u0073\u003d%\u0064", N)
	}
	_baab := _bge.NewImageBase(int(img.Width), int(img.Height), 8, N, nil, img._gebab, img._bebgb)
	_agdb := _aff.NewReader(img.getBase())
	_bbdec := _aff.NewWriter(_baab)
	var (
		_aadbef uint32
		_cffb   int
		_edagc  error
	)
	for {
		_aadbef, _edagc = _agdb.ReadSample()
		if _edagc == _bdd.EOF {
			break
		} else if _edagc != nil {
			return img, _edagc
		}
		_cffb = int(_aadbef)
		_bcd.Log.Trace("\u0049\u006ed\u0065\u0078\u0065\u0064\u003a\u0020\u0069\u006e\u0064\u0065\u0078\u003d\u0025\u0064\u0020\u004e\u003d\u0025\u0064\u0020\u006c\u0075t=\u0025\u0064", _cffb, N, len(_ddagf._befa))
		if (_cffb+1)*N > len(_ddagf._befa) {
			_cffb = len(_ddagf._befa)/N - 1
			_bcd.Log.Trace("C\u006c\u0069\u0070\u0070in\u0067 \u0074\u006f\u0020\u0069\u006ed\u0065\u0078\u003a\u0020\u0025\u0064", _cffb)
			if _cffb < 0 {
				_bcd.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0043a\u006e\u0027\u0074\u0020\u0063\u006c\u0069p\u0020\u0069\u006e\u0064\u0065\u0078.\u0020\u0049\u0073\u0020\u0050\u0044\u0046\u0020\u0066\u0069\u006ce\u0020\u0064\u0061\u006d\u0061\u0067\u0065\u0064\u003f")
				break
			}
		}
		for _cefc := _cffb * N; _cefc < (_cffb+1)*N; _cefc++ {
			if _edagc = _bbdec.WriteSample(uint32(_ddagf._befa[_cefc])); _edagc != nil {
				return img, _edagc
			}
		}
	}
	return _ddagf.Base.ImageToRGB(_agbg(&_baab))
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_gcdac pdfCIDFontType0) GetRuneMetrics(r rune) (_da.CharMetrics, bool) {
	return _da.CharMetrics{Wx: _gcdac._ggbda}, true
}

func _dafcf() string {
	_gcdec.Lock()
	defer _gcdec.Unlock()
	_gedbgdd := _abc.GetLicenseKey()
	if len(_fbcad) > 0 && (_gedbgdd.IsLicensed() || _ddgae) {
		return _fbcad
	}
	return _c.Sprintf("\u0055\u006e\u0069Do\u0063\u0020\u0076\u0025\u0073\u0020\u0028\u0025\u0073)\u0020-\u0020h\u0074t\u0070\u003a\u002f\u002f\u0075\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f", _afgcg(), _gedbgdd.TypeToString())
}

// NewPdfAnnotationRedact returns a new redact annotation.
func NewPdfAnnotationRedact() *PdfAnnotationRedact {
	_cde := NewPdfAnnotation()
	_gac := &PdfAnnotationRedact{}
	_gac.PdfAnnotation = _cde
	_gac.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cde.SetContext(_gac)
	return _gac
}

func _cadf(_ffd _df.PdfObject) (*PdfFilespec, error) {
	if _ffd == nil {
		return nil, nil
	}
	return NewPdfFilespecFromObj(_ffd)
}

// ToWriter creates a new writer from the current reader, based on the specified options.
// If no options are provided, all reader properties are copied to the writer.
func (_gdgdg *PdfReader) ToWriter(opts *ReaderToWriterOpts) (*PdfWriter, error) {
	_fecb := NewPdfWriter()
	_fecb.SetFileName(_gdgdg._effbb)
	if opts == nil {
		opts = &ReaderToWriterOpts{}
	}
	_fcaffg, _fegba := _gdgdg.GetNumPages()
	if _fegba != nil {
		_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _fegba)
		return nil, _fegba
	}
	for _ebfcg := 1; _ebfcg <= _fcaffg; _ebfcg++ {
		_bdbe, _bfged := _gdgdg.GetPage(_ebfcg)
		if _bfged != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bfged)
			return nil, _bfged
		}
		if opts.PageProcessCallback != nil {
			_bfged = opts.PageProcessCallback(_ebfcg, _bdbe)
			if _bfged != nil {
				_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bfged)
				return nil, _bfged
			}
		} else if opts.PageCallback != nil {
			opts.PageCallback(_ebfcg, _bdbe)
		}
		_bfged = _fecb.AddPage(_bdbe)
		if _bfged != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bfged)
			return nil, _bfged
		}
	}
	_fecb._aeffd = _gdgdg.PdfVersion()
	if !opts.SkipInfo {
		_ebgcc, _agfcg := _gdgdg.GetPdfInfo()
		if _agfcg != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _agfcg)
		} else {
			_fecb._caefe.PdfObject = _ebgcc.ToPdfObject()
		}
	}
	if !opts.SkipMetadata {
		if _ccade := _gdgdg._afbaf.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _ccade != nil {
			if _cbede := _fecb.SetCatalogMetadata(_ccade); _cbede != nil {
				return nil, _cbede
			}
		}
	}
	if !opts.SkipMarkInfo {
		if _aabfe, _fgcc := _gdgdg.GetCatalogMarkInfo(); _fgcc {
			if _ggbfb := _fecb.SetCatalogMarkInfo(_aabfe); _ggbfb != nil {
				return nil, _ggbfb
			}
		}
	}
	if !opts.SkipAcroForm {
		_cfefb := _fecb.SetForms(_gdgdg.AcroForm)
		if _cfefb != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _cfefb)
			return nil, _cfefb
		}
	}
	if !opts.SkipViewerPreferences {
		if _egcbf, _dbgfg := _gdgdg.GetCatalogViewerPreferences(); _dbgfg {
			if _cfbfa := _fecb.SetCatalogViewerPreferences(_egcbf); _cfbfa != nil {
				return nil, _cfbfa
			}
		}
	}
	if !opts.SkipLanguage {
		if _dfbe, _aadfb := _gdgdg.GetCatalogLanguage(); _aadfb {
			if _aagfg := _fecb.SetCatalogLanguage(_dfbe); _aagfg != nil {
				return nil, _aagfg
			}
		}
	}
	if !opts.SkipOutlines {
		_fecb.AddOutlineTree(_gdgdg.GetOutlineTree())
	}
	if !opts.SkipOCProperties {
		_dbgff, _cebgfg := _gdgdg.GetOCProperties()
		if _cebgfg != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _cebgfg)
		} else {
			_cebgfg = _fecb.SetOCProperties(_dbgff)
			if _cebgfg != nil {
				_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _cebgfg)
			}
		}
	}
	if !opts.SkipPageLabels {
		_ebfeb, _gcfe := _gdgdg.GetPageLabels()
		if _gcfe != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gcfe)
		} else {
			_gcfe = _fecb.SetPageLabels(_ebfeb)
			if _gcfe != nil {
				_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gcfe)
			}
		}
	}
	if !opts.SkipNamedDests {
		_dfdcc, _afae := _gdgdg.GetNamedDestinations()
		if _afae != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _afae)
		} else {
			_afae = _fecb.SetNamedDestinations(_dfdcc)
			if _afae != nil {
				_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _afae)
			}
		}
	}
	if !opts.SkipNameDictionary {
		_fgeb, _cgacb := _gdgdg.GetNameDictionary()
		if _cgacb != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _cgacb)
		} else {
			_cgacb = _fecb.SetNameDictionary(_fgeb)
			if _cgacb != nil {
				_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _cgacb)
			}
		}
	}
	_acedd, _cbfca := _gdgdg.GetCatalogStructTreeRoot()
	if _cbfca {
		_accbg := _fecb.SetCatalogStructTreeRoot(_acedd)
		if _accbg != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _accbg)
		}
	}
	if !opts.SkipRotation && _gdgdg.Rotate != nil {
		if _ceaee := _fecb.SetRotation(*_gdgdg.Rotate); _ceaee != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ceaee)
		}
	}
	return &_fecb, nil
}

// R returns the value of the red component of the color.
func (_cabc *PdfColorDeviceRGB) R() float64 { return _cabc[0] }

// GetNumComponents returns the number of color components (3 for Lab).
func (_fdebb *PdfColorLab) GetNumComponents() int { return 3 }

func (_ecea *PdfReader) newPdfFieldFromIndirectObject(_fcbdc *_df.PdfIndirectObject, _ebda *PdfField) (*PdfField, error) {
	if _bcdbf, _bfeb := _ecea._ceggc.GetModelFromPrimitive(_fcbdc).(*PdfField); _bfeb {
		return _bcdbf, nil
	}
	_ddbbd, _fdgf := _df.GetDict(_fcbdc)
	if !_fdgf {
		return nil, _c.Errorf("\u0050\u0064f\u0046\u0069\u0065\u006c\u0064 \u0069\u006e\u0064\u0069\u0072e\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_fgddg := NewPdfField()
	_fgddg._cdbc = _fcbdc
	_fgddg._cdbc.PdfObject = _ddbbd
	if _bcbc, _aedfe := _df.GetName(_ddbbd.Get("\u0046\u0054")); _aedfe {
		_fgddg.FT = _bcbc
	}
	if _ebda != nil {
		_fgddg.Parent = _ebda
	}
	_fgddg.T, _ = _ddbbd.Get("\u0054").(*_df.PdfObjectString)
	_fgddg.TU, _ = _ddbbd.Get("\u0054\u0055").(*_df.PdfObjectString)
	_fgddg.TM, _ = _ddbbd.Get("\u0054\u004d").(*_df.PdfObjectString)
	_fgddg.Ff, _ = _ddbbd.Get("\u0046\u0066").(*_df.PdfObjectInteger)
	_fgddg.V = _ddbbd.Get("\u0056")
	_fgddg.DV = _ddbbd.Get("\u0044\u0056")
	_fgddg.AA = _ddbbd.Get("\u0041\u0041")
	if DA := _ddbbd.Get("\u0044\u0041"); DA != nil {
		DA, _ := _df.GetString(DA)
		_fgddg.VariableText = &VariableText{DA: DA}
		Q, _ := _ddbbd.Get("\u0051").(*_df.PdfObjectInteger)
		DS, _ := _ddbbd.Get("\u0044\u0053").(*_df.PdfObjectString)
		RV := _ddbbd.Get("\u0052\u0056")
		_fgddg.VariableText.Q = Q
		_fgddg.VariableText.DS = DS
		_fgddg.VariableText.RV = RV
	}
	_afbbf := _fgddg.FT
	if _afbbf == nil && _ebda != nil {
		_afbbf = _ebda.FT
	}
	if _afbbf != nil {
		switch *_afbbf {
		case "\u0054\u0078":
			_ceebc, _bbabd := _bddb(_ddbbd)
			if _bbabd != nil {
				return nil, _bbabd
			}
			_ceebc.PdfField = _fgddg
			_fgddg._efcbg = _ceebc
		case "\u0043\u0068":
			_cdag, _faeeb := _daegd(_ddbbd)
			if _faeeb != nil {
				return nil, _faeeb
			}
			_cdag.PdfField = _fgddg
			_fgddg._efcbg = _cdag
		case "\u0042\u0074\u006e":
			_gace, _fddf := _dbgf(_ddbbd)
			if _fddf != nil {
				return nil, _fddf
			}
			_gace.PdfField = _fgddg
			_fgddg._efcbg = _gace
		case "\u0053\u0069\u0067":
			_gfeae, _bafac := _ecea.newPdfFieldSignatureFromDict(_ddbbd)
			if _bafac != nil {
				return nil, _bafac
			}
			_gfeae.PdfField = _fgddg
			_fgddg._efcbg = _gfeae
		default:
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065d\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", *_fgddg.FT)
			return nil, _deb.New("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074\u0079p\u0065")
		}
	}
	if _bfcb, _aggee := _df.GetName(_ddbbd.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")); _aggee {
		if *_bfcb == "\u0057\u0069\u0064\u0067\u0065\u0074" {
			_ccbg, _fgefa := _ecea.newPdfAnnotationFromIndirectObject(_fcbdc)
			if _fgefa != nil {
				return nil, _fgefa
			}
			_fegd, _babg := _ccbg.GetContext().(*PdfAnnotationWidget)
			if !_babg {
				return nil, _deb.New("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0067e\u0074 \u0061n\u006e\u006f\u0074\u0061\u0074\u0069\u006fn")
			}
			_fegd._aeaf = _fgddg
			_fegd.Parent = _fgddg._cdbc
			_fgddg.Annotations = append(_fgddg.Annotations, _fegd)
			return _fgddg, nil
		}
	}
	_gdff := true
	if _bagcba, _afeb := _df.GetArray(_ddbbd.Get("\u004b\u0069\u0064\u0073")); _afeb {
		_fccff := make([]*_df.PdfIndirectObject, 0, _bagcba.Len())
		for _, _dbbgc := range _bagcba.Elements() {
			_afbe, _bbcgg := _df.GetIndirect(_dbbgc)
			if !_bbcgg {
				_bcdg, _bceg := _df.GetStream(_dbbgc)
				if _bceg && _bcdg.PdfObjectDictionary != nil {
					_dafd, _faeg := _df.GetNameVal(_bcdg.Get("\u0054\u0079\u0070\u0065"))
					if _faeg && _dafd == "\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061" {
						_bcd.Log.Debug("E\u0052RO\u0052:\u0020f\u006f\u0072\u006d\u0020\u0066i\u0065\u006c\u0064 \u004b\u0069\u0064\u0073\u0020a\u0072\u0072\u0061y\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0073\u0020\u0069n\u0076\u0061\u006cid \u004d\u0065\u0074\u0061\u0064\u0061t\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e")
						continue
					}
				}
				return nil, _deb.New("n\u006f\u0074\u0020\u0061\u006e\u0020i\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0028\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065\u006cd\u0029")
			}
			_eegg, _cdfc := _df.GetDict(_afbe)
			if !_cdfc {
				return nil, ErrTypeCheck
			}
			if _gdff {
				_gdff = !_aadga(_eegg)
			}
			_fccff = append(_fccff, _afbe)
		}
		for _, _abddc := range _fccff {
			if _gdff {
				_ecfga, _dbca := _ecea.newPdfAnnotationFromIndirectObject(_abddc)
				if _dbca != nil {
					_bcd.Log.Debug("\u0045r\u0072\u006fr\u0020\u006c\u006fa\u0064\u0069\u006e\u0067\u0020\u0077\u0069d\u0067\u0065\u0074\u0020\u0061\u006en\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u006f\u0072 \u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076", _dbca)
					return nil, _dbca
				}
				_ebacc, _dgbg := _ecfga._afaa.(*PdfAnnotationWidget)
				if !_dgbg {
					return nil, ErrTypeCheck
				}
				_ebacc._aeaf = _fgddg
				_fgddg.Annotations = append(_fgddg.Annotations, _ebacc)
			} else {
				_ggeb, _dfff := _ecea.newPdfFieldFromIndirectObject(_abddc, _fgddg)
				if _dfff != nil {
					_bcd.Log.Debug("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0068\u0069\u006c\u0064\u0020\u0066\u0069\u0065\u006c\u0064: \u0025\u0076", _dfff)
					return nil, _dfff
				}
				_fgddg.Kids = append(_fgddg.Kids, _ggeb)
			}
		}
	}
	return _fgddg, nil
}

const (
	BorderStyleSolid     BorderStyle = iota
	BorderStyleDashed    BorderStyle = iota
	BorderStyleBeveled   BorderStyle = iota
	BorderStyleInset     BorderStyle = iota
	BorderStyleUnderline BorderStyle = iota
)

// SetFileName sets the pdf writer file name for metered usage tracker.
func (_gegfdc *PdfWriter) SetFileName(name string) { _gegfdc._bfbb = name }

// PdfActionGoTo represents a GoTo action.
type PdfActionGoTo struct {
	*PdfAction
	D _df.PdfObject
}

func _dcdg(_gcdf *PdfField) []*PdfField {
	_fdgfc := []*PdfField{_gcdf}
	for _, _babb := range _gcdf.Kids {
		_fdgfc = append(_fdgfc, _dcdg(_babb)...)
	}
	return _fdgfc
}

// PdfShadingType1 is a Function-based shading.
type PdfShadingType1 struct {
	*PdfShading
	Domain   *_df.PdfObjectArray
	Matrix   *_df.PdfObjectArray
	Function []PdfFunction
}

func _fbgf(_aeca _df.PdfObject) (*PdfColorspaceLab, error) {
	_bace := NewPdfColorspaceLab()
	if _deaea, _afgd := _aeca.(*_df.PdfIndirectObject); _afgd {
		_bace._dced = _deaea
	}
	_aeca = _df.TraceToDirectObject(_aeca)
	_cbeba, _egffd := _aeca.(*_df.PdfObjectArray)
	if !_egffd {
		return nil, _c.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _cbeba.Len() != 2 {
		return nil, _c.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0043\u0061\u006c\u0052G\u0042 \u0063o\u006c\u006f\u0072\u0073\u0070\u0061\u0063e")
	}
	_aeca = _df.TraceToDirectObject(_cbeba.Get(0))
	_feead, _egffd := _aeca.(*_df.PdfObjectName)
	if !_egffd {
		return nil, _c.Errorf("\u006c\u0061\u0062\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
	}
	if *_feead != "\u004c\u0061\u0062" {
		return nil, _c.Errorf("n\u006ft\u0020\u0061\u0020\u004c\u0061\u0062\u0020\u0063o\u006c\u006f\u0072\u0073pa\u0063\u0065")
	}
	_aeca = _df.TraceToDirectObject(_cbeba.Get(1))
	_bfaa, _egffd := _aeca.(*_df.PdfObjectDictionary)
	if !_egffd {
		return nil, _c.Errorf("c\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006ev\u0061l\u0069\u0064")
	}
	_aeca = _bfaa.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_aeca = _df.TraceToDirectObject(_aeca)
	_cgfbc, _egffd := _aeca.(*_df.PdfObjectArray)
	if !_egffd {
		return nil, _c.Errorf("\u004c\u0061\u0062\u0020In\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069n\u0074")
	}
	if _cgfbc.Len() != 3 {
		return nil, _c.Errorf("\u004c\u0061b\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0061rr\u0061\u0079")
	}
	_bcfed, _daaa := _cgfbc.GetAsFloat64Slice()
	if _daaa != nil {
		return nil, _daaa
	}
	_bace.WhitePoint = _bcfed
	_aeca = _bfaa.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _aeca != nil {
		_aeca = _df.TraceToDirectObject(_aeca)
		_fgge, _faef := _aeca.(*_df.PdfObjectArray)
		if !_faef {
			return nil, _c.Errorf("\u004c\u0061\u0062: \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
		}
		if _fgge.Len() != 3 {
			return nil, _c.Errorf("\u004c\u0061b\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074\u0020\u0061rr\u0061\u0079")
		}
		_dagd, _cgfg := _fgge.GetAsFloat64Slice()
		if _cgfg != nil {
			return nil, _cgfg
		}
		_bace.BlackPoint = _dagd
	}
	_aeca = _bfaa.Get("\u0052\u0061\u006eg\u0065")
	if _aeca != nil {
		_aeca = _df.TraceToDirectObject(_aeca)
		_dafc, _eccf := _aeca.(*_df.PdfObjectArray)
		if !_eccf {
			_bcd.Log.Error("\u0052\u0061n\u0067\u0065\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
			return nil, _c.Errorf("\u004ca\u0062:\u0020\u0054\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		if _dafc.Len() != 4 {
			_bcd.Log.Error("\u0052\u0061\u006e\u0067\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020e\u0072\u0072\u006f\u0072")
			return nil, _c.Errorf("\u004c\u0061b\u003a\u0020\u0052a\u006e\u0067\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_fff, _acbf := _dafc.GetAsFloat64Slice()
		if _acbf != nil {
			return nil, _acbf
		}
		_bace.Range = _fff
	}
	return _bace, nil
}

func (_cggc *PdfAppender) updateObjectsDeep(_dea _df.PdfObject, _ccedc map[_df.PdfObject]struct{}) {
	if _ccedc == nil {
		_ccedc = map[_df.PdfObject]struct{}{}
	}
	if _, _dacec := _ccedc[_dea]; _dacec || _dea == nil {
		return
	}
	_ccedc[_dea] = struct{}{}
	_cbdg := _df.ResolveReferencesDeep(_dea, _cggc._abba)
	if _cbdg != nil {
		_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _cbdg)
	}
	switch _cgcg := _dea.(type) {
	case *_df.PdfIndirectObject:
		switch {
		case _cgcg.GetParser() == _cggc._abf._gfdaag:
			return
		case _cgcg.GetParser() == _cggc.Reader._gfdaag:
			_bgca, _ := _cggc._abf.GetIndirectObjectByNumber(int(_cgcg.ObjectNumber))
			_cabg, _ddgf := _bgca.(*_df.PdfIndirectObject)
			if _ddgf && _cabg != nil {
				if _cabg.PdfObject != _cgcg.PdfObject && _cabg.PdfObject.WriteString() != _cgcg.PdfObject.WriteString() {
					if _gc.Contains(_cgcg.PdfObject.WriteString(), "\u002f\u0053\u0069\u0067") && _gc.Contains(_cgcg.PdfObject.WriteString(), "\u002f\u0053\u0075\u0062\u0074\u0079\u0070\u0065") {
						return
					}
					_cggc.addNewObject(_dea)
					_cggc._aggf[_dea] = _cgcg.ObjectNumber
				}
			}
		default:
			_cggc.addNewObject(_dea)
		}
		_cggc.updateObjectsDeep(_cgcg.PdfObject, _ccedc)
	case *_df.PdfObjectArray:
		for _, _gcba := range _cgcg.Elements() {
			_cggc.updateObjectsDeep(_gcba, _ccedc)
		}
	case *_df.PdfObjectDictionary:
		for _, _gbd := range _cgcg.Keys() {
			_cggc.updateObjectsDeep(_cgcg.Get(_gbd), _ccedc)
		}
	case *_df.PdfObjectStreams:
		if _cgcg.GetParser() != _cggc._abf._gfdaag {
			for _, _cgde := range _cgcg.Elements() {
				_cggc.updateObjectsDeep(_cgde, _ccedc)
			}
		}
	case *_df.PdfObjectStream:
		switch {
		case _cgcg.GetParser() == _cggc._abf._gfdaag:
			return
		case _cgcg.GetParser() == _cggc.Reader._gfdaag:
			if _aage, _adcg := _cggc._abf._gfdaag.LookupByReference(_cgcg.PdfObjectReference); _adcg == nil {
				var _cbbg bool
				if _cgb, _abcd := _df.GetStream(_aage); _abcd && _ef.Equal(_cgb.Stream, _cgcg.Stream) {
					_cbbg = true
				}
				if _fag, _ffacd := _df.GetDict(_aage); _cbbg && _ffacd {
					_cbbg = _fag.WriteString() == _cgcg.PdfObjectDictionary.WriteString()
				}
				if _cbbg {
					return
				}
			}
			if _cgcg.ObjectNumber != 0 {
				_cggc._aggf[_dea] = _cgcg.ObjectNumber
			}
		default:
			if _, _dcad := _cggc._gceg[_dea]; !_dcad {
				_cggc.addNewObject(_dea)
			}
		}
		_cggc.updateObjectsDeep(_cgcg.PdfObjectDictionary, _ccedc)
	}
}

// StandardApplier is the interface that performs optimization of the whole PDF document.
// As a result an input document is being changed by the optimizer.
// The writer than takes back all it's parts and overwrites it.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type StandardApplier interface {
	ApplyStandard(_acabc *_cb.Document) error
}

type pdfFontSimple struct {
	fontCommon
	_adbde *_df.PdfIndirectObject
	_ffefd map[_abg.CharCode]float64
	_ebgg  _abg.TextEncoder
	_geecc _abg.TextEncoder
	_abegg *PdfFontDescriptor

	// Encoding is subject to limitations that are described in 9.6.6, "Character Encoding".
	// BaseFont is derived differently.
	FirstChar _df.PdfObject
	LastChar  _df.PdfObject
	Widths    _df.PdfObject
	Encoding  _df.PdfObject
	_aeeed    *_da.RuneCharSafeMap
}

// AddKChild adds a child K dictionary object.
func (_cagda *KDict) AddKChild(kChild *KDict) {
	_cagda._dacfd = append(_cagda._dacfd, &KValue{_eebde: kChild})
}

// PdfColorspace interface defines the common methods of a PDF colorspace.
// The colorspace defines the data storage format for each color and color representation.
//
// Device based colorspace, specified by name
// - /DeviceGray
// - /DeviceRGB
// - /DeviceCMYK
//
// CIE based colorspace specified by [name, dictionary]
// - [/CalGray dict]
// - [/CalRGB dict]
// - [/Lab dict]
// - [/ICCBased dict]
//
// Special colorspaces
// - /Pattern
// - /Indexed
// - /Separation
// - /DeviceN
//
// Work is in progress to support all colorspaces. At the moment ICCBased color spaces fall back to the alternate
// colorspace which works OK in most cases. For full color support, will need fully featured ICC support.
type PdfColorspace interface {

	// String returns the PdfColorspace's name.
	String() string

	// ImageToRGB converts an Image in a given PdfColorspace to an RGB image.
	ImageToRGB(Image) (Image, error)

	// ColorToRGB converts a single color in a given PdfColorspace to an RGB color.
	ColorToRGB(_afe PdfColor) (PdfColor, error)

	// GetNumComponents returns the number of components in the PdfColorspace.
	GetNumComponents() int

	// ToPdfObject returns a PdfObject representation of the PdfColorspace.
	ToPdfObject() _df.PdfObject

	// ColorFromPdfObjects returns a PdfColor in the given PdfColorspace from an array of PdfObject where each
	// PdfObject represents a numeric value.
	ColorFromPdfObjects(_egbc []_df.PdfObject) (PdfColor, error)

	// ColorFromFloats returns a new PdfColor based on input color components for a given PdfColorspace.
	ColorFromFloats(_fcaf []float64) (PdfColor, error)

	// DecodeArray returns the Decode array for the PdfColorSpace, i.e. the range of each component.
	DecodeArray() []float64
}

func _fbee(_cddgg _df.PdfObject) (*PdfFontDescriptor, error) {
	_cbfg := &PdfFontDescriptor{}
	_cddgg = _df.ResolveReference(_cddgg)
	if _bfdcb, _bgbgb := _cddgg.(*_df.PdfIndirectObject); _bgbgb {
		_cbfg._abaa = _bfdcb
		_cddgg = _bfdcb.PdfObject
	}
	_adfg, _fbea := _df.GetDict(_cddgg)
	if !_fbea {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046o\u006e\u0074\u0044\u0065\u0073c\u0072\u0069\u0070\u0074\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0067\u0069\u0076\u0065\u006e\u0020\u0062\u0079\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _cddgg)
		return nil, _df.ErrTypeError
	}
	if _fece := _adfg.Get("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065"); _fece != nil {
		_cbfg.FontName = _fece
	} else {
		_bcd.Log.Debug("\u0049n\u0063\u006fm\u0070\u0061\u0074\u0069b\u0069\u006c\u0069t\u0079\u003a\u0020\u0046\u006f\u006e\u0074\u004e\u0061me\u0020\u0028\u0052e\u0071\u0075i\u0072\u0065\u0064\u0029\u0020\u006di\u0073\u0073i\u006e\u0067")
	}
	_ccbc, _ := _df.GetName(_cbfg.FontName)
	if _ecbea := _adfg.Get("\u0054\u0079\u0070\u0065"); _ecbea != nil {
		_efaa, _ecbbf := _ecbea.(*_df.PdfObjectName)
		if !_ecbbf || string(*_efaa) != "\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072" {
			_bcd.Log.Debug("I\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072i\u0070t\u006f\u0072\u0020\u0054y\u0070\u0065 \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0025\u0054\u0029\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0025\u0054", _ecbea, _ccbc, _cbfg.FontName)
		}
	} else {
		_bcd.Log.Trace("\u0049\u006ec\u006f\u006d\u0070\u0061\u0074i\u0062\u0069\u006c\u0069\u0074y\u003a\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0025\u0054", _ccbc, _cbfg.FontName)
	}
	_cbfg.FontFamily = _adfg.Get("\u0046\u006f\u006e\u0074\u0046\u0061\u006d\u0069\u006c\u0079")
	_cbfg.FontStretch = _adfg.Get("F\u006f\u006e\u0074\u0053\u0074\u0072\u0065\u0074\u0063\u0068")
	_cbfg.FontWeight = _adfg.Get("\u0046\u006f\u006e\u0074\u0057\u0065\u0069\u0067\u0068\u0074")
	_cbfg.Flags = _adfg.Get("\u0046\u006c\u0061g\u0073")
	_cbfg.FontBBox = _adfg.Get("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078")
	_cbfg.ItalicAngle = _adfg.Get("I\u0074\u0061\u006c\u0069\u0063\u0041\u006e\u0067\u006c\u0065")
	_cbfg.Ascent = _adfg.Get("\u0041\u0073\u0063\u0065\u006e\u0074")
	_cbfg.Descent = _adfg.Get("\u0044e\u0073\u0063\u0065\u006e\u0074")
	_cbfg.Leading = _adfg.Get("\u004ce\u0061\u0064\u0069\u006e\u0067")
	_cbfg.CapHeight = _adfg.Get("\u0043a\u0070\u0048\u0065\u0069\u0067\u0068t")
	_cbfg.XHeight = _adfg.Get("\u0058H\u0065\u0069\u0067\u0068\u0074")
	_cbfg.StemV = _adfg.Get("\u0053\u0074\u0065m\u0056")
	_cbfg.StemH = _adfg.Get("\u0053\u0074\u0065m\u0048")
	_cbfg.AvgWidth = _adfg.Get("\u0041\u0076\u0067\u0057\u0069\u0064\u0074\u0068")
	_cbfg.MaxWidth = _adfg.Get("\u004d\u0061\u0078\u0057\u0069\u0064\u0074\u0068")
	_cbfg.MissingWidth = _adfg.Get("\u004d\u0069\u0073s\u0069\u006e\u0067\u0057\u0069\u0064\u0074\u0068")
	_cbfg.FontFile = _adfg.Get("\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065")
	_cbfg.FontFile2 = _adfg.Get("\u0046o\u006e\u0074\u0046\u0069\u006c\u00652")
	_cbfg.FontFile3 = _adfg.Get("\u0046o\u006e\u0074\u0046\u0069\u006c\u00653")
	_cbfg.CharSet = _adfg.Get("\u0043h\u0061\u0072\u0053\u0065\u0074")
	_cbfg.Style = _adfg.Get("\u0053\u0074\u0079l\u0065")
	_cbfg.Lang = _adfg.Get("\u004c\u0061\u006e\u0067")
	_cbfg.FD = _adfg.Get("\u0046\u0044")
	_cbfg.CIDSet = _adfg.Get("\u0043\u0049\u0044\u0053\u0065\u0074")
	if _cbfg.Flags != nil {
		if _cfea, _fcfb := _df.GetIntVal(_cbfg.Flags); _fcfb {
			_cbfg._cadd = _cfea
		}
	}
	if _cbfg.MissingWidth != nil {
		if _fgga, _cbdbd := _df.GetNumberAsFloat(_cbfg.MissingWidth); _cbdbd == nil {
			_cbfg._faeb = _fgga
		}
	}
	if _cbfg.FontFile != nil {
		_ggebf, _becdg := _addec(_cbfg.FontFile)
		if _becdg != nil {
			return _cbfg, _becdg
		}
		_bcd.Log.Trace("f\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u003d\u0025\u0073", _ggebf)
		_cbfg.fontFile = _ggebf
	}
	if _cbfg.FontFile2 != nil {
		_cadg, _ecfef := _da.NewFontFile2FromPdfObject(_cbfg.FontFile2)
		if _ecfef != nil {
			return _cbfg, _ecfef
		}
		_bcd.Log.Trace("\u0066\u006f\u006et\u0046\u0069\u006c\u0065\u0032\u003d\u0025\u0073", _cadg.String())
		_cbfg._dcgaa = &_cadg
	}
	return _cbfg, nil
}

// PartialName returns the partial name of the field.
func (_cgcfe *PdfField) PartialName() string {
	_fbecb := ""
	if _cgcfe.T != nil {
		_fbecb = _cgcfe.T.Decoded()
	} else {
		_bcd.Log.Debug("\u0046\u0069el\u0064\u0020\u006di\u0073\u0073\u0069\u006eg T\u0020fi\u0065\u006c\u0064\u0020\u0028\u0069\u006eco\u006d\u0070\u0061\u0074\u0069\u0062\u006ce\u0029")
	}
	return _fbecb
}

// ToPdfObject returns the text field dictionary within an indirect object (container).
func (_cfgb *PdfFieldText) ToPdfObject() _df.PdfObject {
	_cfgb.PdfField.ToPdfObject()
	_adcf := _cfgb._cdbc
	_gabdg := _adcf.PdfObject.(*_df.PdfObjectDictionary)
	_gabdg.Set("\u0046\u0054", _df.MakeName("\u0054\u0078"))
	if _cfgb.DA != nil {
		_gabdg.Set("\u0044\u0041", _cfgb.DA)
	}
	if _cfgb.Q != nil {
		_gabdg.Set("\u0051", _cfgb.Q)
	}
	if _cfgb.DS != nil {
		_gabdg.Set("\u0044\u0053", _cfgb.DS)
	}
	if _cfgb.RV != nil {
		_gabdg.Set("\u0052\u0056", _cfgb.RV)
	}
	if _cfgb.MaxLen != nil {
		_gabdg.Set("\u004d\u0061\u0078\u004c\u0065\u006e", _cfgb.MaxLen)
	}
	return _adcf
}

// ToPdfObject recursively builds the Outline tree PDF object.
func (_bgdac *PdfOutlineItem) ToPdfObject() _df.PdfObject {
	_geaae := _bgdac._acfea
	_gadee := _geaae.PdfObject.(*_df.PdfObjectDictionary)
	_gadee.Set("\u0054\u0069\u0074l\u0065", _bgdac.Title)
	if _bgdac.A != nil {
		_gadee.Set("\u0041", _bgdac.A)
	}
	if _fgce := _gadee.Get("\u0053\u0045"); _fgce != nil {
		_gadee.Remove("\u0053\u0045")
	}
	if _bgdac.C != nil {
		_gadee.Set("\u0043", _bgdac.C)
	}
	if _bgdac.Dest != nil {
		_gadee.Set("\u0044\u0065\u0073\u0074", _bgdac.Dest)
	}
	if _bgdac.F != nil {
		_gadee.Set("\u0046", _bgdac.F)
	}
	if _bgdac.Count != nil {
		_gadee.Set("\u0043\u006f\u0075n\u0074", _df.MakeInteger(*_bgdac.Count))
	}
	if _bgdac.Next != nil {
		_gadee.Set("\u004e\u0065\u0078\u0074", _bgdac.Next.ToPdfObject())
	}
	if _bgdac.First != nil {
		_gadee.Set("\u0046\u0069\u0072s\u0074", _bgdac.First.ToPdfObject())
	}
	if _bgdac.Prev != nil {
		_gadee.Set("\u0050\u0072\u0065\u0076", _bgdac.Prev.GetContext().GetContainingPdfObject())
	}
	if _bgdac.Last != nil {
		_gadee.Set("\u004c\u0061\u0073\u0074", _bgdac.Last.GetContext().GetContainingPdfObject())
	}
	if _bgdac.Parent != nil {
		_gadee.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _bgdac.Parent.GetContext().GetContainingPdfObject())
	}
	return _geaae
}

func _aadga(_dffb *_df.PdfObjectDictionary) bool {
	for _, _aafc := range _dffb.Keys() {
		if _, _cade := _cbcf[_aafc.String()]; _cade {
			return true
		}
	}
	return false
}

var (
	_gcdec  _g.Mutex
	_geabeg = ""
	_eebfd  _fa.Time
	_cgaca  = ""
	_dabbc  = ""
	_dfbeb  _fa.Time
	_fbcad  = ""
	_baffd  = ""
	_eabgb  = ""
)

func _efdg(_bafca *PdfAnnotation) (*XObjectForm, *PdfRectangle, error) {
	_gcbff, _cefd := _df.GetDict(_bafca.AP)
	if !_cefd {
		return nil, nil, _deb.New("f\u0069\u0065\u006c\u0064\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0041\u0050\u0020d\u0069\u0063\u0074i\u006fn\u0061\u0072\u0079")
	}
	if _gcbff == nil {
		return nil, nil, nil
	}
	_ddecd, _cefd := _df.GetArray(_bafca.Rect)
	if !_cefd || _ddecd.Len() != 4 {
		return nil, nil, _deb.New("\u0072\u0065\u0063t\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	_deagd, _fggc := NewPdfRectangle(*_ddecd)
	if _fggc != nil {
		return nil, nil, _fggc
	}
	_caedf := _df.TraceToDirectObject(_gcbff.Get("\u004e"))
	switch _aeeef := _caedf.(type) {
	case *_df.PdfObjectStream:
		_bada := _aeeef
		_agdf, _bcdfa := NewXObjectFormFromStream(_bada)
		return _agdf, _deagd, _bcdfa
	case *_df.PdfObjectDictionary:
		_bgea := _aeeef
		if _bgea == nil {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067e\u0074\u0020\u0061\u0070\u0070\u0065\u0061r\u0061\u006e\u0063\u0065\u002e\u0020\u0044\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
			return nil, nil, nil
		}
		var _cafb _df.PdfObject
		_dfdd, _gdad := _df.GetName(_bafca.AS)
		if _gdad {
			_cafb = _bgea.Get(*_dfdd)
		} else {
			_fcec := _bafca._bfde.PdfObject.(*_df.PdfObjectDictionary)
			if _fcec == nil {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020F\u0061\u0069\u006ce\u0064\u0020\u0074\u006f \u0067\u0065\u0074\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0066\u0072\u006f\u006d\u0020\u0076\u0061\u006c\u0075\u0065\u002e")
				return nil, nil, nil
			}
			if _gegb := _fcec.Get("\u0056"); _gegb != nil {
				_cafb = _bgea.Get(_df.PdfObjectName(_gegb.String()))
			}
		}
		if _cafb == nil {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0041\u0053\u0020\u0073\u0074\u0061\u0074\u0065\u0020\u006e\u006f\u0074 \u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0069\u006e\u0020\u0041\u0050\u0020\u0064\u0069\u0063\u0074\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006eg")
			return nil, nil, nil
		}
		_bdbf, _gdad := _df.GetStream(_cafb)
		if !_gdad {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055n\u0061\u0062\u006ce \u0074\u006f\u0020\u0061\u0063\u0063e\u0073\u0073\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0066\u006f\u0072 \u0025\u0076", _dfdd)
			return nil, nil, _deb.New("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		}
		_dcaea, _gddgd := NewXObjectFormFromStream(_bdbf)
		return _dcaea, _deagd, _gddgd
	}
	_bcd.Log.Debug("\u0049\u006e\u0076\u0061li\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0066\u006f\u0072\u0020\u004e\u003a\u0020%\u0054", _caedf)
	return nil, nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
}

func (_bcg *PdfReader) newPdfActionLaunchFromDict(_fdb *_df.PdfObjectDictionary) (*PdfActionLaunch, error) {
	_cbcc, _cac := _cadf(_fdb.Get("\u0046"))
	if _cac != nil {
		return nil, _cac
	}
	return &PdfActionLaunch{Win: _fdb.Get("\u0057\u0069\u006e"), Mac: _fdb.Get("\u004d\u0061\u0063"), Unix: _fdb.Get("\u0055\u006e\u0069\u0078"), NewWindow: _fdb.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), F: _cbcc}, nil
}

// AddPages adds pages to be appended to the end of the source PDF.
func (_abeg *PdfAppender) AddPages(pages ...*PdfPage) {
	for _, _gfba := range pages {
		_gfba = _gfba.Duplicate()
		_dfdde(_gfba)
		_abeg._dgac = append(_abeg._dgac, _gfba)
	}
}

// NewPdfAnnotationLine returns a new line annotation.
func NewPdfAnnotationLine() *PdfAnnotationLine {
	_aacf := NewPdfAnnotation()
	_bcfe := &PdfAnnotationLine{}
	_bcfe.PdfAnnotation = _aacf
	_bcfe.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_aacf.SetContext(_bcfe)
	return _bcfe
}

// NewPdfColorDeviceGray returns a new grayscale color based on an input grayscale float value in range [0-1].
func NewPdfColorDeviceGray(grayVal float64) *PdfColorDeviceGray {
	_ggeg := PdfColorDeviceGray(grayVal)
	return &_ggeg
}

// PdfFunctionType0 uses a sequence of sample values (contained in a stream) to provide an approximation
// for functions whose domains and ranges are bounded. The samples are organized as an m-dimensional
// table in which each entry has n components
type PdfFunctionType0 struct {
	Domain        []float64
	Range         []float64
	NumInputs     int
	NumOutputs    int
	Size          []int
	BitsPerSample int
	Order         int
	Encode        []float64
	Decode        []float64
	_egba         []byte
	_fdfc         []uint32
	_faec         *_df.PdfObjectStream
}

// SetFilter sets compression filter. Decodes with current filter sets and
// encodes the data with the new filter.
func (_gaeac *XObjectImage) SetFilter(encoder _df.StreamEncoder) error {
	_feggc := _gaeac.Stream
	_fgcea, _dgcgeg := _gaeac.Filter.DecodeBytes(_feggc)
	if _dgcgeg != nil {
		return _dgcgeg
	}
	_gaeac.Filter = encoder
	encoder.UpdateParams(_gaeac.getParamsDict())
	_feggc, _dgcgeg = encoder.EncodeBytes(_fgcea)
	if _dgcgeg != nil {
		return _dgcgeg
	}
	_gaeac.Stream = _feggc
	return nil
}

// FieldFlag represents form field flags. Some of the flags can apply to all types of fields whereas other
// flags are specific.
type FieldFlag uint32

// GetExtGState gets the ExtGState specified by keyName. Returns a bool
// indicating whether it was found or not.
func (_aaff *PdfPageResources) GetExtGState(keyName _df.PdfObjectName) (_df.PdfObject, bool) {
	if _aaff.ExtGState == nil {
		return nil, false
	}
	_geca, _bcafa := _df.TraceToDirectObject(_aaff.ExtGState).(*_df.PdfObjectDictionary)
	if !_bcafa {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064 \u0045\u0078\u0074\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0065\u006e\u0074\u0072\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _aaff.ExtGState)
		return nil, false
	}
	if _efaac := _geca.Get(keyName); _efaac != nil {
		return _efaac, true
	}
	return nil, false
}

func (_bdaf *PdfWriter) writeString(_cbgdg string) {
	if _bdaf._bbecc != nil {
		return
	}
	_defeb, _fabfb := _bdaf._cfddc.WriteString(_cbgdg)
	_bdaf._afeab += int64(_defeb)
	_bdaf._bbecc = _fabfb
}

// FlattenFields flattens the form fields and annotations for the PDF loaded in `pdf` and makes
// non-editable.
// Looks up all widget annotations corresponding to form fields and flattens them by drawing the content
// through the content stream rather than annotations.
// References to flattened annotations will be removed from Page Annots array. For fields the AcroForm entry
// will be emptied.
// When `allannots` is true, all annotations will be flattened. Keep false if want to keep non-form related
// annotations intact.
// When `appgen` is not nil, it will be used to generate appearance streams for the field annotations.
func (_fbebf *PdfReader) FlattenFields(allannots bool, appgen FieldAppearanceGenerator) error {
	return _fbebf.flattenFieldsWithOpts(allannots, appgen, nil)
}

// PdfWriter handles outputing PDF content.
type PdfWriter struct {
	_aaag          *_df.PdfIndirectObject
	_ggdac         *_df.PdfIndirectObject
	_fddef         map[_df.PdfObject]struct{}
	_aaadf         []*_df.PdfIndirectObject
	_ceeac         []_df.PdfObject
	_aadfbg        map[_df.PdfObject]struct{}
	_bfbeg         []*_df.PdfIndirectObject
	_cfgeg         *PdfOutlineTreeNode
	_gdee          *_df.PdfObjectDictionary
	_bbeda         []_df.PdfObject
	_caefe         *_df.PdfIndirectObject
	_cfddc         *_dg.Writer
	_afeab         int64
	_bbecc         error
	_fcdg          *_df.PdfCrypt
	_cgfadg        *_df.PdfObjectDictionary
	_deega         *_df.PdfIndirectObject
	_fgdf          *_df.PdfObjectArray
	_aeffd         _df.Version
	_ccbfe         *bool
	_acgefe        map[_df.PdfObject][]*_df.PdfObjectDictionary
	_cecbge        *PdfAcroForm
	_adadc         *Names
	_bgagb         Optimizer
	_fbcafd        StandardApplier
	_cdgd          map[int]crossReference
	_bcfff         int64
	ObjNumOffset   int
	_gebfg         bool
	_cbgfg         _df.XrefTable
	_ebfcba        int64
	_acfdce        int64
	_gbga          map[_df.PdfObject]int64
	_dfadb         map[_df.PdfObject]struct{}
	_gcfcfa        string
	_bfbb          string
	_dfbgg         []*PdfOutputIntent
	_aeebe         bool
	_aadde, _addee string
}

// Direction returns the value of the direction.
func (_ddff *ViewerPreferences) Direction() Direction { return _ddff._cggbe }

// GetContentStream returns the pattern cell's content stream
func (_gfgdg *PdfTilingPattern) GetContentStream() ([]byte, error) {
	_gadce, _, _ebbg := _gfgdg.GetContentStreamWithEncoder()
	return _gadce, _ebbg
}

// NewPdfActionGoTo returns a new "go to" action.
func NewPdfActionGoTo() *PdfActionGoTo {
	_gcd := NewPdfAction()
	_gf := &PdfActionGoTo{}
	_gf.PdfAction = _gcd
	_gcd.SetContext(_gf)
	return _gf
}

// GetContainingPdfObject implements interface PdfModel.
func (_fgbbb *PdfSignature) GetContainingPdfObject() _df.PdfObject { return _fgbbb._aeddbb }

// GetType returns the button field type which returns one of the following
// - PdfFieldButtonPush for push button fields
// - PdfFieldButtonCheckbox for checkbox fields
// - PdfFieldButtonRadio for radio button fields
func (_bagcb *PdfFieldButton) GetType() ButtonType {
	_cecc := ButtonTypeCheckbox
	if _bagcb.Ff != nil {
		if (uint32(*_bagcb.Ff) & FieldFlagPushbutton.Mask()) > 0 {
			_cecc = ButtonTypePush
		} else if (uint32(*_bagcb.Ff) & FieldFlagRadio.Mask()) > 0 {
			_cecc = ButtonTypeRadio
		}
	}
	return _cecc
}

// ColorFromPdfObjects returns a new PdfColor based on input color components. The input PdfObjects should
// be numeric.
func (_gbfb *PdfColorspaceDeviceN) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if len(objects) != _gbfb.GetNumComponents() {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gde, _gggg := _df.GetNumbersAsFloat(objects)
	if _gggg != nil {
		return nil, _gggg
	}
	return _gbfb.ColorFromFloats(_gde)
}

// GetNumComponents returns the number of color components (1 for grayscale).
func (_gbfg *PdfColorDeviceGray) GetNumComponents() int { return 1 }

// NewPdfColorspaceSpecialSeparation returns a new separation color.
func NewPdfColorspaceSpecialSeparation() *PdfColorspaceSpecialSeparation {
	_gffdc := &PdfColorspaceSpecialSeparation{}
	return _gffdc
}

// NewPdfAnnotationInk returns a new ink annotation.
func NewPdfAnnotationInk() *PdfAnnotationInk {
	_gccg := NewPdfAnnotation()
	_bfc := &PdfAnnotationInk{}
	_bfc.PdfAnnotation = _gccg
	_bfc.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_gccg.SetContext(_bfc)
	return _bfc
}

// GetXObjectByName gets XObject by name.
func (_bdee *PdfPage) GetXObjectByName(name _df.PdfObjectName) (_df.PdfObject, bool) {
	_efef, _dbceg := _bdee.Resources.XObject.(*_df.PdfObjectDictionary)
	if !_dbceg {
		return nil, false
	}
	if _dcbgaa := _efef.Get(name); _dcbgaa != nil {
		return _dcbgaa, true
	}
	return nil, false
}

// AddExtension adds the specified extension to the Extensions dictionary.
// See section 7.1.2 "Extensions Dictionary" (pp. 108-109 PDF32000_2008).
func (_ggde *PdfWriter) AddExtension(extName, baseVersion string, extLevel int) {
	_ceecg, _gfbg := _df.GetDict(_ggde._gdee.Get("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006e\u0073"))
	if !_gfbg {
		_ceecg = _df.MakeDict()
		_ggde._gdee.Set("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006e\u0073", _ceecg)
	}
	_begdf, _gfbg := _df.GetDict(_ceecg.Get(_df.PdfObjectName(extName)))
	if !_gfbg {
		_begdf = _df.MakeDict()
		_ceecg.Set(_df.PdfObjectName(extName), _begdf)
	}
	if _dcea, _ := _df.GetNameVal(_begdf.Get("B\u0061\u0073\u0065\u0056\u0065\u0072\u0073\u0069\u006f\u006e")); _dcea != baseVersion {
		_begdf.Set("B\u0061\u0073\u0065\u0056\u0065\u0072\u0073\u0069\u006f\u006e", _df.MakeName(baseVersion))
	}
	if _ddbca, _ := _df.GetIntVal(_begdf.Get("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006eL\u0065\u0076\u0065\u006c")); _ddbca != extLevel {
		_begdf.Set("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006eL\u0065\u0076\u0065\u006c", _df.MakeInteger(int64(extLevel)))
	}
}

// ToPdfObject implements interface PdfModel.
func (_adca *PdfBorderStyle) ToPdfObject() _df.PdfObject {
	_fbab := _df.MakeDict()
	if _adca._bbcf != nil {
		if _dgdd, _cbbe := _adca._bbcf.(*_df.PdfIndirectObject); _cbbe {
			_dgdd.PdfObject = _fbab
		}
	}
	_fbab.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0042\u006f\u0072\u0064\u0065\u0072"))
	if _adca.W != nil {
		_fbab.Set("\u0057", _df.MakeFloat(*_adca.W))
	}
	if _adca.S != nil {
		_fbab.Set("\u0053", _df.MakeName(_adca.S.GetPdfName()))
	}
	if _adca.D != nil {
		_fbab.Set("\u0044", _df.MakeArrayFromIntegers(*_adca.D))
	}
	if _adca._bbcf != nil {
		return _adca._bbcf
	}
	return _fbab
}

// ToPdfObject implements interface PdfModel.
func (_eada *PdfAnnotationFileAttachment) ToPdfObject() _df.PdfObject {
	_eada.PdfAnnotation.ToPdfObject()
	_ffbdg := _eada._bfde
	_cfdc := _ffbdg.PdfObject.(*_df.PdfObjectDictionary)
	_eada.PdfAnnotationMarkup.appendToPdfDictionary(_cfdc)
	_cfdc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0046\u0069\u006c\u0065\u0041\u0074\u0074\u0061\u0063h\u006d\u0065\u006e\u0074"))
	_cfdc.SetIfNotNil("\u0046\u0053", _eada.FS)
	_cfdc.SetIfNotNil("\u004e\u0061\u006d\u0065", _eada.Name)
	return _ffbdg
}

func _ecbe(_bdcg *XObjectForm) (*PdfRectangle, bool, error) {
	if _abcb, _eafdc := _bdcg.BBox.(*_df.PdfObjectArray); _eafdc {
		_fcfdc, _cfdb := NewPdfRectangle(*_abcb)
		if _cfdb != nil {
			return nil, false, _cfdb
		}
		if _fgfge, _bafd := _bdcg.Matrix.(*_df.PdfObjectArray); _bafd {
			_fadge, _gbed := _fgfge.ToFloat64Array()
			if _gbed != nil {
				return nil, false, _gbed
			}
			_fbdf := _dbc.IdentityMatrix()
			if len(_fadge) == 6 {
				_fbdf = _dbc.NewMatrix(_fadge[0], _fadge[1], _fadge[2], _fadge[3], _fadge[4], _fadge[5])
			}
			_fcfdc.Transform(_fbdf)
			return _fcfdc, true, nil
		}
		return _fcfdc, false, nil
	}
	return nil, false, _deb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061n\u0063e\u0020\u0042\u0042\u006f\u0078\u0020\u0074y\u0070\u0065")
}

// GetAsTilingPattern returns a tiling pattern. Check with IsTiling() prior to using this.
func (_ddfgfd *PdfPattern) GetAsTilingPattern() *PdfTilingPattern {
	return _ddfgfd._ecfde.(*PdfTilingPattern)
}

// CompliancePdfReader is a wrapper over PdfReader that is used for verifying if the input Pdf document matches the
// compliance rules of standards like PDF/A.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type CompliancePdfReader struct {
	*PdfReader
	_deegf _df.ParserMetadata
}

var (
	StructureTypeDocument      = "\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074"
	StructureTypePart          = "\u0050\u0061\u0072\u0074"
	StructureTypeArticle       = "\u0041\u0072\u0074"
	StructureTypeSection       = "\u0053\u0065\u0063\u0074"
	StructureTypeDivision      = "\u0044\u0069\u0076"
	StructureTypeBlockQuote    = "\u0042\u006c\u006f\u0063\u006b\u0051\u0075\u006f\u0074\u0065"
	StructureTypeCaption       = "\u0043a\u0070\u0074\u0069\u006f\u006e"
	StructureTypeTOC           = "\u0054\u004f\u0043"
	StructureTypeTOCI          = "\u0054\u004f\u0043\u0049"
	StructureTypeIndex         = "\u0049\u006e\u0064e\u0078"
	StructureTypeNonStructural = "\u004eo\u006e\u0053\u0074\u0072\u0075\u0063t"
	StructureTypePrivate       = "\u0050r\u0069\u0076\u0061\u0074\u0065"
)

func (_aefcb *PdfReader) loadForms() (*PdfAcroForm, error) {
	if _aefcb._gfdaag.GetCrypter() != nil && !_aefcb._gfdaag.IsAuthenticated() {
		return nil, _c.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_eccgd := _aefcb._afbaf
	_ecdbd := _eccgd.Get("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d")
	if _ecdbd == nil {
		return nil, nil
	}
	_affga, _dgaab := _df.GetIndirect(_ecdbd)
	_ecdbd = _df.TraceToDirectObject(_ecdbd)
	if _df.IsNullObject(_ecdbd) {
		_bcd.Log.Trace("\u0041\u0063\u0072of\u006f\u0072\u006d\u0020\u0069\u0073\u0020\u0061\u0020n\u0075l\u006c \u006fb\u006a\u0065\u0063\u0074\u0020\u0028\u0065\u006d\u0070\u0074\u0079\u0029\u000a")
		return nil, nil
	}
	_cgabe, _gfeda := _df.GetDict(_ecdbd)
	if !_gfeda {
		_bcd.Log.Debug("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0041\u0063\u0072\u006fF\u006fr\u006d \u0065\u006e\u0074\u0072\u0079\u0020\u0025T", _ecdbd)
		_bcd.Log.Debug("\u0044\u006f\u0065\u0073 n\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0066\u006f\u0072\u006d\u0073")
		if _aefcb._cbcee.RelaxedMode {
			_bcd.Log.Debug("\u0052\u0065\u006c\u0061\u0078\u0065\u0064\u004d\u006f\u0064\u0065 \u0065\u006e\u0061\u0062\u006c\u0065\u0064\u002e \u0049g\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u0020\u006c\u006fa\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u0073")
			return nil, nil
		}
		return nil, _c.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0061\u0063\u0072\u006ff\u006fr\u006d \u0065\u006e\u0074\u0072\u0079\u0020\u0025T", _ecdbd)
	}
	_bcd.Log.Trace("\u0048\u0061\u0073\u0020\u0041\u0063\u0072\u006f\u0020f\u006f\u0072\u006d\u0073")
	_bcd.Log.Trace("\u0054\u0072\u0061\u0076\u0065\u0072\u0073\u0065\u0020\u0074\u0068\u0065\u0020\u0041\u0063r\u006ff\u006f\u0072\u006d\u0073\u0020\u0073\u0074\u0072\u0075\u0063\u0074\u0075\u0072\u0065")
	if !_aefcb._edbbdf {
		_cfedg := _aefcb.traverseObjectData(_cgabe)
		if _cfedg != nil {
			_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0074\u0072a\u0076\u0065\u0072\u0073\u0065\u0020\u0041\u0063\u0072\u006fFo\u0072\u006d\u0073 \u0028%\u0073\u0029", _cfedg)
			return nil, _cfedg
		}
	}
	_adbdb, _bdace := _aefcb.newPdfAcroFormFromDict(_affga, _cgabe)
	if _bdace != nil {
		return nil, _bdace
	}
	_adbdb._caead = !_dgaab
	return _adbdb, nil
}

// ToPdfObject implements interface PdfModel.
func (_bddd *PdfAnnotationRedact) ToPdfObject() _df.PdfObject {
	_bddd.PdfAnnotation.ToPdfObject()
	_gcfa := _bddd._bfde
	_eeab := _gcfa.PdfObject.(*_df.PdfObjectDictionary)
	_bddd.PdfAnnotationMarkup.appendToPdfDictionary(_eeab)
	_eeab.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0052\u0065\u0064\u0061\u0063\u0074"))
	_eeab.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _bddd.QuadPoints)
	_eeab.SetIfNotNil("\u0049\u0043", _bddd.IC)
	_eeab.SetIfNotNil("\u0052\u004f", _bddd.RO)
	_eeab.SetIfNotNil("O\u0076\u0065\u0072\u006c\u0061\u0079\u0054\u0065\u0078\u0074", _bddd.OverlayText)
	_eeab.SetIfNotNil("\u0052\u0065\u0070\u0065\u0061\u0074", _bddd.Repeat)
	_eeab.SetIfNotNil("\u0044\u0041", _bddd.DA)
	_eeab.SetIfNotNil("\u0051", _bddd.Q)
	return _gcfa
}

func _deeac(_abgb _df.PdfObject) (*PdfFunctionType3, error) {
	_cbbb := &PdfFunctionType3{}
	var _gfcgg *_df.PdfObjectDictionary
	if _ggcfa, _cdff := _abgb.(*_df.PdfIndirectObject); _cdff {
		_bcebd, _faae := _ggcfa.PdfObject.(*_df.PdfObjectDictionary)
		if !_faae {
			return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_cbbb._ffeg = _ggcfa
		_gfcgg = _bcebd
	} else if _fgfff, _bfbgc := _abgb.(*_df.PdfObjectDictionary); _bfbgc {
		_gfcgg = _fgfff
	} else {
		return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_acage, _cdegf := _df.TraceToDirectObject(_gfcgg.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_df.PdfObjectArray)
	if !_cdegf {
		_bcd.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _deb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _acage.Len() != 2 {
		_bcd.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _deb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_gbdge, _dgbdf := _acage.ToFloat64Array()
	if _dgbdf != nil {
		return nil, _dgbdf
	}
	_cbbb.Domain = _gbdge
	_acage, _cdegf = _df.TraceToDirectObject(_gfcgg.Get("\u0052\u0061\u006eg\u0065")).(*_df.PdfObjectArray)
	if _cdegf {
		if _acage.Len() < 0 || _acage.Len()%2 != 0 {
			return nil, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_fbeef, _gacbb := _acage.ToFloat64Array()
		if _gacbb != nil {
			return nil, _gacbb
		}
		_cbbb.Range = _fbeef
	}
	_acage, _cdegf = _df.TraceToDirectObject(_gfcgg.Get("\u0046u\u006e\u0063\u0074\u0069\u006f\u006es")).(*_df.PdfObjectArray)
	if !_cdegf {
		_bcd.Log.Error("\u0046\u0075\u006ect\u0069\u006f\u006e\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064")
		return nil, _deb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_cbbb.Functions = []PdfFunction{}
	for _, _gafa := range _acage.Elements() {
		_bdgg, _eecc := _ddaac(_gafa)
		if _eecc != nil {
			return nil, _eecc
		}
		_cbbb.Functions = append(_cbbb.Functions, _bdgg)
	}
	_acage, _cdegf = _df.TraceToDirectObject(_gfcgg.Get("\u0042\u006f\u0075\u006e\u0064\u0073")).(*_df.PdfObjectArray)
	if !_cdegf {
		_bcd.Log.Error("B\u006fu\u006e\u0064\u0073\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _deb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_cbaegf, _dgbdf := _acage.ToFloat64Array()
	if _dgbdf != nil {
		return nil, _dgbdf
	}
	_cbbb.Bounds = _cbaegf
	if len(_cbbb.Bounds) != len(_cbbb.Functions)-1 {
		_bcd.Log.Error("B\u006f\u0075\u006e\u0064\u0073\u0020\u0028\u0025\u0064)\u0020\u0061\u006e\u0064\u0020\u006e\u0075m \u0066\u0075\u006e\u0063t\u0069\u006f\u006e\u0073\u0020\u0028\u0025\u0064\u0029 n\u006f\u0074 \u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067", len(_cbbb.Bounds), len(_cbbb.Functions))
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_acage, _cdegf = _df.TraceToDirectObject(_gfcgg.Get("\u0045\u006e\u0063\u006f\u0064\u0065")).(*_df.PdfObjectArray)
	if !_cdegf {
		_bcd.Log.Error("E\u006ec\u006f\u0064\u0065\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _deb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_bfdcf, _dgbdf := _acage.ToFloat64Array()
	if _dgbdf != nil {
		return nil, _dgbdf
	}
	_cbbb.Encode = _bfdcf
	if len(_cbbb.Encode) != 2*len(_cbbb.Functions) {
		_bcd.Log.Error("\u004c\u0065\u006e\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0020\u0028\u0025\u0064\u0029 \u0061\u006e\u0064\u0020\u006e\u0075\u006d\u0020\u0066\u0075\u006e\u0063\u0074i\u006f\u006e\u0073\u0020\u0028\u0025\u0064\u0029\u0020\u006e\u006f\u0074 m\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u0075\u0070", len(_cbbb.Encode), len(_cbbb.Functions))
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	return _cbbb, nil
}

// SetDisplayDocTitle sets the value of the displayDocTitle flag.
func (_abcfa *ViewerPreferences) SetDisplayDocTitle(displayDocTitle bool) {
	_abcfa._bfggg = &displayDocTitle
}

// BorderEffect represents a border effect (Table 167 p. 395).
type BorderEffect int

// Height returns the height of `rect`.
func (_aebgg *PdfRectangle) Height() float64 { return _faf.Abs(_aebgg.Ury - _aebgg.Lly) }

// String returns a human readable description of `fontfile`.
func (_geggg *fontFile) String() string {
	_ecceg := "\u005b\u004e\u006f\u006e\u0065\u005d"
	if _geggg._dgacb != nil {
		_ecceg = _geggg._dgacb.String()
	}
	return _c.Sprintf("\u0046O\u004e\u0054\u0046\u0049\u004c\u0045\u007b\u0025\u0023\u0071\u0020e\u006e\u0063\u006f\u0064\u0065\u0072\u003d\u0025\u0073\u007d", _geggg._accbb, _ecceg)
}

// Width returns the width of `rect`.
func (_bbdac *PdfRectangle) Width() float64 { return _faf.Abs(_bbdac.Urx - _bbdac.Llx) }

// PdfDate represents a date, which is a PDF string of the form:
// (D:YYYYMMDDHHmmSSOHH'mm)
type PdfDate struct {
	_gfddd  int64
	_dgfba  int64
	_bgggf  int64
	_deagge int64
	_bbcbg  int64
	_dgabf  int64
	_cefda  byte
	_gabf   int64
	_fgeefd int64
}

// EncryptOptions represents encryption options for an output PDF.
type EncryptOptions struct {
	Permissions _afc.Permissions
	Algorithm   EncryptionAlgorithm
}

// FieldAppearanceGenerator generates appearance stream for a given field.
type FieldAppearanceGenerator interface {
	ContentStreamWrapper
	GenerateAppearanceDict(_becb *PdfAcroForm, _abgfb *PdfField, _ddda *PdfAnnotationWidget) (*_df.PdfObjectDictionary, error)
}

func _eggf(_ffabe _df.PdfObject, _edef *fontCommon) (*_dgf.CMap, error) {
	_eceaf, _beefa := _df.GetStream(_ffabe)
	if !_beefa {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0074\u006f\u0055\u006e\u0069\u0063\u006f\u0064\u0065\u0054\u006f\u0043m\u0061\u0070\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0025\u0054\u0029", _ffabe)
		return nil, _df.ErrTypeError
	}
	_ggadc, _geaeb := _df.DecodeStream(_eceaf)
	if _geaeb != nil {
		return nil, _geaeb
	}
	_eafc, _geaeb := _dgf.LoadCmapFromData(_ggadc, !_edef.isCIDFont())
	if _geaeb != nil {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u004e\u0075\u006d\u0062\u0065\u0072\u003d\u0025\u0064\u0020\u0065\u0072r=\u0025\u0076", _eceaf.ObjectNumber, _geaeb)
	}
	return _eafc, _geaeb
}

// Encrypt encrypts the output file with a specified user/owner password.
func (_bbaafe *PdfWriter) Encrypt(userPass, ownerPass []byte, options *EncryptOptions) error {
	_eaed := RC4_128bit
	if options != nil {
		_eaed = options.Algorithm
	}
	_ddded := _afc.PermOwner
	if options != nil {
		_ddded = options.Permissions
	}
	var _dcdfc _bfb.Filter
	switch _eaed {
	case RC4_128bit:
		_dcdfc = _bfb.NewFilterV2(16)
	case AES_128bit:
		_dcdfc = _bfb.NewFilterAESV2()
	case AES_256bit:
		_dcdfc = _bfb.NewFilterAESV3()
	default:
		return _c.Errorf("\u0075n\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020a\u006cg\u006fr\u0069\u0074\u0068\u006d\u003a\u0020\u0025v", options.Algorithm)
	}
	_gacbbg, _bcbag, _decaef := _df.PdfCryptNewEncrypt(_dcdfc, userPass, ownerPass, _ddded)
	if _decaef != nil {
		return _decaef
	}
	_bbaafe._fcdg = _gacbbg
	if _bcbag.Major != 0 {
		_bbaafe.SetVersion(_bcbag.Major, _bcbag.Minor)
	}
	_bbaafe._cgfadg = _bcbag.Encrypt
	_bbaafe._aadde, _bbaafe._addee = _bcbag.ID0, _bcbag.ID1
	_gdcba := _df.MakeIndirectObject(_bcbag.Encrypt)
	_bbaafe._deega = _gdcba
	_bbaafe.addObject(_gdcba)
	return nil
}

// GetContentStreams returns the content stream as an array of strings.
func (_fabbfe *PdfPage) GetContentStreams() ([]string, error) {
	_dffbc := _fabbfe.GetContentStreamObjs()
	var _cffdf []string
	for _, _eegca := range _dffbc {
		_febga, _eagbe := _fcdf(_eegca)
		if _eagbe != nil {
			return nil, _eagbe
		}
		_cffdf = append(_cffdf, _febga)
	}
	return _cffdf, nil
}

// ToGray returns a PdfColorDeviceGray color based on the current RGB color.
func (_fbff *PdfColorDeviceRGB) ToGray() *PdfColorDeviceGray {
	_abdd := 0.3*_fbff.R() + 0.59*_fbff.G() + 0.11*_fbff.B()
	_abdd = _faf.Min(_faf.Max(_abdd, 0.0), 1.0)
	return NewPdfColorDeviceGray(_abdd)
}

// PdfSignature represents a PDF signature dictionary and is used for signing via form signature fields.
// (Section 12.8, Table 252 - Entries in a signature dictionary p. 475 in PDF32000_2008).
type PdfSignature struct {
	Handler SignatureHandler
	_aeddbb *_df.PdfIndirectObject

	// Type: Sig/DocTimeStamp
	Type         *_df.PdfObjectName
	Filter       *_df.PdfObjectName
	SubFilter    *_df.PdfObjectName
	Contents     *_df.PdfObjectString
	Cert         _df.PdfObject
	ByteRange    *_df.PdfObjectArray
	Reference    *_df.PdfObjectArray
	Changes      *_df.PdfObjectArray
	Name         *_df.PdfObjectString
	M            *_df.PdfObjectString
	Location     *_df.PdfObjectString
	Reason       *_df.PdfObjectString
	ContactInfo  *_df.PdfObjectString
	R            *_df.PdfObjectInteger
	V            *_df.PdfObjectInteger
	PropBuild    *_df.PdfObjectDictionary
	PropAuthTime *_df.PdfObjectInteger
	PropAuthType *_df.PdfObjectName
}

// Items returns all children outline items.
func (_agbag *Outline) Items() []*OutlineItem { return _agbag.Entries }

// ImageToRGB converts image in CalGray color space to RGB (A, B, C -> X, Y, Z).
func (_efec *PdfColorspaceCalGray) ImageToRGB(img Image) (Image, error) {
	_geddf := _aff.NewReader(img.getBase())
	_cagc := _bge.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, nil, nil)
	_fede := _aff.NewWriter(_cagc)
	_gbeb := _faf.Pow(2, float64(img.BitsPerComponent)) - 1
	_dade := make([]uint32, 3)
	var (
		_dece                               uint32
		ANorm, X, Y, Z, _cdee, _gcfd, _ecfd float64
		_cafg                               error
	)
	for {
		_dece, _cafg = _geddf.ReadSample()
		if _cafg == _bdd.EOF {
			break
		} else if _cafg != nil {
			return img, _cafg
		}
		ANorm = float64(_dece) / _gbeb
		X = _efec.WhitePoint[0] * _faf.Pow(ANorm, _efec.Gamma)
		Y = _efec.WhitePoint[1] * _faf.Pow(ANorm, _efec.Gamma)
		Z = _efec.WhitePoint[2] * _faf.Pow(ANorm, _efec.Gamma)
		_cdee = 3.240479*X + -1.537150*Y + -0.498535*Z
		_gcfd = -0.969256*X + 1.875992*Y + 0.041556*Z
		_ecfd = 0.055648*X + -0.204043*Y + 1.057311*Z
		_cdee = _faf.Min(_faf.Max(_cdee, 0), 1.0)
		_gcfd = _faf.Min(_faf.Max(_gcfd, 0), 1.0)
		_ecfd = _faf.Min(_faf.Max(_ecfd, 0), 1.0)
		_dade[0] = uint32(_cdee * _gbeb)
		_dade[1] = uint32(_gcfd * _gbeb)
		_dade[2] = uint32(_ecfd * _gbeb)
		if _cafg = _fede.WriteSamples(_dade); _cafg != nil {
			return img, _cafg
		}
	}
	return _agbg(&_cagc), nil
}

// String implements interface PdfObject.
func (_cca *PdfAction) String() string {
	_fad, _efb := _cca.ToPdfObject().(*_df.PdfIndirectObject)
	if _efb {
		return _c.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _cca._aab, _fad.PdfObject.String())
	}
	return ""
}

// NumCopies returns the value of the numCopies.
func (_dfbccc *ViewerPreferences) NumCopies() int { return _dfbccc._edded }

// NewPdfColorCalGray returns a new CalGray color.
func NewPdfColorCalGray(grayVal float64) *PdfColorCalGray {
	_ffaa := PdfColorCalGray(grayVal)
	return &_ffaa
}

// NewCustomPdfOutputIntent creates a new custom PdfOutputIntent.
func NewCustomPdfOutputIntent(outputCondition, outputConditionIdentifier, info string, destOutputProfile []byte, colorComponents int) *PdfOutputIntent {
	return &PdfOutputIntent{Type: "\u004f\u0075\u0074p\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074", OutputCondition: outputCondition, OutputConditionIdentifier: outputConditionIdentifier, Info: info, DestOutputProfile: destOutputProfile, _eeff: _df.MakeDict(), ColorComponents: colorComponents}
}

// GetFontDescriptor returns the font descriptor for `font`.
func (_afdg PdfFont) GetFontDescriptor() (*PdfFontDescriptor, error) {
	return _afdg._eaeg.getFontDescriptor(), nil
}

// PdfShadingType3 is a Radial shading.
type PdfShadingType3 struct {
	*PdfShading
	Coords   *_df.PdfObjectArray
	Domain   *_df.PdfObjectArray
	Function []PdfFunction
	Extend   *_df.PdfObjectArray
}

// ToPdfObject returns the PDF representation of the DSS dictionary.
func (_caaee *DSS) ToPdfObject() _df.PdfObject {
	_eacf := _caaee._dbdf.PdfObject.(*_df.PdfObjectDictionary)
	_eacf.Clear()
	_bcbgc := _df.MakeDict()
	for _edbc, _dbeg := range _caaee.VRI {
		_bcbgc.Set(*_df.MakeName(_edbc), _dbeg.ToPdfObject())
	}
	_eacf.SetIfNotNil("\u0043\u0065\u0072t\u0073", _gcedg(_caaee.Certs))
	_eacf.SetIfNotNil("\u004f\u0043\u0053P\u0073", _gcedg(_caaee.OCSPs))
	_eacf.SetIfNotNil("\u0043\u0052\u004c\u0073", _gcedg(_caaee.CRLs))
	_eacf.Set("\u0056\u0052\u0049", _bcbgc)
	return _caaee._dbdf
}

// NewPdfFileSpecFromEmbeddedFile construct a new PdfFileSpec that contains an embedded file.
func NewPdfFileSpecFromEmbeddedFile(file *EmbeddedFile) *PdfFilespec {
	_ccfc := &PdfFilespec{}
	_ccfc._gaafd = _df.MakeIndirectObject(_df.MakeDict())
	_ccfc.Desc = _df.MakeString(file.Description)
	_ccfc.EF = file.ToPdfObject()
	_ccfc.F = _df.MakeString(file.Name)
	_ccfc.UF = _df.MakeEncodedString(file.Name, true)
	_cebfc := "U\u006e\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064"
	switch file.Relationship {
	case RelationshipSource:
		_cebfc = "\u0053\u006f\u0075\u0072\u0063\u0065"
	case RelationshipData:
		_cebfc = "\u0044\u0061\u0074\u0061"
	case RelationshipAlternative:
		_cebfc = "A\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065"
	case RelationshipSupplement:
		_cebfc = "\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074"
	}
	_ccfc.AFRelationship = _df.MakeName(_cebfc)
	return _ccfc
}

// AddRefChild adds a child reference object.
func (_gbcfa *KDict) AddRefChild(kChild *_df.PdfObjectDictionary) {
	_gbcfa._dacfd = append(_gbcfa._dacfd, &KValue{_ccgeg: kChild})
}

// ToPdfObject implements interface PdfModel.
func (_dcg *PdfActionSound) ToPdfObject() _df.PdfObject {
	_dcg.PdfAction.ToPdfObject()
	_afa := _dcg._gcf
	_bfd := _afa.PdfObject.(*_df.PdfObjectDictionary)
	_bfd.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeSound)))
	_bfd.SetIfNotNil("\u0053\u006f\u0075n\u0064", _dcg.Sound)
	_bfd.SetIfNotNil("\u0056\u006f\u006c\u0075\u006d\u0065", _dcg.Volume)
	_bfd.SetIfNotNil("S\u0079\u006e\u0063\u0068\u0072\u006f\u006e\u006f\u0075\u0073", _dcg.Synchronous)
	_bfd.SetIfNotNil("\u0052\u0065\u0070\u0065\u0061\u0074", _dcg.Repeat)
	_bfd.SetIfNotNil("\u004d\u0069\u0078", _dcg.Mix)
	return _afa
}

// PrintClip returns the value of the printClip.
func (_ecbaa *ViewerPreferences) PrintClip() PageBoundary { return _ecbaa._edeeb }

// ButtonType represents the subtype of a button field, can be one of:
// - Checkbox (ButtonTypeCheckbox)
// - PushButton (ButtonTypePushButton)
// - RadioButton (ButtonTypeRadioButton)
type ButtonType int

// NewPdfActionResetForm returns a new "reset form" action.
func NewPdfActionResetForm() *PdfActionResetForm {
	_abe := NewPdfAction()
	_edf := &PdfActionResetForm{}
	_edf.PdfAction = _abe
	_abe.SetContext(_edf)
	return _edf
}

// DecodeArray returns the range of color component values in the Lab colorspace.
func (_bgac *PdfColorspaceLab) DecodeArray() []float64 {
	_ddaeb := []float64{0, 100}
	if _bgac != nil && _bgac.Range != nil && len(_bgac.Range) == 4 {
		_ddaeb = append(_ddaeb, _bgac.Range...)
	} else {
		_ddaeb = append(_ddaeb, -100, 100, -100, 100)
	}
	return _ddaeb
}

func _gacff(_ccdee *_df.PdfObjectDictionary) (*PdfShadingType4, error) {
	_fbgcfe := PdfShadingType4{}
	_ddbbb := _ccdee.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _ddbbb == nil {
		_bcd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_fffa, _degb := _ddbbb.(*_df.PdfObjectInteger)
	if !_degb {
		_bcd.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _ddbbb)
		return nil, _df.ErrTypeError
	}
	_fbgcfe.BitsPerCoordinate = _fffa
	_ddbbb = _ccdee.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _ddbbb == nil {
		_bcd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_fffa, _degb = _ddbbb.(*_df.PdfObjectInteger)
	if !_degb {
		_bcd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _ddbbb)
		return nil, _df.ErrTypeError
	}
	_fbgcfe.BitsPerComponent = _fffa
	_ddbbb = _ccdee.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _ddbbb == nil {
		_bcd.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_fffa, _degb = _ddbbb.(*_df.PdfObjectInteger)
	if !_degb {
		_bcd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _ddbbb)
		return nil, _df.ErrTypeError
	}
	_fbgcfe.BitsPerComponent = _fffa
	_ddbbb = _ccdee.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _ddbbb == nil {
		_bcd.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_afag, _degb := _ddbbb.(*_df.PdfObjectArray)
	if !_degb {
		_bcd.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _ddbbb)
		return nil, _df.ErrTypeError
	}
	_fbgcfe.Decode = _afag
	_ddbbb = _ccdee.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _ddbbb == nil {
		_bcd.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_fbgcfe.Function = []PdfFunction{}
	if _egbea, _eead := _ddbbb.(*_df.PdfObjectArray); _eead {
		for _, _feeda := range _egbea.Elements() {
			_adbe, _daegg := _ddaac(_feeda)
			if _daegg != nil {
				_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _daegg)
				return nil, _daegg
			}
			_fbgcfe.Function = append(_fbgcfe.Function, _adbe)
		}
	} else {
		_gbfgf, _gfgbge := _ddaac(_ddbbb)
		if _gfgbge != nil {
			_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _gfgbge)
			return nil, _gfgbge
		}
		_fbgcfe.Function = append(_fbgcfe.Function, _gbfgf)
	}
	return &_fbgcfe, nil
}

// SetFillImage attach a model.Image to push button.
func (_ccecf *PdfFieldButton) SetFillImage(image *Image) {
	if _ccecf.IsPush() {
		_ccecf._addf = image
	}
}

// ParsePdfObject parses input pdf object into given output intent.
func (_eegcd *PdfOutputIntent) ParsePdfObject(object _df.PdfObject) error {
	_bbecd, _bdcacb := _df.GetDict(object)
	if !_bdcacb {
		_bcd.Log.Error("\u0055\u006e\u006bno\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020%\u0054 \u0066o\u0072 \u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0069\u006e\u0074\u0065\u006e\u0074", object)
		return _deb.New("\u0075\u006e\u006b\u006e\u006fw\u006e\u0020\u0070\u0064\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0066\u006f\u0072\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0069\u006e\u0074\u0065\u006e\u0074")
	}
	_eegcd._eeff = _bbecd
	_eegcd.Type, _ = _bbecd.GetString("\u0054\u0079\u0070\u0065")
	_bggd, _bdcacb := _bbecd.GetString("\u0053")
	if _bdcacb {
		switch _bggd {
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411":
			_eegcd.S = PdfOutputIntentTypeA1
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00412":
			_eegcd.S = PdfOutputIntentTypeA2
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00413":
			_eegcd.S = PdfOutputIntentTypeA3
		case "\u0047T\u0053\u005f\u0050\u0044\u0046\u00414":
			_eegcd.S = PdfOutputIntentTypeA4
		case "\u0047\u0054\u0053\u005f\u0050\u0044\u0046\u0058":
			_eegcd.S = PdfOutputIntentTypeX
		}
	}
	_eegcd.OutputCondition, _ = _bbecd.GetString("\u004fu\u0074p\u0075\u0074\u0043\u006f\u006e\u0064\u0069\u0074\u0069\u006f\u006e")
	_eegcd.OutputConditionIdentifier, _ = _bbecd.GetString("\u004fu\u0074\u0070\u0075\u0074C\u006f\u006e\u0064\u0069\u0074i\u006fn\u0049d\u0065\u006e\u0074\u0069\u0066\u0069\u0065r")
	_eegcd.RegistryName, _ = _bbecd.GetString("\u0052\u0065\u0067i\u0073\u0074\u0072\u0079\u004e\u0061\u006d\u0065")
	_eegcd.Info, _ = _bbecd.GetString("\u0049\u006e\u0066\u006f")
	if _acaef, _ecdaa := _df.GetStream(_bbecd.Get("\u0044\u0065\u0073\u0074\u004f\u0075\u0074\u0070\u0075\u0074\u0050\u0072o\u0066\u0069\u006c\u0065")); _ecdaa {
		_eegcd.ColorComponents, _ = _df.GetIntVal(_acaef.Get("\u004e"))
		_aaad, _cbbc := _df.DecodeStream(_acaef)
		if _cbbc != nil {
			return _cbbc
		}
		_eegcd.DestOutputProfile = _aaad
	}
	return nil
}

// AllFields returns a flattened list of all fields in the form.
func (_fcfgd *PdfAcroForm) AllFields() []*PdfField {
	if _fcfgd == nil {
		return nil
	}
	var _fabaa []*PdfField
	if _fcfgd.Fields != nil {
		for _, _eabg := range *_fcfgd.Fields {
			_fabaa = append(_fabaa, _dcdg(_eabg)...)
		}
	}
	return _fabaa
}

// GetNamedDestinations returns the Dests entry in the PDF catalog.
// See section 12.3.2.3 "Named Destinations" (p. 367 PDF32000_2008).
func (_bfgc *PdfReader) GetNamedDestinations() (_df.PdfObject, error) {
	_bebb := _df.ResolveReference(_bfgc._afbaf.Get("\u0044\u0065\u0073t\u0073"))
	if _bebb == nil {
		return nil, nil
	}
	if !_bfgc._edbbdf {
		_abecg := _bfgc.traverseObjectData(_bebb)
		if _abecg != nil {
			return nil, _abecg
		}
	}
	return _bebb, nil
}

// ToGoImage converts the unidoc Image to a golang Image structure.
func (_ddfe *Image) ToGoImage() (_cg.Image, error) {
	_bcd.Log.Trace("\u0043\u006f\u006e\u0076er\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0067\u006f\u0020\u0069\u006d\u0061g\u0065")
	_dbegf, _bgbbd := _bge.NewImage(int(_ddfe.Width), int(_ddfe.Height), int(_ddfe.BitsPerComponent), _ddfe.ColorComponents, _ddfe.Data, _ddfe._gebab, _ddfe._bebgb)
	if _bgbbd != nil {
		return nil, _bgbbd
	}
	return _dbegf, nil
}

// ToPdfObject implements interface PdfModel.
func (_fdd *PdfActionMovie) ToPdfObject() _df.PdfObject {
	_fdd.PdfAction.ToPdfObject()
	_bfg := _fdd._gcf
	_bec := _bfg.PdfObject.(*_df.PdfObjectDictionary)
	_bec.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeMovie)))
	_bec.SetIfNotNil("\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e", _fdd.Annotation)
	_bec.SetIfNotNil("\u0054", _fdd.T)
	_bec.SetIfNotNil("\u004fp\u0065\u0072\u0061\u0074\u0069\u006fn", _fdd.Operation)
	return _bfg
}

// ToUnicode returns the name of the font's "ToUnicode" field if there is one, or "" if there isn't.
func (_eccg *PdfFont) ToUnicode() string {
	if _eccg.baseFields()._afcbd == nil {
		return ""
	}
	return _eccg.baseFields()._afcbd.Name()
}

// Items returns all children outline items.
func (_gfdcb *OutlineItem) Items() []*OutlineItem { return _gfdcb.Entries }

// NewViewerPreferences returns a new ViewerPreferences object with
// default empty values.
func NewViewerPreferences() *ViewerPreferences { return &ViewerPreferences{} }

// SetStructParentsKey sets the StructParents key.
func (_fgdgf *PdfPage) SetStructParentsKey(key int) {
	if key == -1 {
		_fgdgf.StructParents = nil
	} else {
		_fgdgf.StructParents = _df.MakeInteger(int64(key))
	}
}

// ToPdfObject implements interface PdfModel.
func (_bdadc *Permissions) ToPdfObject() _df.PdfObject { return _bdadc._abddf }

// SetPdfCreationDate sets the CreationDate attribute of the output PDF.
func SetPdfCreationDate(creationDate _fa.Time) {
	_gcdec.Lock()
	defer _gcdec.Unlock()
	_eebfd = creationDate
}

// GetContentStream returns the XObject Form's content stream.
func (_ebdcf *XObjectForm) GetContentStream() ([]byte, error) {
	_fdgae, _geagb := _df.DecodeStream(_ebdcf._bbfeg)
	if _geagb != nil {
		return nil, _geagb
	}
	return _fdgae, nil
}

// NewPdfColorDeviceCMYK returns a new CMYK32 color.
func NewPdfColorDeviceCMYK(c, m, y, k float64) *PdfColorDeviceCMYK {
	_deagg := PdfColorDeviceCMYK{c, m, y, k}
	return &_deagg
}

func _bddgg(_dgbac *_df.PdfObjectDictionary, _bacec *fontCommon) (*pdfCIDFontType0, error) {
	if _bacec._fgfae != "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030" {
		_bcd.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0046\u006fn\u0074\u0020\u0053u\u0062\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020CI\u0044\u0046\u006fn\u0074\u0054y\u0070\u0065\u0030\u002e\u0020\u0066o\u006e\u0074=\u0025\u0073", _bacec)
		return nil, _df.ErrRangeError
	}
	_gabae := _ceeg(_bacec)
	_efda, _aeabf := _df.GetDict(_dgbac.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
	if !_aeabf {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043I\u0044\u0053\u0079st\u0065\u006d\u0049\u006e\u0066\u006f \u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _bacec)
		return nil, ErrRequiredAttributeMissing
	}
	_gabae.CIDSystemInfo = _efda
	_gabae.DW = _dgbac.Get("\u0044\u0057")
	_gabae.W = _dgbac.Get("\u0057")
	_gabae.DW2 = _dgbac.Get("\u0044\u0057\u0032")
	_gabae.W2 = _dgbac.Get("\u0057\u0032")
	_gabae._ggbda = 1000.0
	if _bfecc, _bgef := _df.GetNumberAsFloat(_gabae.DW); _bgef == nil {
		_gabae._ggbda = _bfecc
	}
	_bebd, _acff := _cadgb(_gabae.W)
	if _acff != nil {
		return nil, _acff
	}
	if _bebd == nil {
		_bebd = map[_abg.CharCode]float64{}
	}
	_gabae._cbee = _bebd
	return _gabae, nil
}

// SetPdfTitle sets the Title attribute of the output PDF.
func SetPdfTitle(title string) { _gcdec.Lock(); defer _gcdec.Unlock(); _eabgb = title }

// SetRotation sets the rotation of all pages added to writer. The rotation is
// specified in degrees and must be a multiple of 90.
// The Rotate field of individual pages has priority over the global rotation.
func (_aeebbe *PdfWriter) SetRotation(rotate int64) error {
	_bcfcd, _dbedf := _df.GetDict(_aeebbe._ggdac)
	if !_dbedf {
		return ErrTypeCheck
	}
	_bcfcd.Set("\u0052\u006f\u0074\u0061\u0074\u0065", _df.MakeInteger(rotate))
	return nil
}

// ImageToRGB returns an error since an image cannot be defined in a pattern colorspace.
func (_ffecb *PdfColorspaceSpecialPattern) ImageToRGB(img Image) (Image, error) {
	_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0049\u006d\u0061\u0067\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066i\u0065\u0064\u0020\u0069\u006e\u0020\u0050\u0061\u0074\u0074\u0065\u0072n \u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	return img, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0066\u006f\u0072\u0020\u0069m\u0061\u0067\u0065\u0020\u0028p\u0061\u0074t\u0065\u0072\u006e\u0029")
}

// String returns a string representation of the field.
func (_deegg *PdfField) String() string {
	if _dbcebd, _agbc := _deegg.ToPdfObject().(*_df.PdfIndirectObject); _agbc {
		return _c.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _deegg._efcbg, _dbcebd.PdfObject.String())
	}
	return ""
}

// PdfColorspaceDeviceCMYK represents a CMYK32 colorspace.
type PdfColorspaceDeviceCMYK struct{}

// GetNameDictionary returns the Names entry in the PDF catalog.
// See section 7.7.4 "Name Dictionary" (p. 80 PDF32000_2008).
func (_gdgde *PdfReader) GetNameDictionary() (_df.PdfObject, error) {
	_ddeafc := _df.ResolveReference(_gdgde._afbaf.Get("\u004e\u0061\u006de\u0073"))
	if _ddeafc == nil {
		return nil, nil
	}
	if !_gdgde._edbbdf {
		_gefag := _gdgde.traverseObjectData(_ddeafc)
		if _gefag != nil {
			return nil, _gefag
		}
	}
	return _ddeafc, nil
}

// ToPdfObject returns a stream object.
func (_ffdgg *XObjectForm) ToPdfObject() _df.PdfObject {
	_fccba := _ffdgg._bbfeg
	_fbbde := _fccba.PdfObjectDictionary
	if _ffdgg.Filter != nil {
		_fbbde = _ffdgg.Filter.MakeStreamDict()
		_fccba.PdfObjectDictionary = _fbbde
	}
	_fbbde.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0058O\u0062\u006a\u0065\u0063\u0074"))
	_fbbde.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0046\u006f\u0072\u006d"))
	_fbbde.SetIfNotNil("\u0046\u006f\u0072\u006d\u0054\u0079\u0070\u0065", _ffdgg.FormType)
	_fbbde.SetIfNotNil("\u0042\u0042\u006f\u0078", _ffdgg.BBox)
	_fbbde.SetIfNotNil("\u004d\u0061\u0074\u0072\u0069\u0078", _ffdgg.Matrix)
	if _ffdgg.Resources != nil {
		_fbbde.SetIfNotNil("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _ffdgg.Resources.ToPdfObject())
	}
	_fbbde.SetIfNotNil("\u0047\u0072\u006fu\u0070", _ffdgg.Group)
	_fbbde.SetIfNotNil("\u0052\u0065\u0066", _ffdgg.Ref)
	_fbbde.SetIfNotNil("\u004d\u0065\u0074\u0061\u0044\u0061\u0074\u0061", _ffdgg.MetaData)
	_fbbde.SetIfNotNil("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o", _ffdgg.PieceInfo)
	_fbbde.SetIfNotNil("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064", _ffdgg.LastModified)
	_fbbde.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _ffdgg.StructParent)
	_fbbde.SetIfNotNil("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _ffdgg.StructParents)
	_fbbde.SetIfNotNil("\u004f\u0050\u0049", _ffdgg.OPI)
	_fbbde.SetIfNotNil("\u004f\u0043", _ffdgg.OC)
	_fbbde.SetIfNotNil("\u004e\u0061\u006d\u0065", _ffdgg.Name)
	_fbbde.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _df.MakeInteger(int64(len(_ffdgg.Stream))))
	_fccba.Stream = _ffdgg.Stream
	return _fccba
}

// ToPdfObject returns a PDF object representation of the outline destination.
func (_edfbb OutlineDest) ToPdfObject() _df.PdfObject {
	if (_edfbb.PageObj == nil && _edfbb.Page < 0) || _edfbb.Mode == "" {
		return _df.MakeNull()
	}
	_adcfg := _df.MakeArray()
	if _edfbb.PageObj != nil {
		_adcfg.Append(_edfbb.PageObj)
	} else {
		_adcfg.Append(_df.MakeInteger(_edfbb.Page))
	}
	_adcfg.Append(_df.MakeName(_edfbb.Mode))
	switch _edfbb.Mode {
	case "\u0046\u0069\u0074", "\u0046\u0069\u0074\u0042":
	case "\u0046\u0069\u0074\u0048", "\u0046\u0069\u0074B\u0048":
		_adcfg.Append(_df.MakeFloat(_edfbb.Y))
	case "\u0046\u0069\u0074\u0056", "\u0046\u0069\u0074B\u0056":
		_adcfg.Append(_df.MakeFloat(_edfbb.X))
	case "\u0058\u0059\u005a":
		_adcfg.Append(_df.MakeFloat(_edfbb.X))
		_adcfg.Append(_df.MakeFloat(_edfbb.Y))
		_adcfg.Append(_df.MakeFloat(_edfbb.Zoom))
	default:
		_adcfg.Set(1, _df.MakeName("\u0046\u0069\u0074"))
	}
	return _adcfg
}

// ToPdfObject converts the font to a PDF representation.
func (_bbcd *pdfFontType3) ToPdfObject() _df.PdfObject {
	if _bbcd._ecfc == nil {
		_bbcd._ecfc = &_df.PdfIndirectObject{}
	}
	_egbcc := _bbcd.baseFields().asPdfObjectDictionary("\u0054\u0079\u0070e\u0033")
	_bbcd._ecfc.PdfObject = _egbcc
	if _bbcd.FirstChar != nil {
		_egbcc.Set("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r", _bbcd.FirstChar)
	}
	if _bbcd.LastChar != nil {
		_egbcc.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", _bbcd.LastChar)
	}
	if _bbcd.Widths != nil {
		_egbcc.Set("\u0057\u0069\u0064\u0074\u0068\u0073", _bbcd.Widths)
	}
	if _bbcd.Encoding != nil {
		_egbcc.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _bbcd.Encoding)
	} else if _bbcd._ceed != nil {
		_gdgag := _bbcd._ceed.ToPdfObject()
		if _gdgag != nil {
			_egbcc.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _gdgag)
		}
	}
	if _bbcd.FontBBox != nil {
		_egbcc.Set("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078", _bbcd.FontBBox)
	}
	if _bbcd.FontMatrix != nil {
		_egbcc.Set("\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0069\u0072\u0078", _bbcd.FontMatrix)
	}
	if _bbcd.CharProcs != nil {
		_egbcc.Set("\u0043h\u0061\u0072\u0050\u0072\u006f\u0063s", _bbcd.CharProcs)
	}
	if _bbcd.Resources != nil {
		_egbcc.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _bbcd.Resources)
	}
	return _bbcd._ecfc
}

// NewPdfColorspaceDeviceCMYK returns a new CMYK32 colorspace object.
func NewPdfColorspaceDeviceCMYK() *PdfColorspaceDeviceCMYK { return &PdfColorspaceDeviceCMYK{} }

// PdfColorPatternType3 represents a color shading pattern type 3 (Radial).
type PdfColorPatternType3 struct {
	Color       PdfColor
	PatternName _df.PdfObjectName
}

// SubsetRegistered subsets the font to only the glyphs that have been registered by the encoder.
//
// NOTE: This only works on fonts that support subsetting. For unsupported fonts this is a no-op, although a debug
// message is emitted.  Currently supported fonts are embedded Truetype CID fonts (type 0).
//
// NOTE: Make sure to call this soon before writing (once all needed runes have been registered).
// If using package creator, use its EnableFontSubsetting method instead.
func (_adfd *PdfFont) SubsetRegistered() error {
	switch _fcffc := _adfd._eaeg.(type) {
	case *pdfFontType0:
		_bcfdc := _fcffc.subsetRegistered()
		if _bcfdc != nil {
			_bcd.Log.Debug("\u0053\u0075b\u0073\u0065\u0074 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076", _bcfdc)
			return _bcfdc
		}
		if _fcffc._ddfda != nil {
			if _fcffc._gdbg != nil {
				_fcffc._gdbg.ToPdfObject()
			}
			_fcffc.ToPdfObject()
		}
	default:
		_bcd.Log.Debug("F\u006f\u006e\u0074\u0020\u0025\u0054 \u0064\u006f\u0065\u0073\u0020\u006eo\u0074\u0020\u0073\u0075\u0070\u0070\u006fr\u0074\u0020\u0073\u0075\u0062\u0073\u0065\u0074\u0074\u0069n\u0067", _fcffc)
	}
	return nil
}

// FontDescriptor returns font's PdfFontDescriptor. This may be a builtin descriptor for standard 14
// fonts but must be an explicit descriptor for other fonts.
func (_gafc *PdfFont) FontDescriptor() *PdfFontDescriptor {
	if _gafc.baseFields()._agggb != nil {
		return _gafc.baseFields()._agggb
	}
	if _efcbb := _gafc._eaeg.getFontDescriptor(); _efcbb != nil {
		return _efcbb
	}
	_bcd.Log.Error("\u0041\u006cl \u0066\u006f\u006et\u0073\u0020\u0068\u0061ve \u0061 D\u0065\u0073\u0063\u0072\u0069\u0070\u0074or\u002e\u0020\u0066\u006f\u006e\u0074\u003d%\u0073", _gafc)
	return nil
}

// GetAnnotations returns the list of page annotations for `page`. If not loaded attempts to load the
// annotations, otherwise returns the loaded list.
func (_baegd *PdfPage) GetAnnotations() ([]*PdfAnnotation, error) {
	if _baegd._adef != nil {
		return _baegd._adef, nil
	}
	if _baegd.Annots == nil {
		_baegd._adef = []*PdfAnnotation{}
		return nil, nil
	}
	if _baegd._cgacg == nil {
		_baegd._adef = []*PdfAnnotation{}
		return nil, nil
	}
	_egbfge, _ebdg := _baegd._cgacg.loadAnnotations(_baegd.Annots)
	if _ebdg != nil {
		return nil, _ebdg
	}
	if _egbfge == nil {
		_baegd._adef = []*PdfAnnotation{}
	}
	_baegd._adef = _egbfge
	return _baegd._adef, nil
}

// C returns the value of the C component of the color.
func (_faagc *PdfColorCalRGB) C() float64 { return _faagc[2] }

// ToPdfObject implements interface PdfModel.
func (_baaeba *EmbeddedFile) ToPdfObject() _df.PdfObject {
	_abcf := _df.NewFlateEncoder()
	_fcaaa, _acgbf := _df.MakeStream(_baaeba.Content, _abcf)
	if _acgbf != nil {
		_bcd.Log.Debug("\u0046\u0061\u0069\u006c\u0065d\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020\u0065\u006db\u0065\u0064\u0064\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _acgbf)
		return nil
	}
	_eefe := _fcaaa.PdfObjectDictionary
	_eefe.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0045\u006d\u0062e\u0064\u0064\u0065\u0064\u0046\u0069\u006c\u0065"))
	_eefe.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeEncodedString("\u0074\u0065\u0078\u0074\u002f\u0070\u006c\u0061\u0069\u006e", true))
	_ebabde := _df.MakeDict()
	_ebabde.Set("\u0043\u0068\u0065\u0063\u006b\u0053\u0075\u006d", _df.MakeString(_baaeba.Hash[:]))
	_ebabde.Set("\u0053\u0069\u007a\u0065", _df.MakeInteger(int64(len(_baaeba.Content))))
	_cedb := _baaeba.CreationTime
	if _cedb.IsZero() {
		_cedb = _fa.Now()
	}
	_dbaf := _baaeba.ModTime
	if _dbaf.IsZero() {
		_dbaf = _cedb
	}
	_dcbf, _acgbf := NewPdfDateFromTime(_cedb)
	if _acgbf != nil {
		_bcd.Log.Debug("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074o\u0020\u0063\u0072ea\u0074\u0065\u0020\u0065\u006d\u0062e\u0064\u0064\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u0063\u0072\u0065\u0061\u0074i\u006f\u006e\u0020\u0064\u0061\u0074\u0065\u003a \u0025\u0076", _acgbf)
		return nil
	}
	_cabb, _acgbf := NewPdfDateFromTime(_dbaf)
	if _acgbf != nil {
		_bcd.Log.Debug("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074o\u0020\u0063\u0072ea\u0074\u0065\u0020\u0065\u006d\u0062e\u0064\u0064\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u0063\u0072\u0065\u0061\u0074i\u006f\u006e\u0020\u0064\u0061\u0074\u0065\u003a \u0025\u0076", _acgbf)
		return nil
	}
	_ebabde.Set("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _dcbf.ToPdfObject())
	_ebabde.Set("\u004do\u0064\u0044\u0061\u0074\u0065", _cabb.ToPdfObject())
	_eefe.Set("\u0050\u0061\u0072\u0061\u006d\u0073", _ebabde)
	_fafga := _df.MakeDict()
	_fafga.Set(*_df.MakeName("\u0046"), _fcaaa)
	return _fafga
}

// ToPdfObject implements interface PdfModel.
func (_fbda *PdfAnnotationPolygon) ToPdfObject() _df.PdfObject {
	_fbda.PdfAnnotation.ToPdfObject()
	_ecdb := _fbda._bfde
	_ggbb := _ecdb.PdfObject.(*_df.PdfObjectDictionary)
	_fbda.PdfAnnotationMarkup.appendToPdfDictionary(_ggbb)
	_ggbb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0050o\u006c\u0079\u0067\u006f\u006e"))
	_ggbb.SetIfNotNil("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073", _fbda.Vertices)
	_ggbb.SetIfNotNil("\u004c\u0045", _fbda.LE)
	_ggbb.SetIfNotNil("\u0042\u0053", _fbda.BS)
	_ggbb.SetIfNotNil("\u0049\u0043", _fbda.IC)
	_ggbb.SetIfNotNil("\u0042\u0045", _fbda.BE)
	_ggbb.SetIfNotNil("\u0049\u0054", _fbda.IT)
	_ggbb.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _fbda.Measure)
	return _ecdb
}

// NewPdfOutlineTree returns an initialized PdfOutline tree.
func NewPdfOutlineTree() *PdfOutline { _cbaf := NewPdfOutline(); _cbaf._dcgc = &_cbaf; return _cbaf }

func (_eecdd *PdfWriter) checkCrossReferenceStream() bool {
	_faea := _eecdd._aeffd.Major > 1 || (_eecdd._aeffd.Major == 1 && _eecdd._aeffd.Minor > 4)
	if _eecdd._ccbfe != nil {
		_faea = *_eecdd._ccbfe
	}
	return _faea
}

func _gcge(_fegeg *_df.PdfObjectDictionary) (*PdfShadingType7, error) {
	_fabc := PdfShadingType7{}
	_eaff := _fegeg.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _eaff == nil {
		_bcd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_bggcg, _acdaf := _eaff.(*_df.PdfObjectInteger)
	if !_acdaf {
		_bcd.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _eaff)
		return nil, _df.ErrTypeError
	}
	_fabc.BitsPerCoordinate = _bggcg
	_eaff = _fegeg.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _eaff == nil {
		_bcd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_bggcg, _acdaf = _eaff.(*_df.PdfObjectInteger)
	if !_acdaf {
		_bcd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _eaff)
		return nil, _df.ErrTypeError
	}
	_fabc.BitsPerComponent = _bggcg
	_eaff = _fegeg.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _eaff == nil {
		_bcd.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_bggcg, _acdaf = _eaff.(*_df.PdfObjectInteger)
	if !_acdaf {
		_bcd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _eaff)
		return nil, _df.ErrTypeError
	}
	_fabc.BitsPerComponent = _bggcg
	_eaff = _fegeg.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _eaff == nil {
		_bcd.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_egcd, _acdaf := _eaff.(*_df.PdfObjectArray)
	if !_acdaf {
		_bcd.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _eaff)
		return nil, _df.ErrTypeError
	}
	_fabc.Decode = _egcd
	if _deagb := _fegeg.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _deagb != nil {
		_fabc.Function = []PdfFunction{}
		if _ecdfa, _egeb := _deagb.(*_df.PdfObjectArray); _egeb {
			for _, _fcbaa := range _ecdfa.Elements() {
				_ebcbd, _dggaaa := _ddaac(_fcbaa)
				if _dggaaa != nil {
					_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _dggaaa)
					return nil, _dggaaa
				}
				_fabc.Function = append(_fabc.Function, _ebcbd)
			}
		} else {
			_efgdf, _ebagg := _ddaac(_deagb)
			if _ebagg != nil {
				_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _ebagg)
				return nil, _ebagg
			}
			_fabc.Function = append(_fabc.Function, _efgdf)
		}
	}
	return &_fabc, nil
}

func (_gbeec *pdfCIDFontType2) getFontDescriptor() *PdfFontDescriptor { return _gbeec._agggb }

var _ pdfFont = (*pdfCIDFontType0)(nil)

// NewPdfColorspaceICCBased returns a new ICCBased colorspace object.
func NewPdfColorspaceICCBased(N int) (*PdfColorspaceICCBased, error) {
	_efgd := &PdfColorspaceICCBased{}
	if N != 1 && N != 3 && N != 4 {
		return nil, _c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020\u0028\u0031/\u0033\u002f\u0034\u0029")
	}
	_efgd.N = N
	return _efgd, nil
}

// PdfColorDeviceGray represents a grayscale color value that shall be represented by a single number in the
// range 0.0 to 1.0 where 0.0 corresponds to black and 1.0 to white.
type PdfColorDeviceGray float64

func (_cfbg *PdfReader) newPdfAnnotationCaretFromDict(_dbdgc *_df.PdfObjectDictionary) (*PdfAnnotationCaret, error) {
	_fgbd := PdfAnnotationCaret{}
	_eegf, _bdc := _cfbg.newPdfAnnotationMarkupFromDict(_dbdgc)
	if _bdc != nil {
		return nil, _bdc
	}
	_fgbd.PdfAnnotationMarkup = _eegf
	_fgbd.RD = _dbdgc.Get("\u0052\u0044")
	_fgbd.Sy = _dbdgc.Get("\u0053\u0079")
	return &_fgbd, nil
}

// NewPdfAnnotationSound returns a new sound annotation.
func NewPdfAnnotationSound() *PdfAnnotationSound {
	_fbeb := NewPdfAnnotation()
	_age := &PdfAnnotationSound{}
	_age.PdfAnnotation = _fbeb
	_age.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_fbeb.SetContext(_age)
	return _age
}

// PdfField contains the common attributes of a form field. The context object contains the specific field data
// which can represent a button, text, choice or signature.
// The PdfField is typically not used directly, but is encapsulated by the more specific field types such as
// PdfFieldButton etc (i.e. the context attribute).
type PdfField struct {
	_efcbg       PdfModel
	_cdbc        *_df.PdfIndirectObject
	Parent       *PdfField
	Annotations  []*PdfAnnotationWidget
	Kids         []*PdfField
	FT           *_df.PdfObjectName
	T            *_df.PdfObjectString
	TU           *_df.PdfObjectString
	TM           *_df.PdfObjectString
	Ff           *_df.PdfObjectInteger
	V            _df.PdfObject
	DV           _df.PdfObject
	AA           _df.PdfObject
	VariableText *VariableText
}

// NewPdfReaderLazy creates a new PdfReader for `rs` in lazy-loading mode. The difference
// from NewPdfReader is that in lazy-loading mode, objects are only loaded into memory when needed
// rather than entire structure being loaded into memory on reader creation.
// Note that it may make sense to use the lazy-load reader when processing only parts of files,
// rather than loading entire file into memory. Example: splitting a few pages from a large PDF file.
func NewPdfReaderLazy(rs _bdd.ReadSeeker) (*PdfReader, error) {
	const _begd = "\u006d\u006f\u0064\u0065l:\u004e\u0065\u0077\u0050\u0064\u0066\u0052\u0065\u0061\u0064\u0065\u0072\u004c\u0061z\u0079"
	return _gafgf(rs, &ReaderOpts{LazyLoad: true}, false, _begd)
}

// NewPdfColorLab returns a new Lab color.
func NewPdfColorLab(l, a, b float64) *PdfColorLab { _gcgc := PdfColorLab{l, a, b}; return &_gcgc }

// ToPdfObject returns the PDF representation of the page resources.
func (_affgd *PdfPageResources) ToPdfObject() _df.PdfObject {
	_bacbe := _affgd._cecgg
	_bacbe.SetIfNotNil("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _affgd.ExtGState)
	if _affgd._eafae != nil {
		_affgd.ColorSpace = _affgd._eafae.ToPdfObject()
	}
	_bacbe.SetIfNotNil("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _affgd.ColorSpace)
	_bacbe.SetIfNotNil("\u0050a\u0074\u0074\u0065\u0072\u006e", _affgd.Pattern)
	_bacbe.SetIfNotNil("\u0053h\u0061\u0064\u0069\u006e\u0067", _affgd.Shading)
	_bacbe.SetIfNotNil("\u0058O\u0062\u006a\u0065\u0063\u0074", _affgd.XObject)
	_bacbe.SetIfNotNil("\u0046\u006f\u006e\u0074", _affgd.Font)
	_bacbe.SetIfNotNil("\u0050r\u006f\u0063\u0053\u0065\u0074", _affgd.ProcSet)
	_bacbe.SetIfNotNil("\u0050\u0072\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073", _affgd.Properties)
	return _bacbe
}

func (_gdfgf *PdfWriter) setDocInfo(_bfcab _df.PdfObject) {
	if _gdfgf.hasObject(_gdfgf._caefe) {
		delete(_gdfgf._aadfbg, _gdfgf._caefe)
		delete(_gdfgf._dfadb, _gdfgf._caefe)
		for _dddaa, _fdbcf := range _gdfgf._ceeac {
			if _fdbcf == _gdfgf._caefe {
				copy(_gdfgf._ceeac[_dddaa:], _gdfgf._ceeac[_dddaa+1:])
				_gdfgf._ceeac[len(_gdfgf._ceeac)-1] = nil
				_gdfgf._ceeac = _gdfgf._ceeac[:len(_gdfgf._ceeac)-1]
				break
			}
		}
	}
	_caefeb := _df.PdfIndirectObject{}
	_caefeb.PdfObject = _bfcab
	_gdfgf._caefe = &_caefeb
	_gdfgf.addObject(&_caefeb)
}

// GetFillImage get attached model.Image in push button.
func (_ggcf *PdfFieldButton) GetFillImage() *Image {
	if _ggcf.IsPush() {
		return _ggcf._addf
	}
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_gbcb *PdfAnnotationStrikeOut) ToPdfObject() _df.PdfObject {
	_gbcb.PdfAnnotation.ToPdfObject()
	_cgfa := _gbcb._bfde
	_cdbe := _cgfa.PdfObject.(*_df.PdfObjectDictionary)
	_gbcb.PdfAnnotationMarkup.appendToPdfDictionary(_cdbe)
	_cdbe.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0053t\u0072\u0069\u006b\u0065\u004f\u0075t"))
	_cdbe.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _gbcb.QuadPoints)
	return _cgfa
}

// AlphaMap performs mapping of alpha data for transformations. Allows custom filtering of alpha data etc.
func (_fecaf *Image) AlphaMap(mapFunc AlphaMapFunc) {
	for _bbbdg, _bfbc := range _fecaf._gebab {
		_fecaf._gebab[_bbbdg] = mapFunc(_bfbc)
	}
}

// ToPdfObject implements interface PdfModel.
func (_gaea *PdfAnnotationPopup) ToPdfObject() _df.PdfObject {
	_gaea.PdfAnnotation.ToPdfObject()
	_eaf := _gaea._bfde
	_aefca := _eaf.PdfObject.(*_df.PdfObjectDictionary)
	_aefca.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0050\u006f\u0070u\u0070"))
	_aefca.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _gaea.Parent)
	_aefca.SetIfNotNil("\u004f\u0070\u0065\u006e", _gaea.Open)
	return _eaf
}

// PdfAnnotationWatermark represents Watermark annotations.
// (Section 12.5.6.22).
type PdfAnnotationWatermark struct {
	*PdfAnnotation
	FixedPrint _df.PdfObject
}

// PdfColorspaceSpecialSeparation is a Separation colorspace.
// At the moment the colour space is set to a Separation space, the conforming reader shall determine whether the
// device has an available colorant (e.g. dye) corresponding to the name of the requested space. If so, the conforming
// reader shall ignore the alternateSpace and tintTransform parameters; subsequent painting operations within the
// space shall apply the designated colorant directly, according to the tint values supplied.
//
// Format: [/Separation name alternateSpace tintTransform]
type PdfColorspaceSpecialSeparation struct {
	ColorantName   *_df.PdfObjectName
	AlternateSpace PdfColorspace
	TintTransform  PdfFunction
	_afad          *_df.PdfIndirectObject
}

// GetContainingPdfObject returns the containing object for the PdfField, i.e. an indirect object
// containing the field dictionary.
func (_cgca *PdfField) GetContainingPdfObject() _df.PdfObject { return _cgca._cdbc }

func (_ffec *PdfColorspaceCalRGB) String() string { return "\u0043\u0061\u006c\u0052\u0047\u0042" }

func _ddaac(_cbage _df.PdfObject) (PdfFunction, error) {
	_cbage = _df.ResolveReference(_cbage)
	if _ffed, _adcfd := _cbage.(*_df.PdfObjectStream); _adcfd {
		_fbbcf := _ffed.PdfObjectDictionary
		_ccfb, _ffcff := _fbbcf.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_df.PdfObjectInteger)
		if !_ffcff {
			_bcd.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _deb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_ccfb == 0 {
			return _ecdad(_ffed)
		} else if *_ccfb == 4 {
			return _cffdd(_ffed)
		} else {
			return nil, _deb.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else if _fbgdd, _fefe := _cbage.(*_df.PdfIndirectObject); _fefe {
		_fdcd, _aggfd := _fbgdd.PdfObject.(*_df.PdfObjectDictionary)
		if !_aggfd {
			_bcd.Log.Error("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u0020\u0049\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006eg\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
			return nil, _deb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		_fedgg, _aggfd := _fdcd.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_df.PdfObjectInteger)
		if !_aggfd {
			_bcd.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _deb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_fedgg == 2 {
			return _ddeec(_fbgdd)
		} else if *_fedgg == 3 {
			return _deeac(_fbgdd)
		} else {
			return nil, _deb.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else if _ggcgg, _ccga := _cbage.(*_df.PdfObjectDictionary); _ccga {
		_gcfcf, _edfd := _ggcgg.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_df.PdfObjectInteger)
		if !_edfd {
			_bcd.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _deb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_gcfcf == 2 {
			return _ddeec(_ggcgg)
		} else if *_gcfcf == 3 {
			return _deeac(_ggcgg)
		} else {
			return nil, _deb.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else {
		_bcd.Log.Debug("\u0046u\u006e\u0063\u0074\u0069\u006f\u006e\u0020\u0054\u0079\u0070\u0065 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0023\u0076", _cbage)
		return nil, _deb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
}

// A returns the value of the A component of the color.
func (_bafc *PdfColorLab) A() float64 { return _bafc[1] }

// GetCatalogLanguage gets catalog Language object.
func (_cebbe *PdfReader) GetCatalogLanguage() (_df.PdfObject, bool) {
	if _cebbe._afbaf == nil {
		return nil, false
	}
	_bbcga := _cebbe._afbaf.Get("\u004c\u0061\u006e\u0067")
	return _bbcga, _bbcga != nil
}

// ToInteger convert to an integer format.
func (_dbbc *PdfColorCalGray) ToInteger(bits int) uint32 {
	_eddg := _faf.Pow(2, float64(bits)) - 1
	return uint32(_eddg * _dbbc.Val())
}

// PdfPageResourcesColorspaces contains the colorspace in the PdfPageResources.
// Needs to have matching name and colorspace map entry. The Names define the order.
type PdfPageResourcesColorspaces struct {
	Names       []string
	Colorspaces map[string]PdfColorspace
	_bcbab      *_df.PdfIndirectObject
}

// Encoder returns the font's text encoder.
func (_fggd pdfCIDFontType2) Encoder() _abg.TextEncoder { return _fggd._adfa }

// ToPdfObject implements interface PdfModel.
func (_bbff *PdfAnnotationPolyLine) ToPdfObject() _df.PdfObject {
	_bbff.PdfAnnotation.ToPdfObject()
	_cacc := _bbff._bfde
	_gefe := _cacc.PdfObject.(*_df.PdfObjectDictionary)
	_bbff.PdfAnnotationMarkup.appendToPdfDictionary(_gefe)
	_gefe.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0050\u006f\u006c\u0079\u004c\u0069\u006e\u0065"))
	_gefe.SetIfNotNil("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073", _bbff.Vertices)
	_gefe.SetIfNotNil("\u004c\u0045", _bbff.LE)
	_gefe.SetIfNotNil("\u0042\u0053", _bbff.BS)
	_gefe.SetIfNotNil("\u0049\u0043", _bbff.IC)
	_gefe.SetIfNotNil("\u0042\u0045", _bbff.BE)
	_gefe.SetIfNotNil("\u0049\u0054", _bbff.IT)
	_gefe.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _bbff.Measure)
	return _cacc
}

func _gfegf(_gfge, _eabe string) string {
	if _gc.Contains(_gfge, "\u002b") {
		_edab := _gc.Split(_gfge, "\u002b")
		if len(_edab) == 2 {
			_gfge = _edab[1]
		}
	}
	return _eabe + "\u002b" + _gfge
}

// IsDisplayDocTitle returns the value of the displayDocTitle flag.
func (_bbdbe *ViewerPreferences) IsDisplayDocTitle() bool {
	if _bbdbe._bfggg == nil {
		return false
	}
	return *_bbdbe._bfggg
}

func (_bbfd *PdfReader) newPdfAnnotationPolyLineFromDict(_gec *_df.PdfObjectDictionary) (*PdfAnnotationPolyLine, error) {
	_bbb := PdfAnnotationPolyLine{}
	_febb, _agb := _bbfd.newPdfAnnotationMarkupFromDict(_gec)
	if _agb != nil {
		return nil, _agb
	}
	_bbb.PdfAnnotationMarkup = _febb
	_bbb.Vertices = _gec.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073")
	_bbb.LE = _gec.Get("\u004c\u0045")
	_bbb.BS = _gec.Get("\u0042\u0053")
	_bbb.IC = _gec.Get("\u0049\u0043")
	_bbb.BE = _gec.Get("\u0042\u0045")
	_bbb.IT = _gec.Get("\u0049\u0054")
	_bbb.Measure = _gec.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	return &_bbb, nil
}

// SetCatalogMetadata sets the catalog metadata (XMP) stream object.
func (_gceea *PdfWriter) SetCatalogMetadata(meta _df.PdfObject) error {
	if meta == nil {
		_gceea._gdee.Remove("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061")
		return nil
	}
	_cddcea, _aegbg := _df.GetStream(meta)
	if !_aegbg {
		return _deb.New("\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006d\u0065\u0074\u0061\u0064a\u0074\u0061\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0073t\u0072\u0065\u0061\u006d")
	}
	_gceea.addObject(_cddcea)
	_gceea._gdee.Set("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _cddcea)
	return nil
}

// RemoveStructParentsKey removes the StructParents key.
func (_gagfd *PdfPage) RemoveStructParentsKey() { _gagfd.StructParents = nil }

// PdfFunctionType3 defines stitching of the subdomains of several 1-input functions to produce
// a single new 1-input function.
type PdfFunctionType3 struct {
	Domain    []float64
	Range     []float64
	Functions []PdfFunction
	Bounds    []float64
	Encode    []float64
	_ffeg     *_df.PdfIndirectObject
}

// DecodeArray returns the component range values for the Separation colorspace.
func (_bgcb *PdfColorspaceSpecialSeparation) DecodeArray() []float64 { return []float64{0, 1.0} }

func (_ecg *PdfReader) newPdfAnnotationUnderlineFromDict(_ecc *_df.PdfObjectDictionary) (*PdfAnnotationUnderline, error) {
	_fgbe := PdfAnnotationUnderline{}
	_feea, _def := _ecg.newPdfAnnotationMarkupFromDict(_ecc)
	if _def != nil {
		return nil, _def
	}
	_fgbe.PdfAnnotationMarkup = _feea
	_fgbe.QuadPoints = _ecc.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_fgbe, nil
}

// GetSubFilter returns SubFilter value or empty string.
func (_dbde *pdfSignDictionary) GetSubFilter() string {
	_efcbbd := _dbde.Get("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r")
	if _efcbbd == nil {
		return ""
	}
	if _aggaf, _abegge := _df.GetNameVal(_efcbbd); _abegge {
		return _aggaf
	}
	return ""
}

// ColorToRGB converts an Indexed color to an RGB color.
func (_fbec *PdfColorspaceSpecialIndexed) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _fbec.Base == nil {
		return nil, _deb.New("\u0069\u006e\u0064\u0065\u0078\u0065d\u0020\u0062\u0061\u0073\u0065\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064")
	}
	return _fbec.Base.ColorToRGB(color)
}

func (_bebc *PdfColorspaceLab) String() string { return "\u004c\u0061\u0062" }

// GetXHeight returns the XHeight of the font `descriptor`.
func (_ebba *PdfFontDescriptor) GetXHeight() (float64, error) {
	return _df.GetNumberAsFloat(_ebba.XHeight)
}

// GetContainingPdfObject implements interface PdfModel.
func (_defg *PdfFilespec) GetContainingPdfObject() _df.PdfObject { return _defg._gaafd }

// StandardValidator is the interface that is used for the PDF StandardImplementer validation for the PDF document.
// It is using a CompliancePdfReader which is expected to give more Metadata during reading process.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type StandardValidator interface {

	// ValidateStandard checks if the input reader
	ValidateStandard(_fcfdaf *CompliancePdfReader) error
}

// GetNumComponents returns the number of color components (3 for RGB).
func (_faaa *PdfColorDeviceRGB) GetNumComponents() int { return 3 }

// AddMCIDChild adds a child MCID object.
func (_fdaa *KDict) AddMCIDChild(mcid int) {
	_fdaa._dacfd = append(_fdaa._dacfd, &KValue{_dfca: &mcid})
}

// GetAction returns the PDF action for the annotation link.
func (_faa *PdfAnnotationLink) GetAction() (*PdfAction, error) {
	if _faa._aefc != nil {
		return _faa._aefc, nil
	}
	if _faa.A == nil {
		return nil, nil
	}
	if _faa._caae == nil {
		return nil, nil
	}
	_dee, _abgf := _faa._caae.loadAction(_faa.A)
	if _abgf != nil {
		return nil, _abgf
	}
	_faa._aefc = _dee
	return _faa._aefc, nil
}

// NewStandardPdfOutputIntent creates a new standard PdfOutputIntent.
func NewStandardPdfOutputIntent(outputCondition, outputConditionIdentifier, registryName string, destOutputProfile []byte, colorComponents int) *PdfOutputIntent {
	return &PdfOutputIntent{Type: "\u004f\u0075\u0074p\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074", OutputCondition: outputCondition, OutputConditionIdentifier: outputConditionIdentifier, RegistryName: registryName, DestOutputProfile: destOutputProfile, ColorComponents: colorComponents, _eeff: _df.MakeDict()}
}

// PdfBorderStyle represents a border style dictionary (12.5.4 Border Styles p. 394).
type PdfBorderStyle struct {
	W     *float64
	S     *BorderStyle
	D     *[]int
	_bbcf _df.PdfObject
}

func (_efbd fontCommon) isCIDFont() bool {
	if _efbd._fgfae == "" {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0069\u0073\u0043\u0049\u0044\u0046\u006f\u006e\u0074\u002e\u0020\u0063o\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _efbd)
	}
	_eddc := false
	switch _efbd._fgfae {
	case "\u0054\u0079\u0070e\u0030", "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030", "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032":
		_eddc = true
	}
	_bcd.Log.Trace("i\u0073\u0043\u0049\u0044\u0046\u006fn\u0074\u003a\u0020\u0069\u0073\u0043\u0049\u0044\u003d%\u0074\u0020\u0066o\u006et\u003d\u0025\u0073", _eddc, _efbd)
	return _eddc
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_ggggb pdfFontType0) GetRuneMetrics(r rune) (_da.CharMetrics, bool) {
	if _ggggb.DescendantFont == nil {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u002e\u0020\u0066\u006f\u006et=\u0025\u0073", _ggggb)
		return _da.CharMetrics{}, false
	}
	return _ggggb.DescendantFont.GetRuneMetrics(r)
}

func (_eedab *Image) samplesTrimPadding(_egbcg []uint32) []uint32 {
	_bcff := _eedab.ColorComponents * int(_eedab.Width) * int(_eedab.Height)
	if len(_egbcg) == _bcff {
		return _egbcg
	}
	_cefdb := make([]uint32, _bcff)
	_gbeca := int(_eedab.Width) * _eedab.ColorComponents
	var _befbe, _ebbba, _aagc, _bcfad int
	_geaec := _bge.BytesPerLine(int(_eedab.Width), int(_eedab.BitsPerComponent), _eedab.ColorComponents)
	for _befbe = 0; _befbe < int(_eedab.Height); _befbe++ {
		_ebbba = _befbe * int(_eedab.Width)
		_aagc = _befbe * _geaec
		for _bcfad = 0; _bcfad < _gbeca; _bcfad++ {
			_cefdb[_ebbba+_bcfad] = _egbcg[_aagc+_bcfad]
		}
	}
	return _cefdb
}

// GetMCID returns the MCID of the KValue.
func (_fbgfc *KValue) GetMCID() *int { return _fbgfc._dfca }

func _abec(_adcdf _df.PdfObject) (*PdfColorspaceDeviceNAttributes, error) {
	_ggae := &PdfColorspaceDeviceNAttributes{}
	var _fdff *_df.PdfObjectDictionary
	switch _eafg := _adcdf.(type) {
	case *_df.PdfIndirectObject:
		_ggae._addb = _eafg
		var _bcbg bool
		_fdff, _bcbg = _eafg.PdfObject.(*_df.PdfObjectDictionary)
		if !_bcbg {
			_bcd.Log.Error("\u0044\u0065\u0076\u0069c\u0065\u004e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065 \u0074\u0079\u0070\u0065\u0020\u0065\u0072r\u006f\u0072")
			return nil, _deb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
	case *_df.PdfObjectDictionary:
		_fdff = _eafg
	case *_df.PdfObjectReference:
		_gaca := _eafg.Resolve()
		return _abec(_gaca)
	default:
		_bcd.Log.Error("\u0044\u0065\u0076\u0069c\u0065\u004e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065 \u0074\u0079\u0070\u0065\u0020\u0065\u0072r\u006f\u0072")
		return nil, _deb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _gddce := _fdff.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"); _gddce != nil {
		_fgac, _cgadf := _df.TraceToDirectObject(_gddce).(*_df.PdfObjectName)
		if !_cgadf {
			_bcd.Log.Error("\u0044\u0065vi\u0063\u0065\u004e \u0061\u0074\u0074\u0072ibu\u0074e \u0053\u0075\u0062\u0074\u0079\u0070\u0065 t\u0079\u0070\u0065\u0020\u0065\u0072\u0072o\u0072")
			return nil, _deb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_ggae.Subtype = _fgac
	}
	if _gdfb := _fdff.Get("\u0043o\u006c\u006f\u0072\u0061\u006e\u0074s"); _gdfb != nil {
		_ggae.Colorants = _gdfb
	}
	if _fadde := _fdff.Get("\u0050r\u006f\u0063\u0065\u0073\u0073"); _fadde != nil {
		_ggae.Process = _fadde
	}
	if _bdca := _fdff.Get("M\u0069\u0078\u0069\u006e\u0067\u0048\u0069\u006e\u0074\u0073"); _bdca != nil {
		_ggae.MixingHints = _bdca
	}
	return _ggae, nil
}

var _ddgae = false

// ReplacePage replaces the original page to a new page.
func (_cdge *PdfAppender) ReplacePage(pageNum int, page *PdfPage) {
	_egcf := pageNum - 1
	for _cdbb := range _cdge._dgac {
		if _cdbb == _egcf {
			_ddfb := page.Duplicate()
			_dfdde(_ddfb)
			_cdge._dgac[_cdbb] = _ddfb
		}
	}
}

// GetRuneMetrics iterates through each font in the list of fonts the returns the fonts.CharMetrics from working font.
func (_fbge *MultipleFontEncoder) GetRuneMetrics(r rune) (_da.CharMetrics, bool) {
	_deefa := _fbge.CurrentFont
	_agdcg, _aggcg := _deefa.GetRuneMetrics(r)
	for _fbbfa := 1; _fbbfa < len(_fbge._fbeed) && _agdcg.Wx == 0; _fbbfa++ {
		_deefa = _fbge._fbeed[_fbbfa]
		_agdcg, _aggcg = _deefa.GetRuneMetrics(r)
	}
	return _agdcg, _aggcg
}

func _aedd(_degg StdFontName) (pdfFontSimple, error) {
	_cdgeb, _dgeb := _da.NewStdFontByName(_degg)
	if !_dgeb {
		return pdfFontSimple{}, ErrFontNotSupported
	}
	_cgafa := _acfc(_cdgeb)
	return _cgafa, nil
}

// FillWithAppearance populates `form` with values provided by `provider`.
// If not nil, `appGen` is used to generate appearance dictionaries for the
// field annotations, based on the specified settings. Otherwise, appearance
// generation is skipped.
// e.g.: appGen := annotator.FieldAppearance{OnlyIfMissing: true, RegenerateTextFields: true}
// NOTE: In next major version this functionality will be part of Fill. (v4)
func (_cabbc *PdfAcroForm) FillWithAppearance(provider FieldValueProvider, appGen FieldAppearanceGenerator) error {
	_gedee := _cabbc.fill(provider, appGen)
	if _gedee != nil {
		return _gedee
	}
	if _, _ggcg := provider.(FieldImageProvider); _ggcg {
		_gedee = _cabbc.fillImageWithAppearance(provider.(FieldImageProvider), appGen)
	}
	return _gedee
}

// IsHideWindowUI returns the value of the hideWindowUI flag.
func (_fcgab *ViewerPreferences) IsHideWindowUI() bool {
	if _fcgab._dbfebfg == nil {
		return false
	}
	return *_fcgab._dbfebfg
}

func (_dba *PdfReader) newPdfActionImportDataFromDict(_eeb *_df.PdfObjectDictionary) (*PdfActionImportData, error) {
	_ebfc, _fbf := _cadf(_eeb.Get("\u0046"))
	if _fbf != nil {
		return nil, _fbf
	}
	return &PdfActionImportData{F: _ebfc}, nil
}

func (_ggbf *PdfReader) newPdfAnnotationPopupFromDict(_dafa *_df.PdfObjectDictionary) (*PdfAnnotationPopup, error) {
	_ecb := PdfAnnotationPopup{}
	_ecb.Parent = _dafa.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	_ecb.Open = _dafa.Get("\u004f\u0070\u0065\u006e")
	return &_ecb, nil
}

// GetContainingPdfObject implements interface PdfModel.
func (_ba *PdfAction) GetContainingPdfObject() _df.PdfObject { return _ba._gcf }

// PdfAnnotationSquare represents Square annotations.
// (Section 12.5.6.8).
type PdfAnnotationSquare struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	BS _df.PdfObject
	IC _df.PdfObject
	BE _df.PdfObject
	RD _df.PdfObject
}

// NewGrayImageFromGoImage creates a new grayscale unidoc Image from a golang Image.
func (_bdgcf DefaultImageHandler) NewGrayImageFromGoImage(goimg _cg.Image) (*Image, error) {
	_bcba := goimg.Bounds()
	_ccdc := &Image{Width: int64(_bcba.Dx()), Height: int64(_bcba.Dy()), ColorComponents: 1, BitsPerComponent: 8}
	switch _dadbc := goimg.(type) {
	case *_cg.Gray:
		if len(_dadbc.Pix) != _bcba.Dx()*_bcba.Dy() {
			_cafee, _baeec := _bge.GrayConverter.Convert(goimg)
			if _baeec != nil {
				return nil, _baeec
			}
			_ccdc.Data = _cafee.Pix()
		} else {
			_ccdc.Data = _dadbc.Pix
		}
	case *_cg.Gray16:
		_ccdc.BitsPerComponent = 16
		if len(_dadbc.Pix) != _bcba.Dx()*_bcba.Dy()*2 {
			_ddeab, _gbeeca := _bge.Gray16Converter.Convert(goimg)
			if _gbeeca != nil {
				return nil, _gbeeca
			}
			_ccdc.Data = _ddeab.Pix()
		} else {
			_ccdc.Data = _dadbc.Pix
		}
	case _bge.Image:
		_cdae := _dadbc.Base()
		if _cdae.ColorComponents == 1 {
			_ccdc.BitsPerComponent = int64(_cdae.BitsPerComponent)
			_ccdc.Data = _cdae.Data
			return _ccdc, nil
		}
		_geag, _gccfc := _bge.GrayConverter.Convert(goimg)
		if _gccfc != nil {
			return nil, _gccfc
		}
		_ccdc.Data = _geag.Pix()
	default:
		_afee, _dgdb := _bge.GrayConverter.Convert(goimg)
		if _dgdb != nil {
			return nil, _dgdb
		}
		_ccdc.Data = _afee.Pix()
	}
	return _ccdc, nil
}

// SetFlag sets the flag for the field.
func (_dadb *PdfField) SetFlag(flag FieldFlag) { _dadb.Ff = _df.MakeInteger(int64(flag)) }

// Insert adds an outline item as a child of the current outline item,
// at the specified index.
func (_acbfef *OutlineItem) Insert(index uint, item *OutlineItem) {
	_cfbbd := uint(len(_acbfef.Entries))
	if index > _cfbbd {
		index = _cfbbd
	}
	_acbfef.Entries = append(_acbfef.Entries[:index], append([]*OutlineItem{item}, _acbfef.Entries[index:]...)...)
}

var (
	StructureTypeSpan               = "\u0053\u0070\u0061\u006e"
	StructureTypeQuote              = "\u0051\u0075\u006ft\u0065"
	StructureTypeNote               = "\u004e\u006f\u0074\u0065"
	StructureTypeReference          = "\u0052e\u0066\u0065\u0072\u0065\u006e\u0063e"
	StructureTypeBibliography       = "\u0042\u0069\u0062\u0045\u006e\u0074\u0072\u0079"
	StructureTypeCode               = "\u0043\u006f\u0064\u0065"
	StructureTypeLink               = "\u004c\u0069\u006e\u006b"
	StructureTypeAnnot              = "\u0041\u006e\u006eo\u0074"
	StructureTypeRuby               = "\u0052\u0075\u0062\u0079"
	StructureTypeWarichu            = "\u0057a\u0072\u0069\u0063\u0068\u0075"
	StructureTypeRubyBase           = "\u0052\u0042"
	StructureTypeRubyText           = "\u0052\u0054"
	StructureTypeRubyPunctuation    = "\u0052\u0050"
	StructureTypeWarichuText        = "\u0057\u0054"
	StructureTypeWarichuPunctuation = "\u0057\u0050"
	StructureTypeFigure             = "\u0046\u0069\u0067\u0075\u0072\u0065"
	StructureTypeFormula            = "\u0046o\u0072\u006d\u0075\u006c\u0061"
	StructureTypeForm               = "\u0046\u006f\u0072\u006d"
)

// ToPdfObject implements interface PdfModel.
func (_abb *PdfActionNamed) ToPdfObject() _df.PdfObject {
	_abb.PdfAction.ToPdfObject()
	_cec := _abb._gcf
	_gfe := _cec.PdfObject.(*_df.PdfObjectDictionary)
	_gfe.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeNamed)))
	_gfe.SetIfNotNil("\u004e", _abb.N)
	return _cec
}

// ToOutlineTree returns a low level PdfOutlineTreeNode object, based on
// the current instance.
func (_gacf *Outline) ToOutlineTree() *PdfOutlineTreeNode {
	return &_gacf.ToPdfOutline().PdfOutlineTreeNode
}

// ContentStreamWrapper wraps the Page's contentstream into q ... Q blocks.
type ContentStreamWrapper interface{ WrapContentStream(_daeaf *PdfPage) error }

// ImageToRGB converts an image with samples in Separation CS to an image with samples specified in
// DeviceRGB CS.
func (_ebad *PdfColorspaceSpecialSeparation) ImageToRGB(img Image) (Image, error) {
	_fggeb := _aff.NewReader(img.getBase())
	_acfb := _bge.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), _ebad.AlternateSpace.GetNumComponents(), nil, img._gebab, nil)
	_egga := _aff.NewWriter(_acfb)
	_afec := _faf.Pow(2, float64(img.BitsPerComponent)) - 1
	_bcd.Log.Trace("\u0053\u0065\u0070a\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0073\u0070\u0061\u0063\u0065\u0020\u002d\u003e\u0020\u0054\u006f\u0052\u0047\u0042\u0020\u0063o\u006e\u0076\u0065\u0072\u0073\u0069\u006f\u006e")
	_bcd.Log.Trace("\u0054i\u006et\u0054\u0072\u0061\u006e\u0073f\u006f\u0072m\u003a\u0020\u0025\u002b\u0076", _ebad.TintTransform)
	_gcbf := _ebad.AlternateSpace.DecodeArray()
	var (
		_bdfc uint32
		_gbdc error
	)
	for {
		_bdfc, _gbdc = _fggeb.ReadSample()
		if _gbdc == _bdd.EOF {
			break
		}
		if _gbdc != nil {
			return img, _gbdc
		}
		_gdbbb := float64(_bdfc) / _afec
		_gcde, _afaac := _ebad.TintTransform.Evaluate([]float64{_gdbbb})
		if _afaac != nil {
			return img, _afaac
		}
		for _accg, _gfcf := range _gcde {
			_cebbd := _bge.LinearInterpolate(_gfcf, _gcbf[_accg*2], _gcbf[_accg*2+1], 0, 1)
			if _afaac = _egga.WriteSample(uint32(_cebbd * _afec)); _afaac != nil {
				return img, _afaac
			}
		}
	}
	return _ebad.AlternateSpace.ImageToRGB(_agbg(&_acfb))
}

// DecodeArray returns the range of color component values in CalRGB colorspace.
func (_bfdg *PdfColorspaceCalRGB) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}

// ToPdfObject converts the pdfCIDFontType2 to a PDF representation.
func (_fdcgf *pdfCIDFontType2) ToPdfObject() _df.PdfObject {
	if _fdcgf._agee == nil {
		_fdcgf._agee = &_df.PdfIndirectObject{}
	}
	_defe := _fdcgf.baseFields().asPdfObjectDictionary("\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032")
	_fdcgf._agee.PdfObject = _defe
	if _fdcgf.CIDSystemInfo != nil {
		_defe.Set("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f", _fdcgf.CIDSystemInfo)
	}
	if _fdcgf.DW != nil {
		_defe.Set("\u0044\u0057", _fdcgf.DW)
	}
	if _fdcgf.DW2 != nil {
		_defe.Set("\u0044\u0057\u0032", _fdcgf.DW2)
	}
	if _fdcgf.W != nil {
		_defe.Set("\u0057", _fdcgf.W)
	}
	if _fdcgf.W2 != nil {
		_defe.Set("\u0057\u0032", _fdcgf.W2)
	}
	if _fdcgf.CIDToGIDMap != nil {
		_defe.Set("C\u0049\u0044\u0054\u006f\u0047\u0049\u0044\u004d\u0061\u0070", _fdcgf.CIDToGIDMap)
	}
	return _fdcgf._agee
}

func (_eebag *PdfWriter) updateObjectNumbers() {
	_cegfg := _eebag.ObjNumOffset
	_acgaa := 0
	for _, _bdcda := range _eebag._ceeac {
		_ccgd := int64(_acgaa + 1 + _cegfg)
		_gabc := true
		if _eebag._gebfg {
			if _eadca, _bebdd := _eebag._gbga[_bdcda]; _bebdd {
				_ccgd = _eadca
				_gabc = false
			}
		}
		switch _agcca := _bdcda.(type) {
		case *_df.PdfIndirectObject:
			_agcca.ObjectNumber = _ccgd
			_agcca.GenerationNumber = 0
		case *_df.PdfObjectStream:
			_agcca.ObjectNumber = _ccgd
			_agcca.GenerationNumber = 0
		case *_df.PdfObjectStreams:
			_agcca.ObjectNumber = _ccgd
			_agcca.GenerationNumber = 0
		case *_df.PdfObjectReference:
			_agcca.ObjectNumber = _ccgd
			_agcca.GenerationNumber = 0
		case *_df.PdfObjectDictionary, *_df.PdfObjectString:
		default:
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u0020%\u0054\u0020\u002d\u0020\u0073\u006b\u0069p\u0070\u0069\u006e\u0067", _agcca)
			continue
		}
		if _gabc {
			_acgaa++
		}
	}
	_cgfeae := func(_bggdfg _df.PdfObject) int64 {
		switch _ggcggb := _bggdfg.(type) {
		case *_df.PdfIndirectObject:
			return _ggcggb.ObjectNumber
		case *_df.PdfObjectStream:
			return _ggcggb.ObjectNumber
		case *_df.PdfObjectStreams:
			return _ggcggb.ObjectNumber
		case *_df.PdfObjectReference:
			return _ggcggb.ObjectNumber
		}
		return 0
	}
	_f.SliceStable(_eebag._ceeac, func(_abdbfa, _gafba int) bool {
		return _cgfeae(_eebag._ceeac[_abdbfa]) < _cgfeae(_eebag._ceeac[_gafba])
	})
}

// ValidateSignatures validates digital signatures in the document.
func (_cefaa *PdfReader) ValidateSignatures(handlers []SignatureHandler) ([]SignatureValidationResult, error) {
	if _cefaa.AcroForm == nil {
		return nil, nil
	}
	if _cefaa.AcroForm.Fields == nil {
		return nil, nil
	}
	type sigFieldPair struct {
		_fbce  *PdfSignature
		_begef *PdfField
		_edegb SignatureHandler
	}
	var _ffdae []*sigFieldPair
	for _, _bfedf := range _cefaa.AcroForm.AllFields() {
		if _bfedf.V == nil {
			continue
		}
		if _eacg, _geaea := _df.GetDict(_bfedf.V); _geaea {
			if _dcfeg, _fafcfd := _df.GetNameVal(_eacg.Get("\u0054\u0079\u0070\u0065")); _fafcfd && (_dcfeg == "\u0053\u0069\u0067" || _dcfeg == "\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070") {
				_gdbcgb, _dfcb := _df.GetIndirect(_bfedf.V)
				if !_dfcb {
					_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0020\u0069s\u0020\u006e\u0069\u006c")
					return nil, ErrTypeCheck
				}
				_gcdbc, _aagee := _cefaa.newPdfSignatureFromIndirect(_gdbcgb)
				if _aagee != nil {
					return nil, _aagee
				}
				var _gbadc SignatureHandler
				for _, _afcdc := range handlers {
					if _afcdc.IsApplicable(_gcdbc) {
						_gbadc = _afcdc
						break
					}
				}
				_ffdae = append(_ffdae, &sigFieldPair{_fbce: _gcdbc, _begef: _bfedf, _edegb: _gbadc})
			}
		}
	}
	var _cfffa []SignatureValidationResult
	for _, _fecaa := range _ffdae {
		_cgafc := SignatureValidationResult{IsSigned: true, Fields: []*PdfField{_fecaa._begef}}
		if _fecaa._edegb == nil {
			_cgafc.Errors = append(_cgafc.Errors, "\u0068a\u006ed\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0073\u0065\u0074")
			_cfffa = append(_cfffa, _cgafc)
			continue
		}
		_aebddc, _ceaab := _fecaa._edegb.NewDigest(_fecaa._fbce)
		if _ceaab != nil {
			_cgafc.Errors = append(_cgafc.Errors, "\u0064\u0069\u0067e\u0073\u0074\u0020\u0065\u0072\u0072\u006f\u0072", _ceaab.Error())
			_cfffa = append(_cfffa, _cgafc)
			continue
		}
		_egdeb := _fecaa._fbce.ByteRange
		if _egdeb == nil {
			_cgafc.Errors = append(_cgafc.Errors, "\u0042\u0079\u0074\u0065\u0052\u0061\u006e\u0067\u0065\u0020\u006e\u006ft\u0020\u0073\u0065\u0074")
			_cfffa = append(_cfffa, _cgafc)
			continue
		}
		for _fdgfba := 0; _fdgfba < _egdeb.Len(); _fdgfba = _fdgfba + 2 {
			_adcc, _ := _df.GetNumberAsInt64(_egdeb.Get(_fdgfba))
			_fgggfd, _ := _df.GetIntVal(_egdeb.Get(_fdgfba + 1))
			if _, _gfdcbe := _cefaa._fbacd.Seek(_adcc, _bdd.SeekStart); _gfdcbe != nil {
				return nil, _gfdcbe
			}
			_daabf := make([]byte, _fgggfd)
			if _, _debac := _cefaa._fbacd.Read(_daabf); _debac != nil {
				return nil, _debac
			}
			_aebddc.Write(_daabf)
		}
		var _fcaed SignatureValidationResult
		if _dafffe, _ggcdg := _fecaa._edegb.(SignatureHandlerDocMDP); _ggcdg {
			_fcaed, _ceaab = _dafffe.ValidateWithOpts(_fecaa._fbce, _aebddc, SignatureHandlerDocMDPParams{Parser: _cefaa._gfdaag})
		} else {
			_fcaed, _ceaab = _fecaa._edegb.Validate(_fecaa._fbce, _aebddc)
		}
		if _ceaab != nil {
			_bcd.Log.Debug("E\u0052\u0052\u004f\u0052: \u0025v\u0020\u0028\u0025\u0054\u0029 \u002d\u0020\u0073\u006b\u0069\u0070", _ceaab, _fecaa._edegb)
			_fcaed.Errors = append(_fcaed.Errors, _ceaab.Error())
		}
		_fcaed.Name = _fecaa._fbce.Name.Decoded()
		_fcaed.Reason = _fecaa._fbce.Reason.Decoded()
		if _fecaa._fbce.M != nil {
			_agaf, _afbfe := NewPdfDate(_fecaa._fbce.M.String())
			if _afbfe != nil {
				_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _afbfe)
				_fcaed.Errors = append(_fcaed.Errors, _afbfe.Error())
				continue
			}
			_fcaed.Date = _agaf
		}
		_fcaed.ContactInfo = _fecaa._fbce.ContactInfo.Decoded()
		_fcaed.Location = _fecaa._fbce.Location.Decoded()
		_fcaed.Fields = _cgafc.Fields
		_cfffa = append(_cfffa, _fcaed)
	}
	return _cfffa, nil
}

// SetDSS sets the DSS dictionary (ETSI TS 102 778-4 V1.1.1) of the current
// document revision.
func (_gagb *PdfAppender) SetDSS(dss *DSS) {
	if dss != nil {
		_gagb.updateObjectsDeep(dss.ToPdfObject(), nil)
	}
	_gagb._cgebag = dss
}

func (_gag *PdfReader) newPdfAnnotationWatermarkFromDict(_bbd *_df.PdfObjectDictionary) (*PdfAnnotationWatermark, error) {
	_cdeg := PdfAnnotationWatermark{}
	_cdeg.FixedPrint = _bbd.Get("\u0046\u0069\u0078\u0065\u0064\u0050\u0072\u0069\u006e\u0074")
	return &_cdeg, nil
}

// L returns the value of the L component of the color.
func (_ddgfba *PdfColorLab) L() float64 { return _ddgfba[0] }

// Transform rectangle with the supplied matrix.
func (_cgbc *PdfRectangle) Transform(transformMatrix _dbc.Matrix) {
	_cgbc.Llx, _cgbc.Lly = transformMatrix.Transform(_cgbc.Llx, _cgbc.Lly)
	_cgbc.Urx, _cgbc.Ury = transformMatrix.Transform(_cgbc.Urx, _cgbc.Ury)
	_cgbc.Normalize()
}

// PdfActionHide represents a hide action.
type PdfActionHide struct {
	*PdfAction
	T _df.PdfObject
	H _df.PdfObject
}

// AddFont adds a font dictionary to the Font resources.
func (_cfdfg *PdfPage) AddFont(name _df.PdfObjectName, font _df.PdfObject) error {
	if _cfdfg.Resources == nil {
		_cfdfg.Resources = NewPdfPageResources()
	}
	if _cfdfg.Resources.Font == nil {
		_cfdfg.Resources.Font = _df.MakeDict()
	}
	_cgafdd, _bcgaf := _df.TraceToDirectObject(_cfdfg.Resources.Font).(*_df.PdfObjectDictionary)
	if !_bcgaf {
		_bcd.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u0066\u006f\u006et \u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a \u0025\u0076", _df.TraceToDirectObject(_cfdfg.Resources.Font))
		return _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_cgafdd.Set(name, font)
	return nil
}

// PdfTransformParamsDocMDP represents a transform parameters dictionary for the DocMDP method and is used to detect
// modifications relative to a signature field that is signed by the author of a document.
// (Section 12.8.2.2, Table 254 - Entries in the DocMDP transform parameters dictionary p. 471 in PDF32000_2008).
type PdfTransformParamsDocMDP struct {
	Type *_df.PdfObjectName
	P    *_df.PdfObjectInteger
	V    *_df.PdfObjectName
}

// GetDSS gets the DSS dictionary (ETSI TS 102 778-4 V1.1.1) of the current
// document revision.
func (_ccf *PdfAppender) GetDSS() (_bab *DSS) { return _ccf._cgebag }

// PdfAnnotationTrapNet represents TrapNet annotations.
// (Section 12.5.6.21).
type PdfAnnotationTrapNet struct{ *PdfAnnotation }

// GetNumComponents returns the number of color components (1 for CalGray).
func (_dgbbf *PdfColorCalGray) GetNumComponents() int { return 1 }

// GetChildren returns the children of the K dictionary object.
func (_aaece *KDict) GetChildren() []*KValue { return _aaece._dacfd }

// FieldFilterFunc represents a PDF field filtering function. If the function
// returns true, the PDF field is kept, otherwise it is discarded.
type FieldFilterFunc func(*PdfField) bool

// NewPdfActionImportData returns a new "import data" action.
func NewPdfActionImportData() *PdfActionImportData {
	_egf := NewPdfAction()
	_aad := &PdfActionImportData{}
	_aad.PdfAction = _egf
	_egf.SetContext(_aad)
	return _aad
}

func _cfaa(_fgfad rune) string {
	for _eadfg, _geaebb := range _e.Categories {
		if len(_eadfg) == 2 && _e.Is(_geaebb, _fgfad) {
			return _eadfg
		}
	}
	return "\u0043\u006e"
}

// ImageToGray returns a new grayscale image based on the passed in RGB image.
func (_abag *PdfColorspaceDeviceRGB) ImageToGray(img Image) (Image, error) {
	if img.ColorComponents != 3 {
		return img, _deb.New("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0061\u0020\u0044\u0065\u0076\u0069c\u0065\u0052\u0047\u0042")
	}
	_bdag, _dgceb := _bge.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._gebab, img._bebgb)
	if _dgceb != nil {
		return img, _dgceb
	}
	_fddbb, _dgceb := _bge.GrayConverter.Convert(_bdag)
	if _dgceb != nil {
		return img, _dgceb
	}
	return _agbg(_fddbb.Base()), nil
}

const (
	ActionTypeGoTo        PdfActionType = "\u0047\u006f\u0054\u006f"
	ActionTypeGoTo3DView  PdfActionType = "\u0047\u006f\u0054\u006f\u0033\u0044\u0056\u0069\u0065\u0077"
	ActionTypeGoToE       PdfActionType = "\u0047\u006f\u0054o\u0045"
	ActionTypeGoToR       PdfActionType = "\u0047\u006f\u0054o\u0052"
	ActionTypeHide        PdfActionType = "\u0048\u0069\u0064\u0065"
	ActionTypeImportData  PdfActionType = "\u0049\u006d\u0070\u006f\u0072\u0074\u0044\u0061\u0074\u0061"
	ActionTypeJavaScript  PdfActionType = "\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"
	ActionTypeLaunch      PdfActionType = "\u004c\u0061\u0075\u006e\u0063\u0068"
	ActionTypeMovie       PdfActionType = "\u004d\u006f\u0076i\u0065"
	ActionTypeNamed       PdfActionType = "\u004e\u0061\u006de\u0064"
	ActionTypeRendition   PdfActionType = "\u0052e\u006e\u0064\u0069\u0074\u0069\u006fn"
	ActionTypeResetForm   PdfActionType = "\u0052e\u0073\u0065\u0074\u0046\u006f\u0072m"
	ActionTypeSetOCGState PdfActionType = "S\u0065\u0074\u004f\u0043\u0047\u0053\u0074\u0061\u0074\u0065"
	ActionTypeSound       PdfActionType = "\u0053\u006f\u0075n\u0064"
	ActionTypeSubmitForm  PdfActionType = "\u0053\u0075\u0062\u006d\u0069\u0074\u0046\u006f\u0072\u006d"
	ActionTypeThread      PdfActionType = "\u0054\u0068\u0072\u0065\u0061\u0064"
	ActionTypeTrans       PdfActionType = "\u0054\u0072\u0061n\u0073"
	ActionTypeURI         PdfActionType = "\u0055\u0052\u0049"
)

func (_gdcda fontCommon) coreString() string {
	_fedf := ""
	if _gdcda._agggb != nil {
		_fedf = _gdcda._agggb.String()
	}
	return _c.Sprintf("\u0025#\u0071\u0020%\u0023\u0071\u0020%\u0071\u0020\u006f\u0062\u006a\u003d\u0025d\u0020\u0054\u006f\u0055\u006e\u0069c\u006f\u0064\u0065\u003d\u0025\u0074\u0020\u0066\u006c\u0061\u0067s\u003d\u0030\u0078\u0025\u0030\u0078\u0020\u0025\u0073", _gdcda._fgfae, _gdcda._gddcf, _gdcda._ggad, _gdcda._fceg, _gdcda._cdbgag != nil, _gdcda.fontFlags(), _fedf)
}

// ToPdfObject returns a PdfObject representation of PdfColorspaceDeviceNAttributes as a PdfObjectDictionary directly
// or indirectly within an indirect object container.
func (_aebf *PdfColorspaceDeviceNAttributes) ToPdfObject() _df.PdfObject {
	_gfggg := _df.MakeDict()
	if _aebf.Subtype != nil {
		_gfggg.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _aebf.Subtype)
	}
	_gfggg.SetIfNotNil("\u0043o\u006c\u006f\u0072\u0061\u006e\u0074s", _aebf.Colorants)
	_gfggg.SetIfNotNil("\u0050r\u006f\u0063\u0065\u0073\u0073", _aebf.Process)
	_gfggg.SetIfNotNil("M\u0069\u0078\u0069\u006e\u0067\u0048\u0069\u006e\u0074\u0073", _aebf.MixingHints)
	if _aebf._addb != nil {
		_aebf._addb.PdfObject = _gfggg
		return _aebf._addb
	}
	return _gfggg
}

// Clear clears flag fl from the flag and returns the resulting flag.
func (_baed FieldFlag) Clear(fl FieldFlag) FieldFlag { return FieldFlag(_baed.Mask() &^ fl.Mask()) }

// RemveTabOrder removes the tab order for the page.
func (_gbeaae *PdfPage) RemoveTabOrder() { _gbeaae.Tabs = nil }

// DecodeArray returns the component range values for the DeviceN colorspace.
// [0 1.0 0 1.0 ...] for each color component.
func (_eafd *PdfColorspaceDeviceN) DecodeArray() []float64 {
	var _dcae []float64
	for _agae := 0; _agae < _eafd.GetNumComponents(); _agae++ {
		_dcae = append(_dcae, 0.0, 1.0)
	}
	return _dcae
}

func (_cagfc fontCommon) fontFlags() int {
	if _cagfc._agggb == nil {
		return 0
	}
	return _cagfc._agggb._cadd
}

// ToPdfObject recursively builds the Outline tree PDF object.
func (_ddade *PdfOutline) ToPdfObject() _df.PdfObject {
	_fggca := _ddade._edacg
	_bgcgdd := _fggca.PdfObject.(*_df.PdfObjectDictionary)
	_bgcgdd.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073"))
	if _ddade.First != nil {
		_bgcgdd.Set("\u0046\u0069\u0072s\u0074", _ddade.First.ToPdfObject())
	}
	if _ddade.Last != nil {
		_bgcgdd.Set("\u004c\u0061\u0073\u0074", _ddade.Last.GetContext().GetContainingPdfObject())
	}
	if _ddade.Parent != nil {
		_bgcgdd.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _ddade.Parent.GetContext().GetContainingPdfObject())
	}
	if _ddade.Count != nil {
		_bgcgdd.Set("\u0043\u006f\u0075n\u0074", _df.MakeInteger(*_ddade.Count))
	}
	return _fggca
}

// ImageToRGB converts an Image in a given PdfColorspace to an RGB image.
func (_befd *PdfColorspaceDeviceN) ImageToRGB(img Image) (Image, error) {
	_feff := _aff.NewReader(img.getBase())
	_gfdb := _bge.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, nil, img._gebab, img._bebgb)
	_debg := _aff.NewWriter(_gfdb)
	_dbg := _faf.Pow(2, float64(img.BitsPerComponent)) - 1
	_gbeaa := _befd.GetNumComponents()
	_fadda := make([]uint32, _gbeaa)
	_dfgbe := make([]float64, _gbeaa)
	for {
		_bedge := _feff.ReadSamples(_fadda)
		if _bedge == _bdd.EOF {
			break
		} else if _bedge != nil {
			return img, _bedge
		}
		for _deea := 0; _deea < _gbeaa; _deea++ {
			_daed := float64(_fadda[_deea]) / _dbg
			_dfgbe[_deea] = _daed
		}
		_dded, _bedge := _befd.TintTransform.Evaluate(_dfgbe)
		if _bedge != nil {
			return img, _bedge
		}
		for _, _dbdga := range _dded {
			_dbdga = _faf.Min(_faf.Max(0, _dbdga), 1.0)
			if _bedge = _debg.WriteSample(uint32(_dbdga * _dbg)); _bedge != nil {
				return img, _bedge
			}
		}
	}
	return _befd.AlternateSpace.ImageToRGB(_agbg(&_gfdb))
}

// NewReaderForText makes a new PdfReader for an input PDF content string. For use in testing.
func NewReaderForText(txt string) *PdfReader {
	return &PdfReader{_eebc: map[_df.PdfObject]struct{}{}, _ceggc: _dacefe(), _gfdaag: _df.NewParserFromString(txt)}
}

// GetNumComponents returns the number of color components (3 for CalRGB).
func (_ccbb *PdfColorCalRGB) GetNumComponents() int { return 3 }

// NewPdfColorPatternType3 returns an empty color shading pattern type 3 (Radial).
func NewPdfColorPatternType3() *PdfColorPatternType3 { _bbaf := &PdfColorPatternType3{}; return _bbaf }

// ToPdfObject returns a PDF object representation of the outline.
func (_ggfcb *Outline) ToPdfObject() _df.PdfObject { return _ggfcb.ToPdfOutline().ToPdfObject() }

// GetModelFromPrimitive returns the model corresponding to the `primitive` PdfObject.
func (_dggc *modelManager) GetModelFromPrimitive(primitive _df.PdfObject) PdfModel {
	model, _dbgag := _dggc._fdge[primitive]
	if !_dbgag {
		return nil
	}
	return model
}

func (_bceac *PdfWriter) mapObjectStreams(_dedfa bool) (map[_df.PdfObject]bool, bool) {
	_ceade := make(map[_df.PdfObject]bool)
	for _, _bgegbd := range _bceac._ceeac {
		if _gcgbf, _gbffe := _bgegbd.(*_df.PdfObjectStreams); _gbffe {
			_dedfa = true
			for _, _bcecd := range _gcgbf.Elements() {
				_ceade[_bcecd] = true
				if _aecg, _ebeba := _bcecd.(*_df.PdfIndirectObject); _ebeba {
					_ceade[_aecg.PdfObject] = true
				}
			}
		}
	}
	return _ceade, _dedfa
}

// IsSimple returns true if `font` is a simple font.
func (_fccd *PdfFont) IsSimple() bool { _, _caecd := _fccd._eaeg.(*pdfFontSimple); return _caecd }

// GetContext returns the action context which contains the specific type-dependent context.
// The context represents the subaction.
func (_cc *PdfAction) GetContext() PdfModel {
	if _cc == nil {
		return nil
	}
	return _cc._aab
}

// SetNamedDestinations sets the Dests entry in the PDF catalog.
// See section 12.3.2.3 "Named Destinations" (p. 367 PDF32000_2008).
func (_begaa *PdfWriter) SetNamedDestinations(dests _df.PdfObject) error {
	if dests == nil {
		return nil
	}
	_bcd.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006co\u0067\u0020\u0044\u0065\u0073\u0074\u0073\u002e\u002e\u002e")
	_begaa._gdee.Set("\u0044\u0065\u0073t\u0073", dests)
	return _begaa.addObjects(dests)
}

// Compress is yet to be implemented.
// Should be able to compress in terms of JPEG quality parameter,
// and DPI threshold (need to know bounding area dimensions).
func (_afead DefaultImageHandler) Compress(input *Image, quality int64) (*Image, error) {
	return input, nil
}

// GetParamsDict returns *core.PdfObjectDictionary with a set of basic image parameters.
func (_ebca *Image) GetParamsDict() *_df.PdfObjectDictionary {
	_ffbgb := _df.MakeDict()
	_ffbgb.Set("\u0057\u0069\u0064t\u0068", _df.MakeInteger(_ebca.Width))
	_ffbgb.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _df.MakeInteger(_ebca.Height))
	_ffbgb.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _df.MakeInteger(int64(_ebca.ColorComponents)))
	_ffbgb.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _df.MakeInteger(_ebca.BitsPerComponent))
	return _ffbgb
}

// NewLTV returns a new LTV client.
func NewLTV(appender *PdfAppender) (*LTV, error) {
	_befdd := appender.Reader.DSS
	if _befdd == nil {
		_befdd = NewDSS()
	}
	if _dagab := _befdd.GenerateHashMaps(); _dagab != nil {
		return nil, _dagab
	}
	return &LTV{CertClient: _fd.NewCertClient(), OCSPClient: _fd.NewOCSPClient(), CRLClient: _fd.NewCRLClient(), SkipExisting: true, _cdad: appender, _dfcg: _befdd}, nil
}

// PdfColorPattern represents a pattern color.
type PdfColorPattern struct {
	Color       PdfColor
	PatternName _df.PdfObjectName
}

// BorderStyle defines border type, typically used for annotations.
type BorderStyle int

// ToPdfObject returns the PDF representation of the function.
func (_deed *PdfFunctionType0) ToPdfObject() _df.PdfObject {
	if _deed._faec == nil {
		_deed._faec = &_df.PdfObjectStream{}
	}
	_aebdd := _df.MakeDict()
	_aebdd.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _df.MakeInteger(0))
	_aegba := &_df.PdfObjectArray{}
	for _, _agce := range _deed.Domain {
		_aegba.Append(_df.MakeFloat(_agce))
	}
	_aebdd.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _aegba)
	_cdac := &_df.PdfObjectArray{}
	for _, _fagd := range _deed.Range {
		_cdac.Append(_df.MakeFloat(_fagd))
	}
	_aebdd.Set("\u0052\u0061\u006eg\u0065", _cdac)
	_cfece := &_df.PdfObjectArray{}
	for _, _gfbdg := range _deed.Size {
		_cfece.Append(_df.MakeInteger(int64(_gfbdg)))
	}
	_aebdd.Set("\u0053\u0069\u007a\u0065", _cfece)
	_aebdd.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0053\u0061\u006d\u0070\u006c\u0065", _df.MakeInteger(int64(_deed.BitsPerSample)))
	if _deed.Order != 1 {
		_aebdd.Set("\u004f\u0072\u0064e\u0072", _df.MakeInteger(int64(_deed.Order)))
	}
	_aebdd.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _df.MakeInteger(int64(len(_deed._egba))))
	_deed._faec.Stream = _deed._egba
	_deed._faec.PdfObjectDictionary = _aebdd
	return _deed._faec
}

// ColorFromPdfObjects gets the color from a series of pdf objects (4 for cmyk).
func (_ffgb *PdfColorspaceDeviceCMYK) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if len(objects) != 4 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gcce, _fggf := _df.GetNumbersAsFloat(objects)
	if _fggf != nil {
		return nil, _fggf
	}
	return _ffgb.ColorFromFloats(_gcce)
}

func _febd() *Names { return &Names{_dfag: _df.MakeIndirectObject(_df.MakeDict())} }

// NewImageFromGoImage creates a new NRGBA32 unidoc Image from a golang Image.
// If `goimg` is grayscale (*goimage.Gray8) then calls NewGrayImageFromGoImage instead.
func (_bafb DefaultImageHandler) NewImageFromGoImage(goimg _cg.Image) (*Image, error) {
	_bccc, _ecace := _bge.FromGoImage(goimg)
	if _ecace != nil {
		return nil, _ecace
	}
	_dgdfd := _agbg(_bccc.Base())
	return &_dgdfd, nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_cdbcc *PdfShadingType3) ToPdfObject() _df.PdfObject {
	_cdbcc.PdfShading.ToPdfObject()
	_decead, _cgdda := _cdbcc.getShadingDict()
	if _cgdda != nil {
		_bcd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _cdbcc.Coords != nil {
		_decead.Set("\u0043\u006f\u006f\u0072\u0064\u0073", _cdbcc.Coords)
	}
	if _cdbcc.Domain != nil {
		_decead.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _cdbcc.Domain)
	}
	if _cdbcc.Function != nil {
		if len(_cdbcc.Function) == 1 {
			_decead.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _cdbcc.Function[0].ToPdfObject())
		} else {
			_bbca := _df.MakeArray()
			for _, _fedcf := range _cdbcc.Function {
				_bbca.Append(_fedcf.ToPdfObject())
			}
			_decead.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _bbca)
		}
	}
	if _cdbcc.Extend != nil {
		_decead.Set("\u0045\u0078\u0074\u0065\u006e\u0064", _cdbcc.Extend)
	}
	return _cdbcc._bgdag
}

func _acbfe(_dgbef *_df.PdfObjectDictionary) {
	_ceee, _ecce := _df.GetArray(_dgbef.Get("\u0057\u0069\u0064\u0074\u0068\u0073"))
	_bbeeb, _cdfa := _df.GetIntVal(_dgbef.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r"))
	_cgfab, _ggcc := _df.GetIntVal(_dgbef.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072"))
	if _ecce && _cdfa && _ggcc {
		_gecb := _ceee.Len()
		if _gecb != _cgfab-_bbeeb+1 {
			_bcd.Log.Debug("\u0055\u006e\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0057\u0069\u0064\u0074\u0068\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076\u002c\u0020\u004c\u0061\u0073t\u0043\u0068\u0061\u0072\u003a\u0020\u0025\u0076", _gecb, _cgfab)
			_ecga := _df.PdfObjectInteger(_bbeeb + _gecb - 1)
			_dgbef.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", &_ecga)
		}
	}
}

// ToPdfObject implements interface PdfModel.
func (_gfd *PdfActionGoTo) ToPdfObject() _df.PdfObject {
	_gfd.PdfAction.ToPdfObject()
	_gbb := _gfd._gcf
	_gff := _gbb.PdfObject.(*_df.PdfObjectDictionary)
	_gff.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeGoTo)))
	_gff.SetIfNotNil("\u0044", _gfd.D)
	return _gbb
}

func _gcedg(_egdbf []*_df.PdfObjectStream) *_df.PdfObjectArray {
	if len(_egdbf) == 0 {
		return nil
	}
	_fdfcg := make([]_df.PdfObject, 0, len(_egdbf))
	for _, _eabbg := range _egdbf {
		_fdfcg = append(_fdfcg, _eabbg)
	}
	return _df.MakeArray(_fdfcg...)
}

// CharcodesToStrings returns the unicode strings corresponding to `charcodes`.
// The int returns are the number of strings and the number of unconvereted codes.
// NOTE: The number of strings returned is equal to the number of charcodes
func (_eafdf *PdfFont) CharcodesToStrings(charcodes []_abg.CharCode, replacementText string) ([]string, int, int) {
	_aadcc := _eafdf.baseFields()
	_acef := make([]string, 0, len(charcodes))
	_dbfc := 0
	_cedgd := _eafdf.Encoder()
	_gcfdg := _aadcc._afcbd != nil && _eafdf.IsSimple() && _eafdf.Subtype() == "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065" && !_gc.Contains(_aadcc._afcbd.Name(), "\u0049d\u0065\u006e\u0074\u0069\u0074\u0079-")
	if !_gcfdg && _cedgd != nil {
		switch _dfefg := _cedgd.(type) {
		case _abg.SimpleEncoder:
			_fgcae := _dfefg.BaseName()
			if _, _bdega := _cfaf[_fgcae]; _bdega {
				for _, _cfbf := range charcodes {
					if _gbeeb, _bafe := _cedgd.CharcodeToRune(_cfbf); _bafe {
						_acef = append(_acef, string(_gbeeb))
					} else {
						_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0072u\u006e\u0065\u002e\u0020\u0063\u006f\u0064\u0065=\u0030x\u0025\u0030\u0034\u0078\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0073\u003d\u005b\u0025\u00200\u0034\u0078\u005d\u0020\u0043\u0049\u0044\u003d\u0025\u0074\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073\n\u0009\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003d\u0025\u0073", _cfbf, charcodes, _aadcc.isCIDFont(), _eafdf, _cedgd)
						_dbfc++
						_acef = append(_acef, _dgf.MissingCodeString)
					}
				}
				return _acef, len(_acef), _dbfc
			}
		}
	}
	for _, _caff := range charcodes {
		if _aadcc._afcbd != nil {
			if _gddge, _fabd := _aadcc._afcbd.CharcodeToUnicode(_dgf.CharCode(_caff)); _fabd {
				_dceg, _ := _ag.DecodeLastRuneInString(_gddge)
				_bafdc := _cfaa(_dceg)
				if !(_bafdc == "\u0043\u006f") {
					_acef = append(_acef, _gddge)
					continue
				}
				_bcd.Log.Debug("E\u0052\u0052\u004fR\u003a\u0020\u0054\u006f\u0055\u006e\u0069\u0063\u006f\u0064\u0065\u0020\u0043\u006d\u0061p\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u0020\u006d\u0061\u0070\u0070\u0069\u006e\u0067.\u0020\u0063\u006f\u0064\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u0020\u0069\u0073\u0020m\u0061\u0070\u0070\u0065\u0064 \u0074\u006f\u0020\u0061\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u0063\u006f\u0064\u0065 \u0070\u006f\u0069\u006e\u0074\u0020\u0025\u0073", _caff, _gddge)
			}
		}
		if _cedgd != nil {
			if _bffd, _eagcb := _cedgd.CharcodeToRune(_caff); _eagcb {
				_cgfbf := _cfaa(_bffd)
				if !(_cgfbf == "\u0043\u006f") {
					_acef = append(_acef, string(_bffd))
					continue
				}
				_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e \u0063\u006f\u0064\u0065\u003d\u0030x\u0025\u0030\u0034\u0078\u0020\u0069\u0073\u0020\u0064\u0065\u0063\u006f\u0064\u0065d\u0020\u0074o\u0020\u0061\u006e\u0020i\u006e\u0076\u0061\u006c\u0069d\u0020\u0072\u0075\u006e\u0020\u0025\u0073", _caff, string(_bffd))
			}
		}
		if replacementText != "" {
			_acef = append(_acef, replacementText)
		} else {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0072u\u006e\u0065\u002e\u0020\u0063\u006f\u0064\u0065=\u0030x\u0025\u0030\u0034\u0078\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0073\u003d\u005b\u0025\u00200\u0034\u0078\u005d\u0020\u0043\u0049\u0044\u003d\u0025\u0074\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073\n\u0009\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003d\u0025\u0073", _caff, charcodes, _aadcc.isCIDFont(), _eafdf, _cedgd)
			_dbfc++
			_acef = append(_acef, _dgf.MissingCodeString)
		}
	}
	if _dbfc != 0 {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0043\u006f\u0075\u006c\u0064\u006e\u0027\u0074\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0074\u006f\u0020u\u006e\u0069\u0063\u006f\u0064\u0065\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020i\u006ep\u0075\u0074\u002e\u000a"+"\u0009\u006e\u0075\u006d\u0043\u0068\u0061\u0072\u0073\u003d\u0025d\u0020\u006e\u0075\u006d\u004d\u0069\u0073\u0073\u0065\u0073=\u0025\u0064\u000a"+"\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073", len(charcodes), _dbfc, _eafdf)
	}
	return _acef, len(_acef), _dbfc
}

// ToPdfObject converts the K dictionary to a PDF object.
func (_abbge *KValue) ToPdfObject() _df.PdfObject {
	if _abbge._eebde != nil {
		return _df.MakeIndirectObject(_abbge._eebde.ToPdfObject())
	}
	if _abbge._ccgeg != nil {
		return _abbge._ccgeg
	}
	if _abbge._dfca != nil {
		return _df.MakeInteger(int64(*_abbge._dfca))
	}
	return nil
}

func _fcdf(_dggec _df.PdfObject) (string, error) {
	_dggec = _df.TraceToDirectObject(_dggec)
	switch _bcab := _dggec.(type) {
	case *_df.PdfObjectString:
		return _bcab.Str(), nil
	case *_df.PdfObjectStream:
		_fgece, _fbeg := _df.DecodeStream(_bcab)
		if _fbeg != nil {
			return "", _fbeg
		}
		return string(_fgece), nil
	}
	return "", _c.Errorf("\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0073\u0074\u0072e\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0068\u006f\u006c\u0064\u0065\u0072\u0020\u0028\u0025\u0054\u0029", _dggec)
}

func (_adbgb *PdfPage) setContainer(_cbdgcf *_df.PdfIndirectObject) {
	_cbdgcf.PdfObject = _adbgb._gfcee
	_adbgb._gcced = _cbdgcf
}

// ColorToRGB converts a CMYK32 color to an RGB color.
func (_bfgb *PdfColorspaceDeviceCMYK) ColorToRGB(color PdfColor) (PdfColor, error) {
	_fegc, _gdgg := color.(*PdfColorDeviceCMYK)
	if !_gdgg {
		_bcd.Log.Debug("I\u006e\u0070\u0075\u0074\u0020\u0063o\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0064e\u0076\u0069\u0063e\u0020c\u006d\u0079\u006b")
		return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_ffcfd := _fegc.C()
	_cbba := _fegc.M()
	_bbdc := _fegc.Y()
	_dfbcb := _fegc.K()
	_ffcfd = _ffcfd*(1-_dfbcb) + _dfbcb
	_cbba = _cbba*(1-_dfbcb) + _dfbcb
	_bbdc = _bbdc*(1-_dfbcb) + _dfbcb
	_geafb := 1 - _ffcfd
	_bbcb := 1 - _cbba
	_acgb := 1 - _bbdc
	return NewPdfColorDeviceRGB(_geafb, _bbcb, _acgb), nil
}

// IsShading specifies if the pattern is a shading pattern.
func (_cbafd *PdfPattern) IsShading() bool { return _cbafd.PatternType == 2 }

func (_efcd fontCommon) asPdfObjectDictionary(_ebef string) *_df.PdfObjectDictionary {
	if _ebef != "" && _efcd._fgfae != "" && _ebef != _efcd._fgfae {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0061\u0073\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0044\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u002e\u0020O\u0076\u0065\u0072\u0072\u0069\u0064\u0069\u006e\u0067\u0020\u0073\u0075\u0062t\u0079\u0070\u0065\u0020\u0074\u006f \u0025\u0023\u0071 \u0025\u0073", _ebef, _efcd)
	} else if _ebef == "" && _efcd._fgfae == "" {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0061s\u0050\u0064\u0066Ob\u006a\u0065\u0063\u0074\u0044\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006e\u006f\u0020\u0073\u0075\u0062\u0074y\u0070\u0065\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _efcd)
	} else if _efcd._fgfae == "" {
		_efcd._fgfae = _ebef
	}
	_gagag := _df.MakeDict()
	_gagag.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0046\u006f\u006e\u0074"))
	_gagag.Set("\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074", _df.MakeName(_efcd._gddcf))
	_gagag.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName(_efcd._fgfae))
	if _efcd._agggb != nil {
		_gagag.Set("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072", _efcd._agggb.ToPdfObject())
	}
	if _efcd._cdbgag != nil {
		_gagag.Set("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e", _efcd._cdbgag)
	} else if _efcd._afcbd != nil {
		_edaggf, _adcfb := _efcd._afcbd.Stream()
		if _adcfb != nil {
			_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0067\u0065\u0074\u0020C\u004d\u0061\u0070\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u002e\u0020\u0065r\u0072\u003d\u0025\u0076", _adcfb)
		} else {
			_gagag.Set("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e", _edaggf)
		}
	}
	return _gagag
}

func (_fgbbbf *PdfWriter) writeObjects() {
	_bcd.Log.Trace("\u0057\u0072\u0069\u0074\u0069\u006e\u0067\u0020\u0025d\u0020\u006f\u0062\u006a", len(_fgbbbf._ceeac))
	_fgbbbf._cdgd = make(map[int]crossReference)
	_fgbbbf._cdgd[0] = crossReference{Type: 0, ObjectNumber: 0, Generation: 0xFFFF}
	if _fgbbbf._cbgfg.ObjectMap != nil {
		for _dcege, _bfade := range _fgbbbf._cbgfg.ObjectMap {
			if _dcege == 0 {
				continue
			}
			if _bfade.XType == _df.XrefTypeObjectStream {
				_aafef := crossReference{Type: 2, ObjectNumber: _bfade.OsObjNumber, Index: _bfade.OsObjIndex}
				_fgbbbf._cdgd[_dcege] = _aafef
			}
			if _bfade.XType == _df.XrefTypeTableEntry {
				_efbdd := crossReference{Type: 1, ObjectNumber: _bfade.ObjectNumber, Offset: _bfade.Offset}
				_fgbbbf._cdgd[_dcege] = _efbdd
			}
		}
	}
}

func (_bbc *PdfReader) newPdfActionHideFromDict(_gfef *_df.PdfObjectDictionary) (*PdfActionHide, error) {
	return &PdfActionHide{T: _gfef.Get("\u0054"), H: _gfef.Get("\u0048")}, nil
}

// NewPdfPageResourcesColorspaces returns a new PdfPageResourcesColorspaces object.
func NewPdfPageResourcesColorspaces() *PdfPageResourcesColorspaces {
	_gdgec := &PdfPageResourcesColorspaces{}
	_gdgec.Names = []string{}
	_gdgec.Colorspaces = map[string]PdfColorspace{}
	_gdgec._bcbab = &_df.PdfIndirectObject{}
	return _gdgec
}

// NewReaderOpts generates a default `ReaderOpts` instance.
func NewReaderOpts() *ReaderOpts { return &ReaderOpts{Password: "", LazyLoad: true} }

var _ pdfFont = (*pdfFontType3)(nil)

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element between 0 and 1.
func (_dfce *PdfColorspaceCalGray) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_acgeg := vals[0]
	if _acgeg < 0.0 || _acgeg > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _acgeg)
		return nil, ErrColorOutOfRange
	}
	_bceb := NewPdfColorCalGray(_acgeg)
	return _bceb, nil
}

// ToPdfObject converts the PdfFont object to its PDF representation.
func (_gcebe *PdfFont) ToPdfObject() _df.PdfObject {
	if _gcebe._eaeg == nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0066\u006f\u006e\u0074 \u0063\u006f\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073 \u006e\u0069\u006c")
		return _df.MakeNull()
	}
	return _gcebe._eaeg.ToPdfObject()
}

// GetNumComponents returns the number of color components of the underlying
// colorspace device.
func (_bffaf *PdfColorspaceSpecialPattern) GetNumComponents() int {
	return _bffaf.UnderlyingCS.GetNumComponents()
}

func _dcbc(_fgbb _df.PdfObject) (*PdfBorderStyle, error) {
	_dcddc := &PdfBorderStyle{}
	_dcddc._bbcf = _fgbb
	var _fcbf *_df.PdfObjectDictionary
	_fgbb = _df.TraceToDirectObject(_fgbb)
	_fcbf, _gbab := _fgbb.(*_df.PdfObjectDictionary)
	if !_gbab {
		return nil, _deb.New("\u0074\u0079\u0070\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	if _dgad := _fcbf.Get("\u0054\u0079\u0070\u0065"); _dgad != nil {
		_fcff, _dcfc := _dgad.(*_df.PdfObjectName)
		if !_dcfc {
			_bcd.Log.Debug("I\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062i\u006c\u0069\u0074\u0079\u0020\u0077\u0069th\u0020\u0054\u0079\u0070e\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0061me\u0020\u006fb\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0054", _dgad)
		} else {
			if *_fcff != "\u0042\u006f\u0072\u0064\u0065\u0072" {
				_bcd.Log.Debug("W\u0061\u0072\u006e\u0069\u006e\u0067,\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020B\u006f\u0072\u0064e\u0072:\u0020\u0025\u0073", *_fcff)
			}
		}
	}
	if _gffc := _fcbf.Get("\u0057"); _gffc != nil {
		_dfeb, _geef := _df.GetNumberAsFloat(_gffc)
		if _geef != nil {
			_bcd.Log.Debug("\u0045\u0072\u0072\u006fr \u0072\u0065\u0074\u0072\u0069\u0065\u0076\u0069\u006e\u0067\u0020\u0057\u003a\u0020%\u0076", _geef)
			return nil, _geef
		}
		_dcddc.W = &_dfeb
	}
	if _gaba := _fcbf.Get("\u0053"); _gaba != nil {
		_beeg, _cfgdd := _gaba.(*_df.PdfObjectName)
		if !_cfgdd {
			return nil, _deb.New("\u0062\u006f\u0072\u0064\u0065\u0072\u0020\u0053\u0020\u006e\u006ft\u0020\u0061\u0020\u006e\u0061\u006d\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		var _cffc BorderStyle
		switch *_beeg {
		case "\u0053":
			_cffc = BorderStyleSolid
		case "\u0044":
			_cffc = BorderStyleDashed
		case "\u0042":
			_cffc = BorderStyleBeveled
		case "\u0049":
			_cffc = BorderStyleInset
		case "\u0055":
			_cffc = BorderStyleUnderline
		default:
			_bcd.Log.Debug("I\u006e\u0076\u0061\u006cid\u0020s\u0074\u0079\u006c\u0065\u0020n\u0061\u006d\u0065\u0020\u0025\u0073", *_beeg)
			return nil, _deb.New("\u0073\u0074\u0079\u006ce \u0074\u0079\u0070\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065c\u006b")
		}
		_dcddc.S = &_cffc
	}
	if _bdec := _fcbf.Get("\u0044"); _bdec != nil {
		_cded, _dgbb := _bdec.(*_df.PdfObjectArray)
		if !_dgbb {
			_bcd.Log.Debug("\u0042\u006f\u0072\u0064\u0065\u0072\u0020\u0044\u0020\u0064a\u0073\u0068\u0020\u006e\u006f\u0074\u0020a\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0054", _bdec)
			return nil, _deb.New("\u0062o\u0072\u0064\u0065\u0072 \u0044\u0020\u0074\u0079\u0070e\u0020c\u0068e\u0063\u006b\u0020\u0065\u0072\u0072\u006fr")
		}
		_gfaa, _fgefc := _cded.ToIntegerArray()
		if _fgefc != nil {
			_bcd.Log.Debug("\u0042\u006f\u0072\u0064\u0065\u0072\u0020\u0044 \u0050\u0072\u006fbl\u0065\u006d\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0069\u006e\u0074\u0065\u0067e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u003a \u0025\u0076", _fgefc)
			return nil, _fgefc
		}
		_dcddc.D = &_gfaa
	}
	return _dcddc, nil
}

// ToPdfObject returns the PDF representation of the shading pattern.
func (_dfadga *PdfShadingPatternType2) ToPdfObject() _df.PdfObject {
	_dfadga.PdfPattern.ToPdfObject()
	_cgfd := _dfadga.getDict()
	if _dfadga.Shading != nil {
		_cgfd.Set("\u0053h\u0061\u0064\u0069\u006e\u0067", _dfadga.Shading.ToPdfObject())
	}
	if _dfadga.Matrix != nil {
		_cgfd.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _dfadga.Matrix)
	}
	if _dfadga.ExtGState != nil {
		_cgfd.Set("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _dfadga.ExtGState)
	}
	return _dfadga._cbce
}

// PdfColorspaceCalRGB stores A, B, C components
type PdfColorspaceCalRGB struct {
	WhitePoint []float64
	BlackPoint []float64
	Gamma      []float64
	Matrix     []float64
	_gbae      *_df.PdfObjectDictionary
	_bbed      *_df.PdfIndirectObject
}

func _ggebfd() _fa.Time { _gcdec.Lock(); defer _gcdec.Unlock(); return _dfbeb }

func (_ffbg *PdfAppender) replaceObject(_baeg, _caf _df.PdfObject) {
	switch _dacc := _baeg.(type) {
	case *_df.PdfIndirectObject:
		_ffbg._aggf[_caf] = _dacc.ObjectNumber
	case *_df.PdfObjectStream:
		_ffbg._aggf[_caf] = _dacc.ObjectNumber
	}
}

// SetCatalogMarkInfo sets the catalog MarkInfo dictionary.
func (_bbadb *PdfWriter) SetCatalogMarkInfo(info _df.PdfObject) error {
	if info == nil {
		_bbadb._gdee.Remove("\u004d\u0061\u0072\u006b\u0049\u006e\u0066\u006f")
		return nil
	}
	if _cfcag, _facbg := info.(*_df.PdfObjectReference); _facbg {
		info = _cfcag.Resolve()
		if info == nil {
			_bbadb._gdee.Remove("\u004d\u0061\u0072\u006b\u0049\u006e\u0066\u006f")
			return nil
		}
	}
	_bbadb.addObject(info)
	_bbadb._gdee.Set("\u004d\u0061\u0072\u006b\u0049\u006e\u0066\u006f", info)
	return nil
}

// Insert adds a top level outline item in the outline,
// at the specified index.
func (_fdfcf *Outline) Insert(index uint, item *OutlineItem) {
	_bcbd := uint(len(_fdfcf.Entries))
	if index > _bcbd {
		index = _bcbd
	}
	_fdfcf.Entries = append(_fdfcf.Entries[:index], append([]*OutlineItem{item}, _fdfcf.Entries[index:]...)...)
}

// NewPdfInfoFromObject creates a new PdfInfo from the input core.PdfObject.
func NewPdfInfoFromObject(obj _df.PdfObject) (*PdfInfo, error) {
	var _geadaa PdfInfo
	_eagf, _gddf := obj.(*_df.PdfObjectDictionary)
	if !_gddf {
		return nil, _c.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0064\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054", obj)
	}
	for _, _adac := range _eagf.Keys() {
		switch _adac {
		case "\u0054\u0069\u0074l\u0065":
			_geadaa.Title, _ = _df.GetString(_eagf.Get("\u0054\u0069\u0074l\u0065"))
		case "\u0041\u0075\u0074\u0068\u006f\u0072":
			_geadaa.Author, _ = _df.GetString(_eagf.Get("\u0041\u0075\u0074\u0068\u006f\u0072"))
		case "\u0053u\u0062\u006a\u0065\u0063\u0074":
			_geadaa.Subject, _ = _df.GetString(_eagf.Get("\u0053u\u0062\u006a\u0065\u0063\u0074"))
		case "\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073":
			_geadaa.Keywords, _ = _df.GetString(_eagf.Get("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073"))
		case "\u0043r\u0065\u0061\u0074\u006f\u0072":
			_geadaa.Creator, _ = _df.GetString(_eagf.Get("\u0043r\u0065\u0061\u0074\u006f\u0072"))
		case "\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072":
			_geadaa.Producer, _ = _df.GetString(_eagf.Get("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072"))
		case "\u0054r\u0061\u0070\u0070\u0065\u0064":
			_geadaa.Trapped, _ = _df.GetName(_eagf.Get("\u0054r\u0061\u0070\u0070\u0065\u0064"))
		case "\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065":
			if _ggdcb, _bagf := _df.GetString(_eagf.Get("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065")); _bagf && _ggdcb.String() != "" {
				_bcdeb, _fefd := NewPdfDate(_ggdcb.String())
				if _fefd != nil {
					return nil, _c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0072e\u0061\u0074\u0069\u006f\u006e\u0044\u0061t\u0065\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0077", _fefd)
				}
				_geadaa.CreationDate = &_bcdeb
			}
		case "\u004do\u0064\u0044\u0061\u0074\u0065":
			if _efbb, _eaga := _df.GetString(_eagf.Get("\u004do\u0064\u0044\u0061\u0074\u0065")); _eaga && _efbb.String() != "" {
				_aaged, _aeaff := NewPdfDate(_efbb.String())
				if _aeaff != nil {
					return nil, _c.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u004d\u006f\u0064\u0044a\u0074e\u0020f\u0069\u0065\u006c\u0064\u003a\u0020\u0025w", _aeaff)
				}
				_geadaa.ModifiedDate = &_aaged
			}
		default:
			_bcfbbb, _ := _df.GetString(_eagf.Get(_adac))
			if _geadaa._bcec == nil {
				_geadaa._bcec = _df.MakeDict()
			}
			_geadaa._bcec.Set(_adac, _bcfbbb)
		}
	}
	return &_geadaa, nil
}

// NewEmbeddedFile constructs a new EmbeddedFile object from supplied file.
// The file type of the file would be detected automatically.
func NewEmbeddedFile(path string) (*EmbeddedFile, error) {
	_baffb, _ddfg := _bf.ReadFile(path)
	if _ddfg != nil {
		return nil, _ddfg
	}
	_fcfge := _be.Detect(_baffb)
	_gdab := _af.Sum(_baffb)
	_gbbb := &EmbeddedFile{Name: _bg.Base(path), Content: _baffb, FileType: _fcfge.String(), Hash: _ab.EncodeToString(_gdab[:])}
	return _gbbb, nil
}

// String returns a string that describes `base`.
func (_bcag fontCommon) String() string {
	return _c.Sprintf("\u0046\u004f\u004e\u0054\u007b\u0025\u0073\u007d", _bcag.coreString())
}

func (_egdef *PdfReader) flattenFieldsWithOpts(_egdb bool, _baefb FieldAppearanceGenerator, _deage *FieldFlattenOpts) error {
	if _deage == nil {
		_deage = &FieldFlattenOpts{}
	}
	var _cedfa bool
	_cadb := map[*PdfAnnotation]bool{}
	{
		var _cbaeg []*PdfField
		_ffbc := _egdef.AcroForm
		if _ffbc != nil {
			if _deage.FilterFunc != nil {
				_cbaeg = _ffbc.filteredFields(_deage.FilterFunc, true)
				_cedfa = _ffbc.Fields != nil && len(*_ffbc.Fields) > 0
			} else {
				_cbaeg = _ffbc.AllFields()
			}
		}
		for _, _ggag := range _cbaeg {
			if len(_ggag.Annotations) < 1 {
				_bcd.Log.Debug("\u004e\u006f\u0020\u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u006f\u0075\u006ed\u0020\u0066\u006f\u0072\u003a\u0020\u0025v\u002c\u0020\u006c\u006f\u006f\u006b\u0020\u0069\u006e\u0074\u006f \u004b\u0069\u0064\u0073\u0020\u004f\u0062\u006a\u0065\u0063\u0074", _ggag.PartialName())
				for _dffe, _fcac := range _ggag.Kids {
					for _, _eafdg := range _fcac.Annotations {
						_cadb[_eafdg.PdfAnnotation] = _ggag.V != nil
						if _fcac.V == nil {
							_fcac.V = _ggag.V
						}
						if _fcac.T == nil {
							_fcac.T = _df.MakeString(_c.Sprintf("\u0025\u0073\u0023%\u0064", _ggag.PartialName(), _dffe))
						}
						if _baefb != nil {
							_dbag, _ceebe := _baefb.GenerateAppearanceDict(_ffbc, _fcac, _eafdg)
							if _ceebe != nil {
								return _ceebe
							}
							_eafdg.AP = _dbag
						}
					}
				}
			}
			for _, _deff := range _ggag.Annotations {
				_cadb[_deff.PdfAnnotation] = _ggag.V != nil
				if _baefb != nil {
					_ddcdd, _ccef := _baefb.GenerateAppearanceDict(_ffbc, _ggag, _deff)
					if _ccef != nil {
						return _ccef
					}
					_deff.AP = _ddcdd
				}
			}
		}
	}
	if _egdb {
		for _, _geab := range _egdef.PageList {
			_gefb, _gdbdf := _geab.GetAnnotations()
			if _gdbdf != nil {
				return _gdbdf
			}
			for _, _eegc := range _gefb {
				_cadb[_eegc] = true
			}
		}
	}
	for _, _gced := range _egdef.PageList {
		_cbdgd := _gced.flattenFieldsWithOpts(_baefb, _deage, _cadb)
		if _cbdgd != nil {
			return _cbdgd
		}
	}
	if !_cedfa {
		_egdef.AcroForm = nil
	}
	return nil
}

func (_aaf *PdfReader) newPdfAnnotationLineFromDict(_fbga *_df.PdfObjectDictionary) (*PdfAnnotationLine, error) {
	_aggg := PdfAnnotationLine{}
	_cfbe, _dgfd := _aaf.newPdfAnnotationMarkupFromDict(_fbga)
	if _dgfd != nil {
		return nil, _dgfd
	}
	_aggg.PdfAnnotationMarkup = _cfbe
	_aggg.L = _fbga.Get("\u004c")
	_aggg.BS = _fbga.Get("\u0042\u0053")
	_aggg.LE = _fbga.Get("\u004c\u0045")
	_aggg.IC = _fbga.Get("\u0049\u0043")
	_aggg.LL = _fbga.Get("\u004c\u004c")
	_aggg.LLE = _fbga.Get("\u004c\u004c\u0045")
	_aggg.Cap = _fbga.Get("\u0043\u0061\u0070")
	_aggg.IT = _fbga.Get("\u0049\u0054")
	_aggg.LLO = _fbga.Get("\u004c\u004c\u004f")
	_aggg.CP = _fbga.Get("\u0043\u0050")
	_aggg.Measure = _fbga.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	_aggg.CO = _fbga.Get("\u0043\u004f")
	return &_aggg, nil
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_efadc pdfFontType3) GetCharMetrics(code _abg.CharCode) (_da.CharMetrics, bool) {
	if _cgbd, _dacfa := _efadc._cgfgg[code]; _dacfa {
		return _da.CharMetrics{Wx: _cgbd}, true
	}
	if _da.IsStdFont(_da.StdFontName(_efadc._gddcf)) {
		return _da.CharMetrics{Wx: 250}, true
	}
	return _da.CharMetrics{}, false
}

func _ffca(_gbcbf *fontCommon) *pdfFontType3 { return &pdfFontType3{fontCommon: *_gbcbf} }

// IsTerminal returns true for terminal fields, false otherwise.
// Terminal fields are fields whose descendants are only widget annotations.
func (_cbff *PdfField) IsTerminal() bool { return len(_cbff.Kids) == 0 }

// ToInteger convert to an integer format.
func (_cdgec *PdfColorCalRGB) ToInteger(bits int) [3]uint32 {
	_gfgf := _faf.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_gfgf * _cdgec.A()), uint32(_gfgf * _cdgec.B()), uint32(_gfgf * _cdgec.C())}
}

func (_babf *PdfReader) loadDSS() (*DSS, error) {
	if _babf._gfdaag.GetCrypter() != nil && !_babf._gfdaag.IsAuthenticated() {
		return nil, _c.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_aagegb := _babf._afbaf.Get("\u0044\u0053\u0053")
	if _aagegb == nil {
		return nil, nil
	}
	_aefec, _ := _df.GetIndirect(_aagegb)
	_aagegb = _df.TraceToDirectObject(_aagegb)
	switch _abebf := _aagegb.(type) {
	case *_df.PdfObjectNull:
		return nil, nil
	case *_df.PdfObjectDictionary:
		return _aaee(_aefec, _abebf)
	}
	return nil, _c.Errorf("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0044\u0053\u0053 \u0065\u006e\u0074\u0072y \u0025\u0054", _aagegb)
}

func (_fdgec *PdfReader) newPdfOutlineItemFromIndirectObject(_eebea *_df.PdfIndirectObject) (*PdfOutlineItem, error) {
	_gecba, _gffff := _eebea.PdfObject.(*_df.PdfObjectDictionary)
	if !_gffff {
		return nil, _c.Errorf("\u006f\u0075\u0074l\u0069\u006e\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_fcbc := NewPdfOutlineItem()
	_affcb := _gecba.Get("\u0054\u0069\u0074l\u0065")
	if _affcb == nil {
		return nil, _c.Errorf("\u006d\u0069\u0073s\u0069\u006e\u0067\u0020\u0054\u0069\u0074\u006c\u0065\u0020\u0066\u0072\u006f\u006d\u0020\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0049\u0074\u0065\u006d\u0020\u0028r\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029")
	}
	_bdabg, _agbgf := _df.GetString(_affcb)
	if !_agbgf {
		return nil, _c.Errorf("\u0074\u0069\u0074le\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0028\u0025\u0054\u0029", _affcb)
	}
	_fcbc.Title = _bdabg
	if _gacbd := _gecba.Get("\u0043\u006f\u0075n\u0074"); _gacbd != nil {
		_dcbda, _egae := _gacbd.(*_df.PdfObjectInteger)
		if !_egae {
			return nil, _c.Errorf("\u0063o\u0075\u006e\u0074\u0020n\u006f\u0074\u0020\u0061\u006e \u0069n\u0074e\u0067\u0065\u0072\u0020\u0028\u0025\u0054)", _gacbd)
		}
		_bdac := int64(*_dcbda)
		_fcbc.Count = &_bdac
	}
	if _gfgbg := _gecba.Get("\u0044\u0065\u0073\u0074"); _gfgbg != nil {
		_fcbc.Dest = _df.ResolveReference(_gfgbg)
		if !_fdgec._edbbdf {
			_gbcd := _fdgec.traverseObjectData(_fcbc.Dest)
			if _gbcd != nil {
				return nil, _gbcd
			}
		}
	}
	if _dcbae := _gecba.Get("\u0041"); _dcbae != nil {
		_fcbc.A = _df.ResolveReference(_dcbae)
		if !_fdgec._edbbdf {
			_ddgfd := _fdgec.traverseObjectData(_fcbc.A)
			if _ddgfd != nil {
				return nil, _ddgfd
			}
		}
	}
	if _fbaed := _gecba.Get("\u0053\u0045"); _fbaed != nil {
		_fcbc.SE = nil
	}
	if _fbgab := _gecba.Get("\u0043"); _fbgab != nil {
		_fcbc.C = _df.ResolveReference(_fbgab)
	}
	if _gcag := _gecba.Get("\u0046"); _gcag != nil {
		_fcbc.F = _df.ResolveReference(_gcag)
	}
	return _fcbc, nil
}

// PdfActionGoToE represents a GoToE action.
type PdfActionGoToE struct {
	*PdfAction
	F         *PdfFilespec
	D         _df.PdfObject
	NewWindow _df.PdfObject
	T         _df.PdfObject
}

// GetStructParentsKey returns the StructParents key.
// If not set, returns -1.
func (_cbafe *PdfPage) GetStructParentsKey() int {
	if _dacag, _gdgef := _df.GetIntVal(_cbafe.StructParents); _gdgef {
		return _dacag
	}
	return -1
}

func (_daag *PdfReader) newPdfAcroFormFromDict(_ffcba *_df.PdfIndirectObject, _cfeaf *_df.PdfObjectDictionary) (*PdfAcroForm, error) {
	_gdfbe := NewPdfAcroForm()
	if _ffcba != nil {
		_gdfbe._cffeg = _ffcba
		_ffcba.PdfObject = _df.MakeDict()
	}
	if _ebada := _cfeaf.Get("\u0046\u0069\u0065\u006c\u0064\u0073"); _ebada != nil && !_df.IsNullObject(_ebada) {
		_gadc, _gfcg := _df.GetArray(_ebada)
		if !_gfcg {
			return nil, _c.Errorf("\u0066i\u0065\u006c\u0064\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e \u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0025\u0054\u0029", _ebada)
		}
		var _geeag []*PdfField
		for _, _afcee := range _gadc.Elements() {
			_cfee, _gagg := _df.GetIndirect(_afcee)
			if !_gagg {
				if _, _cadef := _afcee.(*_df.PdfObjectNull); _cadef {
					_bcd.Log.Trace("\u0053k\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u006f\u0076\u0065\u0072 \u006e\u0075\u006c\u006c\u0020\u0066\u0069\u0065\u006c\u0064")
					continue
				}
				_bcd.Log.Debug("\u0046\u0069\u0065\u006c\u0064 \u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0064 \u0069\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0054", _afcee)
				return nil, _c.Errorf("\u0066\u0069\u0065l\u0064\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u006e\u0020i\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
			}
			_fbcf, _fadeg := _daag.newPdfFieldFromIndirectObject(_cfee, nil)
			if _fadeg != nil {
				return nil, _fadeg
			}
			_bcd.Log.Trace("\u0041\u0063\u0072\u006fFo\u0072\u006d\u0020\u0046\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u002b\u0076", *_fbcf)
			_geeag = append(_geeag, _fbcf)
		}
		_gdfbe.Fields = &_geeag
	}
	if _fgbgc := _cfeaf.Get("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073"); _fgbgc != nil {
		_dgab, _gdbaa := _df.GetBool(_fgbgc)
		if _gdbaa {
			_gdfbe.NeedAppearances = _dgab
		} else {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u0065\u0065\u0064\u0041\u0070p\u0065\u0061\u0072\u0061\u006e\u0063e\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006ft\u0020\u0025\u0054\u0029", _fgbgc)
		}
	}
	if _fgecc := _cfeaf.Get("\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073"); _fgecc != nil {
		_agdea, _gdfge := _df.GetInt(_fgecc)
		if _gdfge {
			_gdfbe.SigFlags = _agdea
		} else {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073 \u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _fgecc)
		}
	}
	if _gfceb := _cfeaf.Get("\u0043\u004f"); _gfceb != nil {
		_bfaef, _dgeg := _df.GetArray(_gfceb)
		if _dgeg {
			_gdfbe.CO = _bfaef
		} else {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u004f\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _gfceb)
		}
	}
	if _cffbd := _cfeaf.Get("\u0044\u0052"); _cffbd != nil {
		if _fbac, _agfb := _df.GetDict(_cffbd); _agfb {
			_ecfgg, _afcfd := NewPdfPageResourcesFromDict(_fbac)
			if _afcfd != nil {
				_bcd.Log.Error("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0044R\u003a\u0020\u0025\u0076", _afcfd)
				return nil, _afcfd
			}
			_gdfbe.DR = _ecfgg
		} else {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0044\u0052\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _cffbd)
		}
	}
	if _fddgc := _cfeaf.Get("\u0044\u0041"); _fddgc != nil {
		_cgfe, _fbae := _df.GetString(_fddgc)
		if _fbae {
			_gdfbe.DA = _cgfe
		} else {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0044\u0041\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _fddgc)
		}
	}
	if _cfgcg := _cfeaf.Get("\u0051"); _cfgcg != nil {
		_gafgd, _ecae := _df.GetInt(_cfgcg)
		if _ecae {
			_gdfbe.Q = _gafgd
		} else {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u0051\u0020\u0069\u006e\u0076a\u006ci\u0064 \u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _cfgcg)
		}
	}
	if _bebcc := _cfeaf.Get("\u0058\u0046\u0041"); _bebcc != nil {
		_gdfbe.XFA = _bebcc
	}
	if _bgdf := _cfeaf.Get("\u0041\u0044\u0042\u0045\u005f\u0045\u0063\u0068\u006f\u0053\u0069\u0067\u006e"); _bgdf != nil {
		_gdfbe.ADBEEchoSign = _bgdf
	}
	_gdfbe.ToPdfObject()
	return _gdfbe, nil
}

func (_dgde *pdfCIDFontType0) baseFields() *fontCommon { return &_dgde.fontCommon }

func (_dfab *PdfFunctionType0) processSamples() error {
	_cfcee := _aff.ResampleBytes(_dfab._egba, _dfab.BitsPerSample)
	_dfab._fdfc = _cfcee
	return nil
}

func _caeab(_dggdc _df.PdfObject) (*PdfPageResourcesColorspaces, error) {
	_eddcb := &PdfPageResourcesColorspaces{}
	if _acbb, _feafb := _dggdc.(*_df.PdfIndirectObject); _feafb {
		_eddcb._bcbab = _acbb
		_dggdc = _acbb.PdfObject
	}
	_adgaa, _aadfg := _df.GetDict(_dggdc)
	if !_aadfg {
		return nil, _deb.New("\u0043\u0053\u0020at\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_eddcb.Names = []string{}
	_eddcb.Colorspaces = map[string]PdfColorspace{}
	for _, _ddegf := range _adgaa.Keys() {
		_dfagb := _adgaa.Get(_ddegf)
		_eddcb.Names = append(_eddcb.Names, string(_ddegf))
		_cdgeaf, _aadfa := NewPdfColorspaceFromPdfObject(_dfagb)
		if _aadfa != nil {
			return nil, _aadfa
		}
		_eddcb.Colorspaces[string(_ddegf)] = _cdgeaf
	}
	return _eddcb, nil
}

// PdfShadingType7 is a Tensor-product patch mesh.
type PdfShadingType7 struct {
	*PdfShading
	BitsPerCoordinate *_df.PdfObjectInteger
	BitsPerComponent  *_df.PdfObjectInteger
	BitsPerFlag       *_df.PdfObjectInteger
	Decode            *_df.PdfObjectArray
	Function          []PdfFunction
}

// AddAnnotation appends `annot` to the list of page annotations.
func (_agffd *PdfPage) AddAnnotation(annot *PdfAnnotation) {
	if _agffd._adef == nil {
		_agffd.GetAnnotations()
	}
	_agffd._adef = append(_agffd._adef, annot)
}

// GetPageIndirectObject returns the indirect object of page for the specified page number.
func (_adagg *PdfWriter) GetPageIndirectObject(pageNum int) (*_df.PdfIndirectObject, error) {
	if pageNum < 0 || pageNum >= len(_adagg._aaadf) {
		return nil, _deb.New("\u0070a\u0067\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	return _adagg._aaadf[pageNum], nil
}

// ToPdfObject implements interface PdfModel.
func (_fedd *PdfAnnotationLine) ToPdfObject() _df.PdfObject {
	_fedd.PdfAnnotation.ToPdfObject()
	_beaf := _fedd._bfde
	_agde := _beaf.PdfObject.(*_df.PdfObjectDictionary)
	_fedd.PdfAnnotationMarkup.appendToPdfDictionary(_agde)
	_agde.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u004c\u0069\u006e\u0065"))
	_agde.SetIfNotNil("\u004c", _fedd.L)
	_agde.SetIfNotNil("\u0042\u0053", _fedd.BS)
	_agde.SetIfNotNil("\u004c\u0045", _fedd.LE)
	_agde.SetIfNotNil("\u0049\u0043", _fedd.IC)
	_agde.SetIfNotNil("\u004c\u004c", _fedd.LL)
	_agde.SetIfNotNil("\u004c\u004c\u0045", _fedd.LLE)
	_agde.SetIfNotNil("\u0043\u0061\u0070", _fedd.Cap)
	_agde.SetIfNotNil("\u0049\u0054", _fedd.IT)
	_agde.SetIfNotNil("\u004c\u004c\u004f", _fedd.LLO)
	_agde.SetIfNotNil("\u0043\u0050", _fedd.CP)
	_agde.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _fedd.Measure)
	_agde.SetIfNotNil("\u0043\u004f", _fedd.CO)
	return _beaf
}

// Normalize swaps (Llx,Urx) if Urx < Llx, and (Lly,Ury) if Ury < Lly.
func (_fcebd *PdfRectangle) Normalize() {
	if _fcebd.Llx > _fcebd.Urx {
		_fcebd.Llx, _fcebd.Urx = _fcebd.Urx, _fcebd.Llx
	}
	if _fcebd.Lly > _fcebd.Ury {
		_fcebd.Lly, _fcebd.Ury = _fcebd.Ury, _fcebd.Lly
	}
}

// ToPdfObject implements interface PdfModel.
func (_cdc *PdfAnnotationStamp) ToPdfObject() _df.PdfObject {
	_cdc.PdfAnnotation.ToPdfObject()
	_cag := _cdc._bfde
	_bcfbb := _cag.PdfObject.(*_df.PdfObjectDictionary)
	_cdc.PdfAnnotationMarkup.appendToPdfDictionary(_bcfbb)
	_bcfbb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0053\u0074\u0061m\u0070"))
	_bcfbb.SetIfNotNil("\u004e\u0061\u006d\u0065", _cdc.Name)
	return _cag
}

var _bface = _eb.MustCompile("\u005b\\\u006e\u005c\u0072\u005d\u002b")

// FieldImageProvider provides fields images for specified fields.
type FieldImageProvider interface {
	FieldImageValues() (map[string]*Image, error)
}

// PdfActionNamed represents a named action.
type PdfActionNamed struct {
	*PdfAction
	N _df.PdfObject
}

// NewPdfColorCalRGB returns a new CalRBG color.
func NewPdfColorCalRGB(a, b, c float64) *PdfColorCalRGB {
	_aegg := PdfColorCalRGB{a, b, c}
	return &_aegg
}

func _acgee(_acbaa *_df.PdfObjectDictionary) (*PdfShadingType6, error) {
	_bdfg := PdfShadingType6{}
	_bceab := _acbaa.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _bceab == nil {
		_bcd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_bbbea, _ebff := _bceab.(*_df.PdfObjectInteger)
	if !_ebff {
		_bcd.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _bceab)
		return nil, _df.ErrTypeError
	}
	_bdfg.BitsPerCoordinate = _bbbea
	_bceab = _acbaa.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _bceab == nil {
		_bcd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_bbbea, _ebff = _bceab.(*_df.PdfObjectInteger)
	if !_ebff {
		_bcd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _bceab)
		return nil, _df.ErrTypeError
	}
	_bdfg.BitsPerComponent = _bbbea
	_bceab = _acbaa.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _bceab == nil {
		_bcd.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_bbbea, _ebff = _bceab.(*_df.PdfObjectInteger)
	if !_ebff {
		_bcd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _bceab)
		return nil, _df.ErrTypeError
	}
	_bdfg.BitsPerComponent = _bbbea
	_bceab = _acbaa.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _bceab == nil {
		_bcd.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_gaegb, _ebff := _bceab.(*_df.PdfObjectArray)
	if !_ebff {
		_bcd.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _bceab)
		return nil, _df.ErrTypeError
	}
	_bdfg.Decode = _gaegb
	if _gbgcf := _acbaa.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _gbgcf != nil {
		_bdfg.Function = []PdfFunction{}
		if _gfdge, _ddgga := _gbgcf.(*_df.PdfObjectArray); _ddgga {
			for _, _faaea := range _gfdge.Elements() {
				_bcafe, _bbfda := _ddaac(_faaea)
				if _bbfda != nil {
					_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _bbfda)
					return nil, _bbfda
				}
				_bdfg.Function = append(_bdfg.Function, _bcafe)
			}
		} else {
			_bgbga, _dgbc := _ddaac(_gbgcf)
			if _dgbc != nil {
				_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _dgbc)
				return nil, _dgbc
			}
			_bdfg.Function = append(_bdfg.Function, _bgbga)
		}
	}
	return &_bdfg, nil
}

// ToPdfObject converts the K dictionary to a PDF object.
func (_bddeg *KDict) ToPdfObject() _df.PdfObject {
	_fbgeg := _df.MakeDict()
	if _bddeg.ID != nil {
		_fbgeg.Set("\u0049\u0044", _bddeg.ID)
	}
	if _bddeg.K != nil {
		_fbgeg.Set("\u004b", _bddeg.K)
	} else if len(_bddeg._dacfd) > 0 {
		if len(_bddeg._dacfd) == 1 {
			_bddeg.K = _bddeg._dacfd[0].ToPdfObject()
		} else {
			_ddfec := _df.MakeArray()
			for _, _bafgc := range _bddeg._dacfd {
				_ddfec.Append(_bafgc.ToPdfObject())
			}
			_bddeg.K = _ddfec
		}
		_fbgeg.Set("\u004b", _bddeg.K)
	}
	if _bddeg.S != nil {
		_fbgeg.Set("\u0053", _bddeg.S)
	}
	if _bddeg.P != nil {
		_fbgeg.Set("\u0050", _bddeg.P)
	}
	if _bddeg.Pg != nil {
		_fbgeg.Set("\u0050\u0067", _bddeg.Pg)
	}
	if _bddeg.C != nil {
		_fbgeg.Set("\u0043", _bddeg.C)
	}
	if _bddeg.R != nil {
		_fbgeg.Set("\u0052", _bddeg.R)
	}
	if _bddeg.T != nil {
		_fbgeg.Set("\u0054", _bddeg.T)
	}
	if _bddeg.Lang != nil {
		_fbgeg.Set("\u004c\u0061\u006e\u0067", _bddeg.Lang)
	}
	if _bddeg.Alt != nil {
		_fbgeg.Set("\u0041\u006c\u0074", _bddeg.Alt)
	}
	if _bddeg.E != nil {
		_fbgeg.Set("\u0045", _bddeg.E)
	}
	if _bddeg.A != nil {
		_fbgeg.Set("\u0041", _bddeg.A)
	} else if _bddeg._bcbaeb != nil {
		_bgee := _df.MakeArrayFromFloats([]float64{_bddeg._bcbaeb.Llx, _bddeg._bcbaeb.Lly, _bddeg._bcbaeb.Urx, _bddeg._bcbaeb.Ury})
		_gcddce := _df.MakeDict()
		_gcddce.Set("\u0042\u0042\u006f\u0078", _bgee)
		_gcddce.Set("\u004f", _df.MakeString("\u004c\u0061\u0079\u006f\u0075\u0074"))
		_fbgeg.Set("\u0041", _df.MakeIndirectObject(_gcddce))
	}
	if _bddeg.ActualText != nil {
		_fbgeg.Set("\u0041\u0063\u0074\u0075\u0061\u006c\u0054\u0065\u0078\u0074", _bddeg.ActualText)
	}
	if _bddeg.E != nil {
		_fbgeg.Set("\u0045", _bddeg.E)
	}
	if _bddeg.Alt != nil {
		_fbgeg.Set("\u0041\u006c\u0074", _bddeg.Alt)
	}
	return _fbgeg
}

// NewPdfColorspaceSpecialIndexed returns a new Indexed color.
func NewPdfColorspaceSpecialIndexed() *PdfColorspaceSpecialIndexed {
	return &PdfColorspaceSpecialIndexed{HiVal: 255}
}

// WriteToFile writes the output PDF to file.
func (_aefg *PdfWriter) WriteToFile(outputFilePath string) error {
	_efcbba, _fbbfe := _bf.Create(outputFilePath)
	if _fbbfe != nil {
		return _fbbfe
	}
	defer _efcbba.Close()
	return _aefg.Write(_efcbba)
}

// NewPdfColorDeviceRGB returns a new PdfColorDeviceRGB based on the r,g,b component values.
func NewPdfColorDeviceRGB(r, g, b float64) *PdfColorDeviceRGB {
	_dabe := PdfColorDeviceRGB{r, g, b}
	return &_dabe
}

func (_aadc *PdfReader) loadAction(_becd _df.PdfObject) (*PdfAction, error) {
	if _egg, _ffbfg := _df.GetIndirect(_becd); _ffbfg {
		_afcb, _dgcg := _aadc.newPdfActionFromIndirectObject(_egg)
		if _dgcg != nil {
			return nil, _dgcg
		}
		return _afcb, nil
	} else if !_df.IsNullObject(_becd) {
		return nil, _deb.New("\u0061\u0063\u0074\u0069\u006fn\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0070\u006f\u0069\u006e\u0074 \u0074\u006f\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	return nil, nil
}

// PdfAnnotationHighlight represents Highlight annotations.
// (Section 12.5.6.10).
type PdfAnnotationHighlight struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _df.PdfObject
}

// PdfReader represents a PDF file reader. It is a frontend to the lower level parsing mechanism and provides
// a higher level access to work with PDF structure and information, such as the page structure etc.
type PdfReader struct {
	_gfdaag  *_df.PdfParser
	_fbbegf  _df.PdfObject
	_gaadg   *_df.PdfIndirectObject
	_dfcf    *_df.PdfObjectDictionary
	_dcfee   []*_df.PdfIndirectObject
	PageList []*PdfPage
	_dgcgb   int
	_afbaf   *_df.PdfObjectDictionary
	_baaeg   *PdfOutlineTreeNode
	AcroForm *PdfAcroForm
	DSS      *DSS
	Rotate   *int64
	_eaeee   *Permissions
	_aefcd   map[*PdfReader]*PdfReader
	_cbga    []*PdfReader
	_ceggc   *modelManager
	_edbbdf  bool
	_eebc    map[_df.PdfObject]struct{}
	_fbacd   _bdd.ReadSeeker
	_bdcaa   string
	_caece   bool
	_effbb   string
	_cbcee   *ReaderOpts
	_aeec    bool
}

// Evaluate runs the function on the passed in slice and returns the results.
func (_dgaa *PdfFunctionType3) Evaluate(x []float64) ([]float64, error) {
	if len(x) != 1 {
		_bcd.Log.Error("\u004f\u006e\u006c\u0079 o\u006e\u0065\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0061\u006c\u006c\u006f\u0077e\u0064")
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	return nil, _deb.New("\u006e\u006f\u0074\u0020im\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074")
}

func (_dcdb *PdfReader) newPdfAnnotationStrikeOut(_eeba *_df.PdfObjectDictionary) (*PdfAnnotationStrikeOut, error) {
	_dabcc := PdfAnnotationStrikeOut{}
	_gdba, _dgge := _dcdb.newPdfAnnotationMarkupFromDict(_eeba)
	if _dgge != nil {
		return nil, _dgge
	}
	_dabcc.PdfAnnotationMarkup = _gdba
	_dabcc.QuadPoints = _eeba.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_dabcc, nil
}

// Write writes the Appender output to io.Writer.
// It can only be called once and further invocations will result in an error.
func (_dacae *PdfAppender) Write(w _bdd.Writer) error {
	if _dacae._gafb {
		return _deb.New("\u0061\u0070\u0070\u0065\u006e\u0064\u0065\u0072\u0020\u0077\u0072\u0069\u0074e\u0020\u0063\u0061\u006e\u0020\u006fn\u006c\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0076\u006f\u006b\u0065\u0064 \u006f\u006e\u0063\u0065")
	}
	_dgce := NewPdfWriter()
	_bgaa, _cffa := _df.GetDict(_dgce._ggdac)
	if !_cffa {
		return _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0020(\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0029")
	}
	_gedb, _cffa := _bgaa.Get("\u004b\u0069\u0064\u0073").(*_df.PdfObjectArray)
	if !_cffa {
		return _deb.New("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0050\u0061g\u0065\u0073\u0020\u004b\u0069\u0064\u0073\u0020o\u0062\u006a\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079\u0029")
	}
	_bfff, _cffa := _bgaa.Get("\u0043\u006f\u0075n\u0074").(*_df.PdfObjectInteger)
	if !_cffa {
		return _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u0050\u0061\u0067e\u0073\u0020\u0043\u006fu\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0029")
	}
	_fef := _dacae._abf._gfdaag
	_fded := _fef.GetTrailer()
	if _fded == nil {
		return _deb.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072")
	}
	_cefe, _cffa := _df.GetIndirect(_fded.Get("\u0052\u006f\u006f\u0074"))
	if !_cffa {
		return _deb.New("c\u0061\u0074\u0061\u006c\u006f\u0067 \u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064")
	}
	_fdf, _cffa := _df.GetDict(_cefe)
	if !_cffa {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0028\u0072\u006f\u006f\u0074\u0020\u0025\u0071\u0029\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u0020\u0025\u0073\u0029", _cefe, *_fded)
		return _deb.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	_dbee := false
	for _, _ffeb := range _dacae._abf.AcroForm.signatureFields() {
		if _ffeb.Lock != nil {
			_dbee = true
			break
		}
	}
	if _dbee {
		_dgce._aaag = _cefe
	}
	for _, _fdcc := range _fdf.Keys() {
		if _dgce._gdee.Get(_fdcc) == nil {
			_eacc := _fdf.Get(_fdcc)
			_dgce._gdee.Set(_fdcc, _eacc)
		}
	}
	if _dacae._ffe != nil {
		if _dacae._ffe._caead {
			if _baaeb := _df.TraceToDirectObject(_dacae._ffe.ToPdfObject()); !_df.IsNullObject(_baaeb) {
				_dgce._gdee.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _baaeb)
				_dacae.updateObjectsDeep(_baaeb, nil)
			} else {
				_bcd.Log.Debug("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020t\u0072\u0061\u0063e\u0020\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u0020o\u0062\u006a\u0065\u0063\u0074, \u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u002e")
			}
		} else {
			_dgce._gdee.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _dacae._ffe.ToPdfObject())
			_dacae.updateObjectsDeep(_dacae._ffe.ToPdfObject(), nil)
		}
	}
	if _dacae._cgebag != nil {
		_dacae.updateObjectsDeep(_dacae._cgebag.ToPdfObject(), nil)
		_dgce._gdee.Set("\u0044\u0053\u0053", _dacae._cgebag.GetContainingPdfObject())
	}
	if _dacae._gfedf != nil {
		_dgce._gdee.Set("\u0050\u0065\u0072m\u0073", _dacae._gfedf.ToPdfObject())
		_dacae.updateObjectsDeep(_dacae._gfedf.ToPdfObject(), nil)
	}
	if _dgce._aeffd.Major < 2 {
		_dgce.AddExtension("\u0045\u0053\u0049\u0043", "\u0031\u002e\u0037", 5)
		_dgce.AddExtension("\u0041\u0044\u0042\u0045", "\u0031\u002e\u0037", 8)
	}
	if _bbdaf, _aega := _df.GetDict(_fded.Get("\u0049\u006e\u0066\u006f")); _aega {
		if _cfce, _bffa := _df.GetDict(_dgce._caefe); _bffa {
			for _, _gbda := range _bbdaf.Keys() {
				if _cfce.Get(_gbda) == nil {
					_cfce.Set(_gbda, _bbdaf.Get(_gbda))
				}
			}
		}
	}
	if _dacae._fbdb != nil {
		_dgce._caefe = _df.MakeIndirectObject(_dacae._fbdb.ToPdfObject())
	}
	_dacae.updateObjectsDeep(_dgce._caefe, nil)
	_dacae.updateObjectsDeep(_dgce._aaag, nil)
	_fecc := false
	if len(_dacae._abf.PageList) != len(_dacae._dgac) {
		_fecc = true
	} else {
		for _edbg := range _dacae._abf.PageList {
			switch {
			case _dacae._dgac[_edbg] == _dacae._abf.PageList[_edbg]:
			case _dacae._dgac[_edbg] == _dacae.Reader.PageList[_edbg]:
			default:
				_fecc = true
			}
			if _fecc {
				break
			}
		}
	}
	if _fecc {
		_dacae.updateObjectsDeep(_dgce._ggdac, nil)
	} else {
		_dacae._bbba[_dgce._ggdac] = struct{}{}
	}
	_dgce._ggdac.ObjectNumber = _dacae.Reader._gaadg.ObjectNumber
	_dacae._aggf[_dgce._ggdac] = _dacae.Reader._gaadg.ObjectNumber
	_cddg := []_df.PdfObjectName{"\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", "\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", "\u0043r\u006f\u0070\u0042\u006f\u0078", "\u0052\u006f\u0074\u0061\u0074\u0065"}
	for _, _fga := range _dacae._dgac {
		_gbcg := _fga.ToPdfObject()
		*_bfff = *_bfff + 1
		if _afbg, _ddea := _gbcg.(*_df.PdfIndirectObject); _ddea && _afbg.GetParser() == _dacae._abf._gfdaag {
			_gedb.Append(&_afbg.PdfObjectReference)
			continue
		}
		if _bcdd, _gaed := _df.GetDict(_gbcg); _gaed {
			_bgfb, _cbae := _bcdd.Get("\u0050\u0061\u0072\u0065\u006e\u0074").(*_df.PdfIndirectObject)
			for _cbae {
				_bcd.Log.Trace("\u0050a\u0067e\u0020\u0050\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _bgfb)
				_ggdc, _affd := _bgfb.PdfObject.(*_df.PdfObjectDictionary)
				if !_affd {
					return _deb.New("i\u006e\u0076\u0061\u006cid\u0020P\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
				}
				for _, _dfad := range _cddg {
					_bcd.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _dfad)
					if _dbbg := _bcdd.Get(_dfad); _dbbg != nil {
						_bcd.Log.Trace("\u002d \u0070a\u0067\u0065\u0020\u0068\u0061s\u0020\u0061l\u0072\u0065\u0061\u0064\u0079")
						if len(_fga._agacd.Keys()) > 0 && !_fecc {
							_ffcc := _fga._agacd
							if _agef := _ffcc.Get(_dfad); _agef != nil {
								if _dbbg != _agef {
									_bcd.Log.Trace("\u0049\u006e\u0068\u0065\u0072\u0069\u0074\u0069\u006e\u0067\u0020\u006f\u0072\u0069\u0067i\u006ea\u006c\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073\u002c\u0020\u0025\u0054", _dfad, _agef)
									_bcdd.Set(_dfad, _agef)
								}
							}
						}
						continue
					}
					if _gdaaf := _ggdc.Get(_dfad); _gdaaf != nil {
						_bcd.Log.Trace("\u0049\u006e\u0068\u0065ri\u0074\u0069\u006e\u0067\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _dfad)
						_bcdd.Set(_dfad, _gdaaf)
					}
				}
				_bgfb, _cbae = _ggdc.Get("\u0050\u0061\u0072\u0065\u006e\u0074").(*_df.PdfIndirectObject)
				_bcd.Log.Trace("\u004ee\u0078t\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _ggdc.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
			}
			if _fecc {
				_bcdd.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _dgce._ggdac)
			}
		}
		_dacae.updateObjectsDeep(_gbcg, nil)
		_gedb.Append(_gbcg)
	}
	if _, _bafg := _dacae._fggb.Seek(0, _bdd.SeekStart); _bafg != nil {
		return _bafg
	}
	_dcbcb := make(map[SignatureHandler]_bdd.Writer)
	_edebb := _df.MakeArray()
	for _, _afcg := range _dacae._eaad {
		if _fcfe, _fgfa := _df.GetIndirect(_afcg); _fgfa {
			if _beafg, _dbaaf := _fcfe.PdfObject.(*pdfSignDictionary); _dbaaf {
				_cfgc := *_beafg._dabb
				var _ddgfb error
				_dcbcb[_cfgc], _ddgfb = _cfgc.NewDigest(_beafg._gbbba)
				if _ddgfb != nil {
					return _ddgfb
				}
				_edebb.Append(_df.MakeInteger(0xfffff), _df.MakeInteger(0xfffff))
			}
		}
	}
	if _edebb.Len() > 0 {
		_edebb.Append(_df.MakeInteger(0xfffff), _df.MakeInteger(0xfffff))
	}
	for _, _dgcge := range _dacae._eaad {
		if _eefbb, _cgbg := _df.GetIndirect(_dgcge); _cgbg {
			if _ebaf, _eegd := _eefbb.PdfObject.(*pdfSignDictionary); _eegd {
				_ebaf.Set("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e", _edebb)
			}
		}
	}
	_efc := len(_dcbcb) > 0
	var _abbdd _bdd.Reader = _dacae._fggb
	if _efc {
		_gfae := make([]_bdd.Writer, 0, len(_dcbcb))
		for _, _bdea := range _dcbcb {
			_gfae = append(_gfae, _bdea)
		}
		_abbdd = _bdd.TeeReader(_dacae._fggb, _bdd.MultiWriter(_gfae...))
	}
	_bbdb, _gdcc := _bdd.Copy(w, _abbdd)
	if _gdcc != nil {
		return _gdcc
	}
	if len(_dacae._eaad) == 0 {
		return nil
	}
	_dgce._bcfff = _bbdb
	_dgce.ObjNumOffset = _dacae._eadb
	_dgce._gebfg = true
	_dgce._cbgfg = _dacae._bagc
	_dgce._ebfcba = _dacae._cfeb
	_dgce._acfdce = _dacae._bfgee
	_dgce._aeffd = _dacae._abf.PdfVersion()
	_dgce._gbga = _dacae._aggf
	_dgce._fcdg = _dacae._gecd.GetCrypter()
	_dgce._deega = _dacae._gecd.GetEncryptObj()
	_abgc := _dacae._gecd.GetXrefType()
	if _abgc != nil {
		_cdged := *_abgc == _df.XrefTypeObjectStream
		_dgce._ccbfe = &_cdged
	}
	_dgce._aadfbg = map[_df.PdfObject]struct{}{}
	_dgce._ceeac = []_df.PdfObject{}
	for _, _dfbc := range _dacae._eaad {
		if _, _bdece := _dacae._bbba[_dfbc]; _bdece {
			continue
		}
		_dgce.addObject(_dfbc)
	}
	_fab := w
	if _efc {
		_fab = _ef.NewBuffer(nil)
	}
	if _dacae._aadbf != "" && _dgce._fcdg == nil {
		_dgce.Encrypt([]byte(_dacae._aadbf), []byte(_dacae._aadbf), _dacae._aeg)
	}
	if _deae := _fded.Get("\u0049\u0044"); _deae != nil {
		if _debb, _deac := _df.GetArray(_deae); _deac {
			_dgce._fgdf = _debb
		}
	}
	if _gbg := _dgce.Write(_fab); _gbg != nil {
		return _gbg
	}
	if _efc {
		_cgac := _fab.(*_ef.Buffer).Bytes()
		_fbb := _df.MakeArray()
		var _fgffc []*pdfSignDictionary
		var _bgaaf int64
		for _, _cfecg := range _dgce._ceeac {
			if _cacg, _dfdf := _df.GetIndirect(_cfecg); _dfdf {
				if _fgad, _fcbg := _cacg.PdfObject.(*pdfSignDictionary); _fcbg {
					_fgffc = append(_fgffc, _fgad)
					_eaaa := _fgad._ebeeda + int64(_fgad._gcfcd)
					_fbb.Append(_df.MakeInteger(_bgaaf), _df.MakeInteger(_eaaa-_bgaaf))
					_bgaaf = _fgad._ebeeda + int64(_fgad._ecbd)
				}
			}
		}
		_fbb.Append(_df.MakeInteger(_bgaaf), _df.MakeInteger(_bbdb+int64(len(_cgac))-_bgaaf))
		_begb := []byte(_fbb.WriteString())
		for _, _fbcd := range _fgffc {
			_bfgf := int(_fbcd._ebeeda - _bbdb)
			for _fggg := _fbcd._ddfde; _fggg < _fbcd._dffg; _fggg++ {
				_cgac[_bfgf+_fggg] = ' '
			}
			_fdbf := _cgac[_bfgf+_fbcd._ddfde : _bfgf+_fbcd._dffg]
			copy(_fdbf, _begb)
		}
		var _fedcc int
		for _, _fgbdb := range _fgffc {
			_fcgc := int(_fgbdb._ebeeda - _bbdb)
			_cebf := _cgac[_fedcc : _fcgc+_fgbdb._gcfcd]
			_gfad := *_fgbdb._dabb
			_dcbcb[_gfad].Write(_cebf)
			_fedcc = _fcgc + _fgbdb._ecbd
		}
		for _, _aeebb := range _fgffc {
			_afgb := _cgac[_fedcc:]
			_bfec := *_aeebb._dabb
			_dcbcb[_bfec].Write(_afgb)
		}
		for _, _bfbgb := range _fgffc {
			_ggfd := int(_bfbgb._ebeeda - _bbdb)
			_aegd := *_bfbgb._dabb
			_eddd := _dcbcb[_aegd]
			if _dgff := _aegd.Sign(_bfbgb._gbbba, _eddd); _dgff != nil {
				return _dgff
			}
			_bfbgb._gbbba.ByteRange = _fbb
			_dfef := []byte(_bfbgb._gbbba.Contents.WriteString())
			for _fdgd := _bfbgb._ddfde; _fdgd < _bfbgb._dffg; _fdgd++ {
				_cgac[_ggfd+_fdgd] = ' '
			}
			for _gebb := _bfbgb._gcfcd; _gebb < _bfbgb._ecbd; _gebb++ {
				_cgac[_ggfd+_gebb] = ' '
			}
			_agca := _cgac[_ggfd+_bfbgb._ddfde : _ggfd+_bfbgb._dffg]
			copy(_agca, _begb)
			_agca = _cgac[_ggfd+_bfbgb._gcfcd : _ggfd+_bfbgb._ecbd]
			copy(_agca, _dfef)
		}
		_dgee := _ef.NewBuffer(_cgac)
		_, _gdcc = _bdd.Copy(w, _dgee)
		if _gdcc != nil {
			return _gdcc
		}
	}
	_dacae._gafb = true
	return nil
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_faadc *PdfColorspaceSpecialPattern) ToPdfObject() _df.PdfObject {
	if _faadc.UnderlyingCS == nil {
		return _df.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e")
	}
	_gfeg := _df.MakeArray(_df.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e"))
	_gfeg.Append(_faadc.UnderlyingCS.ToPdfObject())
	if _faadc._gbee != nil {
		_faadc._gbee.PdfObject = _gfeg
		return _faadc._gbee
	}
	return _gfeg
}

// FieldFlattenOpts defines a set of options which can be used to configure
// the field flattening process.
type FieldFlattenOpts struct {

	// FilterFunc allows filtering the form fields used in the flattening
	// process. If the filter function returns true, the field is flattened,
	// otherwise it is skipped.
	// If a non-terminal field is discarded, all of its children (the fields
	// present in the Kids array) are discarded as well.
	// Non-terminal fields are kept in the AcroForm if one or more of their
	// child fields have not been selected for flattening.
	// If a filter function is not provided, all form fields are flattened.
	FilterFunc FieldFilterFunc

	// AnnotFilterFunc allows filtering the annotations in the flattening
	// process. If the filter function returns true, the annotation is flattened,
	// otherwise it is skipped.
	AnnotFilterFunc AnnotFilterFunc
}

// GenerateRandomID generates a random ID for the K dictionary object.
func (_cbcff *KDict) GenerateRandomID() string {
	_deefag, _fabadg := _aa.NewUUID()
	if _fabadg != nil {
		_bcd.Log.Debug("\u0045r\u0072\u006f\u0072\u0020g\u0065\u006e\u0065\u0072\u0061t\u0069n\u0067 \u0055\u0055\u0049\u0044\u003a\u0020\u0025v", _fabadg)
	}
	if _deefag != _aa.Nil {
		_bfgbd := _deefag.String()
		_cbcff.ID = _df.MakeString(_bfgbd)
		return _bfgbd
	}
	return ""
}

func (_afaab *PdfWriter) checkLicense() error {
	_aadeaf := _abc.GetLicenseKey()
	if (_aadeaf == nil || !_aadeaf.IsLicensed()) && !_ddgae {
		_c.Printf("\u0055\u006e\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0064\u0020c\u006f\u0070\u0079\u0020\u006f\u0066\u0020\u0055\u006e\u0069P\u0044\u0046\u000a")
		_c.Println("-\u0020\u0047\u0065\u0074\u0020\u0061\u0020\u0066\u0072e\u0065\u0020\u0074\u0072\u0069\u0061\u006c l\u0069\u0063\u0065\u006es\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070s:\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
		return _deb.New("\u0075\u006e\u0069\u0070d\u0066\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020c\u006fd\u0065\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0064")
	}
	return nil
}

func (_daee *PdfColorspaceDeviceRGB) String() string {
	return "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B"
}

// ParserMetadata gets the parser  metadata.
func (_gcfag *CompliancePdfReader) ParserMetadata() _df.ParserMetadata {
	if _gcfag._deegf == (_df.ParserMetadata{}) {
		_gcfag._deegf, _ = _gcfag._gfdaag.ParserMetadata()
	}
	return _gcfag._deegf
}

// GetNumComponents returns the number of color components (4 for CMYK32).
func (_gdcd *PdfColorDeviceCMYK) GetNumComponents() int { return 4 }

// ToPdfObject implements interface PdfModel.
func (_bcf *PdfActionGoToR) ToPdfObject() _df.PdfObject {
	_bcf.PdfAction.ToPdfObject()
	_cgf := _bcf._gcf
	_eag := _cgf.PdfObject.(*_df.PdfObjectDictionary)
	_eag.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeGoToR)))
	if _bcf.F != nil {
		_eag.Set("\u0046", _bcf.F.ToPdfObject())
	}
	_eag.SetIfNotNil("\u0044", _bcf.D)
	_eag.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _bcf.NewWindow)
	return _cgf
}

func (_bcgc *pdfFontSimple) baseFields() *fontCommon { return &_bcgc.fontCommon }

func (_faddd *pdfFontSimple) getFontDescriptor() *PdfFontDescriptor {
	if _egcac := _faddd._agggb; _egcac != nil {
		return _egcac
	}
	return _faddd._abegg
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for an RGB device.
func (_bggg *PdfColorspaceDeviceRGB) GetNumComponents() int { return 3 }

// SetPrintScaling sets the value of the printScaling.
func (_fgeca *ViewerPreferences) SetPrintScaling(printScaling PrintScaling) {
	_fgeca._faefa = printScaling
}

// Val returns the value of the color.
func (_adag *PdfColorCalGray) Val() float64 { return float64(*_adag) }

// PdfActionSound represents a sound action.
type PdfActionSound struct {
	*PdfAction
	Sound       _df.PdfObject
	Volume      _df.PdfObject
	Synchronous _df.PdfObject
	Repeat      _df.PdfObject
	Mix         _df.PdfObject
}

func (_dbdg *PdfReader) newPdfAnnotationCircleFromDict(_fgb *_df.PdfObjectDictionary) (*PdfAnnotationCircle, error) {
	_fadg := PdfAnnotationCircle{}
	_eba, _afb := _dbdg.newPdfAnnotationMarkupFromDict(_fgb)
	if _afb != nil {
		return nil, _afb
	}
	_fadg.PdfAnnotationMarkup = _eba
	_fadg.BS = _fgb.Get("\u0042\u0053")
	_fadg.IC = _fgb.Get("\u0049\u0043")
	_fadg.BE = _fgb.Get("\u0042\u0045")
	_fadg.RD = _fgb.Get("\u0052\u0044")
	return &_fadg, nil
}

// ToPdfObject implements interface PdfModel.
func (_dge *PdfActionThread) ToPdfObject() _df.PdfObject {
	_dge.PdfAction.ToPdfObject()
	_dgc := _dge._gcf
	_agge := _dgc.PdfObject.(*_df.PdfObjectDictionary)
	_agge.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeThread)))
	if _dge.F != nil {
		_agge.Set("\u0046", _dge.F.ToPdfObject())
	}
	_agge.SetIfNotNil("\u0044", _dge.D)
	_agge.SetIfNotNil("\u0042", _dge.B)
	return _dgc
}

// GetOutlineTree returns the outline tree.
func (_bbaaf *PdfReader) GetOutlineTree() *PdfOutlineTreeNode { return _bbaaf._baaeg }

// AddKDict adds a K dictionary object to the structure tree root.
func (_ebdeg *StructTreeRoot) AddKDict(k *KDict) { _ebdeg.K = append(_ebdeg.K, k) }

// WatermarkTextOptions contains options for configuring the text watermark process.
type WatermarkTextOptions struct {

	// opacity, 0.5 by default.
	Alpha float64

	// font size, 20 by default.
	FontSize float64

	// it is mandatory to set FontPath to the path of .ttf font file you would like to use for drawing.
	FontPath string

	// font color, black by default.
	FontColor _b.Color

	// rotation angle in degrees, 0 by default.
	Angle float64
}

// ToPdfObject implements interface PdfModel.
func (_bcea *PdfAnnotationWatermark) ToPdfObject() _df.PdfObject {
	_bcea.PdfAnnotation.ToPdfObject()
	_bgbf := _bcea._bfde
	_beae := _bgbf.PdfObject.(*_df.PdfObjectDictionary)
	_beae.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k"))
	_beae.SetIfNotNil("\u0046\u0069\u0078\u0065\u0064\u0050\u0072\u0069\u006e\u0074", _bcea.FixedPrint)
	return _bgbf
}

// GetNumComponents returns the number of color components (1 for Indexed).
func (_bcgeb *PdfColorspaceSpecialIndexed) GetNumComponents() int { return 1 }

// SignatureHandler interface defines the common functionality for PDF signature handlers, which
// need to be capable of validating digital signatures and signing PDF documents.
type SignatureHandler interface {

	// IsApplicable checks if a given signature dictionary `sig` is applicable for the signature handler.
	// For example a signature of type `adbe.pkcs7.detached` might not fit for a rsa.sha1 handler.
	IsApplicable(_ceaef *PdfSignature) bool

	// Validate validates a PDF signature against a given digest (hash) such as that determined
	// for an input file. Returns validation results.
	Validate(_edafg *PdfSignature, _cgbdba Hasher) (SignatureValidationResult, error)

	// InitSignature prepares the signature dictionary for signing. This involves setting all
	// necessary fields, and also allocating sufficient space to the Contents so that the
	// finalized signature can be inserted once the hash is calculated.
	InitSignature(_bgaec *PdfSignature) error

	// NewDigest creates a new digest/hasher based on the signature dictionary and handler.
	NewDigest(_ggdfb *PdfSignature) (Hasher, error)

	// Sign receives the hash `digest` (for example hash of an input file), and signs based
	// on the signature dictionary `sig` and applies the signature data to the signature
	// dictionary Contents field.
	Sign(_ccbbb *PdfSignature, _eaaed Hasher) error
}

// AppendContentStream adds content stream by string.  Appends to the last
// contentstream instance if many.
func (_debcdc *PdfPage) AppendContentStream(contentStr string) error {
	_fbfgg, _adcaf := _debcdc.GetContentStreams()
	if _adcaf != nil {
		return _adcaf
	}
	if len(_fbfgg) == 0 {
		_fbfgg = []string{contentStr}
		return _debcdc.SetContentStreams(_fbfgg, _df.NewFlateEncoder())
	}
	var _eaadb _ef.Buffer
	_eaadb.WriteString(_fbfgg[len(_fbfgg)-1])
	_eaadb.WriteString("\u000a")
	_eaadb.WriteString(contentStr)
	_fbfgg[len(_fbfgg)-1] = _eaadb.String()
	return _debcdc.SetContentStreams(_fbfgg, _df.NewFlateEncoder())
}

var _cbcf = map[string]struct{}{"\u0046\u0054": {}, "\u004b\u0069\u0064\u0073": {}, "\u0054": {}, "\u0054\u0055": {}, "\u0054\u004d": {}, "\u0046\u0066": {}, "\u0056": {}, "\u0044\u0056": {}, "\u0041\u0041": {}, "\u0044\u0041": {}, "\u0051": {}, "\u0044\u0053": {}, "\u0052\u0056": {}}

// GetPrimitiveFromModel returns the primitive object corresponding to the input `model`.
func (_ddcg *modelManager) GetPrimitiveFromModel(model PdfModel) _df.PdfObject {
	_facc, _dggaa := _ddcg._cebgf[model]
	if !_dggaa {
		return nil
	}
	return _facc
}

// ConvertToBinary converts current image into binary (bi-level) format.
// Binary images are composed of single bits per pixel (only black or white).
// If provided image has more color components, then it would be converted into binary image using
// histogram auto threshold function.
func (_edee *Image) ConvertToBinary() error {
	if _edee.ColorComponents == 1 && _edee.BitsPerComponent == 1 {
		return nil
	}
	_bdfca, _fafbg := _edee.ToGoImage()
	if _fafbg != nil {
		return _fafbg
	}
	_ffgdc, _fafbg := _bge.MonochromeConverter.Convert(_bdfca)
	if _fafbg != nil {
		return _fafbg
	}
	_edee.Data = _ffgdc.Base().Data
	_edee._gebab, _fafbg = _bge.ScaleAlphaToMonochrome(_edee._gebab, int(_edee.Width), int(_edee.Height))
	if _fafbg != nil {
		return _fafbg
	}
	_edee.BitsPerComponent = 1
	_edee.ColorComponents = 1
	_edee._bebgb = nil
	return nil
}

// NewPdfActionSubmitForm returns a new "submit form" action.
func NewPdfActionSubmitForm() *PdfActionSubmitForm {
	_gb := NewPdfAction()
	_ea := &PdfActionSubmitForm{}
	_ea.PdfAction = _gb
	_gb.SetContext(_ea)
	return _ea
}

// HasFontByName checks if has font resource by name.
func (_ddadf *PdfPage) HasFontByName(name _df.PdfObjectName) bool {
	_gbfcf, _caacd := _ddadf.Resources.Font.(*_df.PdfObjectDictionary)
	if !_caacd {
		return false
	}
	if _cfbbb := _gbfcf.Get(name); _cfbbb != nil {
		return true
	}
	return false
}

func (_fcbe *PdfReader) newPdfActionGotoEFromDict(_geg *_df.PdfObjectDictionary) (*PdfActionGoToE, error) {
	_gea, _dedf := _cadf(_geg.Get("\u0046"))
	if _dedf != nil {
		return nil, _dedf
	}
	return &PdfActionGoToE{D: _geg.Get("\u0044"), NewWindow: _geg.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), T: _geg.Get("\u0054"), F: _gea}, nil
}

func _bfgbg(_bdedb *_df.PdfObjectDictionary) (*PdfShadingType3, error) {
	_ebfebb := PdfShadingType3{}
	_acfbf := _bdedb.Get("\u0043\u006f\u006f\u0072\u0064\u0073")
	if _acfbf == nil {
		_bcd.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0043\u006f\u006f\u0072\u0064\u0073")
		return nil, ErrRequiredAttributeMissing
	}
	_agbdd, _bafeb := _acfbf.(*_df.PdfObjectArray)
	if !_bafeb {
		_bcd.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _acfbf)
		return nil, _df.ErrTypeError
	}
	if _agbdd.Len() != 6 {
		_bcd.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0036\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _agbdd.Len())
		return nil, ErrInvalidAttribute
	}
	_ebfebb.Coords = _agbdd
	if _gaegg := _bdedb.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _gaegg != nil {
		_gaegg = _df.TraceToDirectObject(_gaegg)
		_gacef, _baggg := _gaegg.(*_df.PdfObjectArray)
		if !_baggg {
			_bcd.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _gaegg)
			return nil, _df.ErrTypeError
		}
		_ebfebb.Domain = _gacef
	}
	_acfbf = _bdedb.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _acfbf == nil {
		_bcd.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_ebfebb.Function = []PdfFunction{}
	if _aedfbf, _dcbb := _acfbf.(*_df.PdfObjectArray); _dcbb {
		for _, _deggfg := range _aedfbf.Elements() {
			_egffc, _bdegb := _ddaac(_deggfg)
			if _bdegb != nil {
				_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _bdegb)
				return nil, _bdegb
			}
			_ebfebb.Function = append(_ebfebb.Function, _egffc)
		}
	} else {
		_egfdc, _aaceg := _ddaac(_acfbf)
		if _aaceg != nil {
			_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _aaceg)
			return nil, _aaceg
		}
		_ebfebb.Function = append(_ebfebb.Function, _egfdc)
	}
	if _cggef := _bdedb.Get("\u0045\u0078\u0074\u0065\u006e\u0064"); _cggef != nil {
		_cggef = _df.TraceToDirectObject(_cggef)
		_ggcfc, _ffbag := _cggef.(*_df.PdfObjectArray)
		if !_ffbag {
			_bcd.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _cggef)
			return nil, _df.ErrTypeError
		}
		if _ggcfc.Len() != 2 {
			_bcd.Log.Debug("\u0045\u0078\u0074\u0065n\u0064\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _ggcfc.Len())
			return nil, ErrInvalidAttribute
		}
		_ebfebb.Extend = _ggcfc
	}
	return &_ebfebb, nil
}

// GetPdfVersion gets the version of the PDF used within this document.
func (_fcgga *PdfWriter) GetPdfVersion() string { return _fcgga.getPdfVersion() }

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 1 for a CalGray device.
func (_dcc *PdfColorspaceCalGray) GetNumComponents() int { return 1 }

// ToPdfObject converts PdfAcroForm to a PdfObject, i.e. an indirect object containing the
// AcroForm dictionary.
func (_badab *PdfAcroForm) ToPdfObject() _df.PdfObject {
	_abbcd := _badab._cffeg
	_fgcb := _abbcd.PdfObject.(*_df.PdfObjectDictionary)
	if _badab.Fields != nil {
		_ggeda := _df.PdfObjectArray{}
		for _, _ebgge := range *_badab.Fields {
			_baddg := _ebgge.GetContext()
			if _baddg != nil {
				_ggeda.Append(_baddg.ToPdfObject())
			} else {
				_ggeda.Append(_ebgge.ToPdfObject())
			}
		}
		_fgcb.Set("\u0046\u0069\u0065\u006c\u0064\u0073", &_ggeda)
	}
	if _badab.NeedAppearances != nil {
		_fgcb.Set("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073", _badab.NeedAppearances)
	} else {
		if _ccfd := _fgcb.Get("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073"); _ccfd != nil {
			_fgcb.Remove("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073")
		}
	}
	if _badab.SigFlags != nil {
		_fgcb.Set("\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073", _badab.SigFlags)
	}
	if _badab.CO != nil {
		_fgcb.Set("\u0043\u004f", _badab.CO)
	}
	if _badab.DR != nil {
		_fgcb.Set("\u0044\u0052", _badab.DR.ToPdfObject())
	}
	if _badab.DA != nil {
		_fgcb.Set("\u0044\u0041", _badab.DA)
	}
	if _badab.Q != nil {
		_fgcb.Set("\u0051", _badab.Q)
	}
	if _badab.XFA != nil {
		_fgcb.Set("\u0058\u0046\u0041", _badab.XFA)
	}
	if _badab.ADBEEchoSign != nil {
		_fgcb.Set("\u0041\u0044\u0042\u0045\u005f\u0045\u0063\u0068\u006f\u0053\u0069\u0067\u006e", _badab.ADBEEchoSign)
	}
	return _abbcd
}

func (_agfae *PdfReader) loadAnnotations(_aeccg _df.PdfObject) ([]*PdfAnnotation, error) {
	_cfbag, _gdcea := _df.GetArray(_aeccg)
	if !_gdcea {
		return nil, _c.Errorf("\u0041\u006e\u006e\u006fts\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	var _bcdcc []*PdfAnnotation
	for _, _abgff := range _cfbag.Elements() {
		_abgff = _df.ResolveReference(_abgff)
		if _, _cggb := _abgff.(*_df.PdfObjectNull); _cggb {
			continue
		}
		_gccee, _cgafd := _abgff.(*_df.PdfObjectDictionary)
		_cdgeg, _agbe := _abgff.(*_df.PdfIndirectObject)
		if _cgafd {
			_cdgeg = &_df.PdfIndirectObject{}
			_cdgeg.PdfObject = _gccee
		} else {
			if !_agbe {
				return nil, _c.Errorf("\u0061\u006eno\u0074\u0061\u0074i\u006f\u006e\u0020\u006eot \u0069n \u0061\u006e\u0020\u0069\u006e\u0064\u0069re\u0063\u0074\u0020\u006f\u0062\u006a\u0065c\u0074")
			}
		}
		_bged, _cdfag := _agfae.newPdfAnnotationFromIndirectObject(_cdgeg)
		if _cdfag != nil {
			return nil, _cdfag
		}
		switch _geff := _bged.GetContext().(type) {
		case *PdfAnnotationWidget:
			for _, _efcdd := range _agfae.AcroForm.AllFields() {
				if _efcdd._cdbc == _geff.Parent {
					_geff._aeaf = _efcdd
					break
				}
			}
		}
		if _bged != nil {
			_bcdcc = append(_bcdcc, _bged)
		}
	}
	return _bcdcc, nil
}

// ViewArea returns the value of the viewArea.
func (_dbgcf *ViewerPreferences) ViewArea() PageBoundary { return _dbgcf._ffbad }

// ToPdfObject returns the PDF representation of the colorspace.
func (_bbea *PdfColorspaceDeviceCMYK) ToPdfObject() _df.PdfObject {
	return _df.MakeName("\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b")
}

// A PdfPattern can represent a Pattern, either a tiling pattern or a shading pattern.
// Note that all patterns shall be treated as colours; a Pattern colour space shall be established with the CS or cs
// operator just like other colour spaces, and a particular pattern shall be installed as the current colour with the
// SCN or scn operator.
type PdfPattern struct {

	// Type: Pattern
	PatternType int64
	_ecfde      PdfModel
	_cbce       _df.PdfObject
}

func (_ddf *PdfReader) newPdfAnnotationTrapNetFromDict(_eaab *_df.PdfObjectDictionary) (*PdfAnnotationTrapNet, error) {
	_cda := PdfAnnotationTrapNet{}
	return &_cda, nil
}

// M returns the value of the magenta component of the color.
func (_fbgge *PdfColorDeviceCMYK) M() float64 { return _fbgge[1] }

// GetPageLabels returns the PageLabels entry in the PDF catalog.
// See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
func (_beegf *PdfReader) GetPageLabels() (_df.PdfObject, error) {
	_agebd := _df.ResolveReference(_beegf._afbaf.Get("\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006c\u0073"))
	if _agebd == nil {
		return nil, nil
	}
	if !_beegf._edbbdf {
		_bedcd := _beegf.traverseObjectData(_agebd)
		if _bedcd != nil {
			return nil, _bedcd
		}
	}
	return _agebd, nil
}

func (_caede *PdfWriter) hasObject(_fddff _df.PdfObject) bool {
	_, _acdgg := _caede._aadfbg[_fddff]
	return _acdgg
}

// GetColorspaces loads PdfPageResourcesColorspaces from `r.ColorSpace` and returns an error if there
// is a problem loading. Once loaded, the same object is returned on multiple calls.
func (_gffa *PdfPageResources) GetColorspaces() (*PdfPageResourcesColorspaces, error) {
	if _gffa._eafae != nil {
		return _gffa._eafae, nil
	}
	if _gffa.ColorSpace == nil {
		return nil, nil
	}
	_abcgb, _decea := _caeab(_gffa.ColorSpace)
	if _decea != nil {
		return nil, _decea
	}
	_gffa._eafae = _abcgb
	return _gffa._eafae, nil
}

func (_cbfgf *PdfWriter) writeBytes(_caceg []byte) {
	if _cbfgf._bbecc != nil {
		return
	}
	_cdfe, _aadca := _cbfgf._cfddc.Write(_caceg)
	_cbfgf._afeab += int64(_cdfe)
	_cbfgf._bbecc = _aadca
}

func _abfbgf(_dfbff _df.PdfObject) (*PdfShading, error) {
	_fedcg := &PdfShading{}
	var _cdcgf *_df.PdfObjectDictionary
	if _aadgc, _abfcg := _df.GetIndirect(_dfbff); _abfcg {
		_fedcg._bgdag = _aadgc
		_cdfca, _agabb := _aadgc.PdfObject.(*_df.PdfObjectDictionary)
		if !_agabb {
			_bcd.Log.Debug("\u004f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074i\u006f\u006e\u0061\u0072\u0079\u0020\u0074y\u0070\u0065")
			return nil, _df.ErrTypeError
		}
		_cdcgf = _cdfca
	} else if _ggdd, _gfbea := _df.GetStream(_dfbff); _gfbea {
		_fedcg._bgdag = _ggdd
		_cdcgf = _ggdd.PdfObjectDictionary
	} else if _eaade, _fecg := _df.GetDict(_dfbff); _fecg {
		_fedcg._bgdag = _eaade
		_cdcgf = _eaade
	} else {
		_bcd.Log.Debug("O\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0075\u006e\u0065\u0078\u0070e\u0063\u0074\u0065d\u0020(\u0025\u0054\u0029", _dfbff)
		return nil, _df.ErrTypeError
	}
	if _cdcgf == nil {
		_bcd.Log.Debug("\u0044i\u0063t\u0069\u006f\u006e\u0061\u0072y\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, _deb.New("\u0064\u0069\u0063t\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_dfbff = _cdcgf.Get("S\u0068\u0061\u0064\u0069\u006e\u0067\u0054\u0079\u0070\u0065")
	if _dfbff == nil {
		_bcd.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065\u0064\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u0020\u006d\u0069\u0073si\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_dfbff = _df.TraceToDirectObject(_dfbff)
	_agbagg, _geaeg := _dfbff.(*_df.PdfObjectInteger)
	if !_geaeg {
		_bcd.Log.Debug("\u0049\u006e\u0076al\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0066o\u0072 \u0073h\u0061d\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _dfbff)
		return nil, _df.ErrTypeError
	}
	if *_agbagg < 1 || *_agbagg > 7 {
		_bcd.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u002c\u0020\u006e\u006ft\u0020\u0031\u002d\u0037\u0020(\u0067\u006ft\u0020\u0025\u0064\u0029", *_agbagg)
		return nil, _df.ErrTypeError
	}
	_fedcg.ShadingType = _agbagg
	_dfbff = _cdcgf.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065")
	if _dfbff == nil {
		_bcd.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072e\u0064\u0020\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065\u0020e\u006e\u0074\u0072\u0079\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_bagb, _aceaf := NewPdfColorspaceFromPdfObject(_dfbff)
	if _aceaf != nil {
		_bcd.Log.Debug("\u0046\u0061i\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065: \u0025\u0076", _aceaf)
		return nil, _aceaf
	}
	_fedcg.ColorSpace = _bagb
	_dfbff = _cdcgf.Get("\u0042\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064")
	if _dfbff != nil {
		_dfbff = _df.TraceToDirectObject(_dfbff)
		_gcdeg, _efbfe := _dfbff.(*_df.PdfObjectArray)
		if !_efbfe {
			_bcd.Log.Debug("\u0042\u0061\u0063\u006b\u0067r\u006f\u0075\u006e\u0064\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _dfbff)
			return nil, _df.ErrTypeError
		}
		_fedcg.Background = _gcdeg
	}
	_dfbff = _cdcgf.Get("\u0042\u0042\u006f\u0078")
	if _dfbff != nil {
		_dfbff = _df.TraceToDirectObject(_dfbff)
		_ebfg, _dcffc := _dfbff.(*_df.PdfObjectArray)
		if !_dcffc {
			_bcd.Log.Debug("\u0042\u0061\u0063\u006b\u0067r\u006f\u0075\u006e\u0064\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _dfbff)
			return nil, _df.ErrTypeError
		}
		_gdeg, _bdcfc := NewPdfRectangle(*_ebfg)
		if _bdcfc != nil {
			_bcd.Log.Debug("\u0042\u0042\u006f\u0078\u0020\u0065\u0072\u0072\u006fr\u003a\u0020\u0025\u0076", _bdcfc)
			return nil, _bdcfc
		}
		_fedcg.BBox = _gdeg
	}
	_dfbff = _cdcgf.Get("\u0041n\u0074\u0069\u0041\u006c\u0069\u0061s")
	if _dfbff != nil {
		_dfbff = _df.TraceToDirectObject(_dfbff)
		_eggeb, _gfefa := _dfbff.(*_df.PdfObjectBool)
		if !_gfefa {
			_bcd.Log.Debug("A\u006e\u0074\u0069\u0041\u006c\u0069\u0061\u0073\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020ty\u0070\u0065\u002c\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020bo\u006f\u006c \u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _dfbff)
			return nil, _df.ErrTypeError
		}
		_fedcg.AntiAlias = _eggeb
	}
	switch *_agbagg {
	case 1:
		_aecdg, _fgacgd := _efdeb(_cdcgf)
		if _fgacgd != nil {
			return nil, _fgacgd
		}
		_aecdg.PdfShading = _fedcg
		_fedcg._dggab = _aecdg
		return _fedcg, nil
	case 2:
		_baede, _cegd := _ebabc(_cdcgf)
		if _cegd != nil {
			return nil, _cegd
		}
		_baede.PdfShading = _fedcg
		_fedcg._dggab = _baede
		return _fedcg, nil
	case 3:
		_adgc, _efca := _bfgbg(_cdcgf)
		if _efca != nil {
			return nil, _efca
		}
		_adgc.PdfShading = _fedcg
		_fedcg._dggab = _adgc
		return _fedcg, nil
	case 4:
		_aeccd, _gfgff := _gacff(_cdcgf)
		if _gfgff != nil {
			return nil, _gfgff
		}
		_aeccd.PdfShading = _fedcg
		_fedcg._dggab = _aeccd
		return _fedcg, nil
	case 5:
		_becdcd, _cebgcg := _ccbcb(_cdcgf)
		if _cebgcg != nil {
			return nil, _cebgcg
		}
		_becdcd.PdfShading = _fedcg
		_fedcg._dggab = _becdcd
		return _fedcg, nil
	case 6:
		_afdgc, _facag := _acgee(_cdcgf)
		if _facag != nil {
			return nil, _facag
		}
		_afdgc.PdfShading = _fedcg
		_fedcg._dggab = _afdgc
		return _fedcg, nil
	case 7:
		_gbaec, _edbce := _gcge(_cdcgf)
		if _edbce != nil {
			return nil, _edbce
		}
		_gbaec.PdfShading = _fedcg
		_fedcg._dggab = _gbaec
		return _fedcg, nil
	}
	return nil, _deb.New("u\u006ek\u006e\u006f\u0077\u006e\u0020\u0073\u0068\u0061d\u0069\u006e\u0067\u0020ty\u0070\u0065")
}

func _ecdad(_fedbd *_df.PdfObjectStream) (*PdfFunctionType0, error) {
	_gbgc := &PdfFunctionType0{}
	_gbgc._faec = _fedbd
	_dcbd := _fedbd.PdfObjectDictionary
	_aeegg, _becef := _df.TraceToDirectObject(_dcbd.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_df.PdfObjectArray)
	if !_becef {
		_bcd.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _deb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _aeegg.Len() < 0 || _aeegg.Len()%2 != 0 {
		_bcd.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _deb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_gbgc.NumInputs = _aeegg.Len() / 2
	_ccefg, _ffacb := _aeegg.ToFloat64Array()
	if _ffacb != nil {
		return nil, _ffacb
	}
	_gbgc.Domain = _ccefg
	_aeegg, _becef = _df.TraceToDirectObject(_dcbd.Get("\u0052\u0061\u006eg\u0065")).(*_df.PdfObjectArray)
	if !_becef {
		_bcd.Log.Error("\u0052\u0061\u006e\u0067e \u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064")
		return nil, _deb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _aeegg.Len() < 0 || _aeegg.Len()%2 != 0 {
		return nil, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_gbgc.NumOutputs = _aeegg.Len() / 2
	_cdcgd, _ffacb := _aeegg.ToFloat64Array()
	if _ffacb != nil {
		return nil, _ffacb
	}
	_gbgc.Range = _cdcgd
	_aeegg, _becef = _df.TraceToDirectObject(_dcbd.Get("\u0053\u0069\u007a\u0065")).(*_df.PdfObjectArray)
	if !_becef {
		_bcd.Log.Error("\u0053i\u007ae\u0020\u006e\u006f\u0074\u0020s\u0070\u0065c\u0069\u0066\u0069\u0065\u0064")
		return nil, _deb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_fgba, _ffacb := _aeegg.ToIntegerArray()
	if _ffacb != nil {
		return nil, _ffacb
	}
	if len(_fgba) != _gbgc.NumInputs {
		_bcd.Log.Error("T\u0061\u0062\u006c\u0065\u0020\u0073\u0069\u007a\u0065\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0074\u0063h\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072 o\u0066\u0020\u0069n\u0070u\u0074\u0073")
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gbgc.Size = _fgba
	_cedgda, _becef := _df.TraceToDirectObject(_dcbd.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0053\u0061\u006d\u0070\u006c\u0065")).(*_df.PdfObjectInteger)
	if !_becef {
		_bcd.Log.Error("B\u0069\u0074\u0073\u0050\u0065\u0072S\u0061\u006d\u0070\u006c\u0065\u0020\u006e\u006f\u0074 \u0073\u0070\u0065c\u0069f\u0069\u0065\u0064")
		return nil, _deb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if *_cedgda != 1 && *_cedgda != 2 && *_cedgda != 4 && *_cedgda != 8 && *_cedgda != 12 && *_cedgda != 16 && *_cedgda != 24 && *_cedgda != 32 {
		_bcd.Log.Error("\u0042\u0069\u0074s \u0070\u0065\u0072\u0020\u0073\u0061\u006d\u0070\u006ce\u0020o\u0075t\u0073i\u0064\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064\u0029", *_cedgda)
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gbgc.BitsPerSample = int(*_cedgda)
	_gbgc.Order = 1
	_efbgf, _becef := _df.TraceToDirectObject(_dcbd.Get("\u004f\u0072\u0064e\u0072")).(*_df.PdfObjectInteger)
	if _becef {
		if *_efbgf != 1 && *_efbgf != 3 {
			_bcd.Log.Error("\u0049n\u0076a\u006c\u0069\u0064\u0020\u006fr\u0064\u0065r\u0020\u0028\u0025\u0064\u0029", *_efbgf)
			return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
		}
		_gbgc.Order = int(*_efbgf)
	}
	_aeegg, _becef = _df.TraceToDirectObject(_dcbd.Get("\u0045\u006e\u0063\u006f\u0064\u0065")).(*_df.PdfObjectArray)
	if _becef {
		_fcegc, _ebgga := _aeegg.ToFloat64Array()
		if _ebgga != nil {
			return nil, _ebgga
		}
		_gbgc.Encode = _fcegc
	}
	_aeegg, _becef = _df.TraceToDirectObject(_dcbd.Get("\u0044\u0065\u0063\u006f\u0064\u0065")).(*_df.PdfObjectArray)
	if _becef {
		_ggfdf, _deggf := _aeegg.ToFloat64Array()
		if _deggf != nil {
			return nil, _deggf
		}
		_gbgc.Decode = _ggfdf
	}
	_ggedf, _ffacb := _df.DecodeStream(_fedbd)
	if _ffacb != nil {
		return nil, _ffacb
	}
	_gbgc._egba = _ggedf
	return _gbgc, nil
}

func _aedef(_gbdg string) map[string]string {
	_bcfbf := _bface.Split(_gbdg, -1)
	_fedcb := map[string]string{}
	for _, _dgebb := range _bcfbf {
		_caaag := _feafa.FindStringSubmatch(_dgebb)
		if _caaag == nil {
			continue
		}
		_ebfcf, _ega := _caaag[1], _caaag[2]
		_fedcb[_ebfcf] = _ega
	}
	return _fedcb
}

func _dbgf(_acdf *_df.PdfObjectDictionary) (*PdfFieldButton, error) {
	_beec := &PdfFieldButton{}
	_beec.PdfField = NewPdfField()
	_beec.PdfField.SetContext(_beec)
	_beec.Opt, _ = _df.GetArray(_acdf.Get("\u004f\u0070\u0074"))
	_bgae := NewPdfAnnotationWidget()
	_bgae.A, _ = _df.GetDict(_acdf.Get("\u0041"))
	_bgae.AP, _ = _df.GetDict(_acdf.Get("\u0041\u0050"))
	_bgae.SetContext(_beec)
	_beec.PdfField.Annotations = append(_beec.PdfField.Annotations, _bgae)
	return _beec, nil
}

// PdfAnnotationProjection represents Projection annotations.
type PdfAnnotationProjection struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
}

// GetObjectNums returns the object numbers of the PDF objects in the file
// Numbered objects are either indirect objects or stream objects.
// e.g. objNums := pdfReader.GetObjectNums()
// The underlying objects can then be accessed with
// pdfReader.GetIndirectObjectByNumber(objNums[0]) for the first available object.
func (_fcga *PdfReader) GetObjectNums() []int { return _fcga._gfdaag.GetObjectNums() }

// NewCompositePdfFontFromTTF loads a composite TTF font. Composite fonts can
// be used to represent unicode fonts which can have multi-byte character codes, representing a wide
// range of values. They are often used for symbolic languages, including Chinese, Japanese and Korean.
// It is represented by a Type0 Font with an underlying CIDFontType2 and an Identity-H encoding map.
// TODO: May be extended in the future to support a larger variety of CMaps and vertical fonts.
// NOTE: For simple fonts, use NewPdfFontFromTTF.
func NewCompositePdfFontFromTTF(r _bdd.ReadSeeker) (*PdfFont, error) {
	_gefab, _bfefe := _bdd.ReadAll(r)
	if _bfefe != nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074s\u003a\u0020\u0025\u0076", _bfefe)
		return nil, _bfefe
	}
	_addfg, _bfefe := _da.TtfParse(_ef.NewReader(_gefab))
	if _bfefe != nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067 \u0074\u0074\u0066\u0020\u0066\u006f\u006et\u003a\u0020\u0025\u0076", _bfefe)
		return nil, _bfefe
	}
	_cbad := &pdfCIDFontType2{fontCommon: fontCommon{_fgfae: "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032"}, CIDToGIDMap: _df.MakeName("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079")}
	if len(_addfg.Widths) <= 0 {
		return nil, _deb.New("\u0045\u0052\u0052O\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u0028\u0057\u0069\u0064\u0074\u0068\u0073\u0029")
	}
	_efdgg := 1000.0 / float64(_addfg.UnitsPerEm)
	_eecd := _efdgg * float64(_addfg.Widths[0])
	_bffea := make(map[rune]int)
	_dedg := make(map[_da.GID]int)
	_ccdg := _da.GID(len(_addfg.Widths))
	for _fbbf, _addd := range _addfg.Chars {
		if _addd > _ccdg-1 {
			continue
		}
		_aaefg := int(_efdgg * float64(_addfg.Widths[_addd]))
		_bffea[_fbbf] = _aaefg
		_dedg[_addd] = _aaefg
	}
	_cbad._dbcecg = _bffea
	_cbad.DW = _df.MakeInteger(int64(_eecd))
	_afea := _caged(_dedg, uint16(_ccdg))
	_cbad.W = _df.MakeIndirectObject(_afea)
	_gcedf := _df.MakeDict()
	_gcedf.Set("\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067", _df.MakeString("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"))
	_gcedf.Set("\u0052\u0065\u0067\u0069\u0073\u0074\u0072\u0079", _df.MakeString("\u0041\u0064\u006fb\u0065"))
	_gcedf.Set("\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074", _df.MakeInteger(0))
	_cbad.CIDSystemInfo = _gcedf
	_acce := &PdfFontDescriptor{FontName: _df.MakeName(_addfg.PostScriptName), Ascent: _df.MakeFloat(_efdgg * float64(_addfg.TypoAscender)), Descent: _df.MakeFloat(_efdgg * float64(_addfg.TypoDescender)), CapHeight: _df.MakeFloat(_efdgg * float64(_addfg.CapHeight)), FontBBox: _df.MakeArrayFromFloats([]float64{_efdgg * float64(_addfg.Xmin), _efdgg * float64(_addfg.Ymin), _efdgg * float64(_addfg.Xmax), _efdgg * float64(_addfg.Ymax)}), ItalicAngle: _df.MakeFloat(_addfg.ItalicAngle), MissingWidth: _df.MakeFloat(_eecd)}
	_degf, _bfefe := _df.MakeStream(_gefab, _df.NewFlateEncoder())
	if _bfefe != nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074o\u0020m\u0061\u006b\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _bfefe)
		return nil, _bfefe
	}
	_degf.PdfObjectDictionary.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _df.MakeInteger(int64(len(_gefab))))
	_acce.FontFile2 = _degf
	if _addfg.Bold {
		_acce.StemV = _df.MakeInteger(120)
	} else {
		_acce.StemV = _df.MakeInteger(70)
	}
	_edfb := _gfbe
	if _addfg.IsFixedPitch {
		_edfb |= _cfef
	}
	if _addfg.ItalicAngle != 0 {
		_edfb |= _aacc
	}
	_acce.Flags = _df.MakeInteger(int64(_edfb))
	_cbad._gddcf = _addfg.PostScriptName
	_cbad._agggb = _acce
	_fcfbg := pdfFontType0{fontCommon: fontCommon{_fgfae: "\u0054\u0079\u0070e\u0030", _gddcf: _addfg.PostScriptName}, DescendantFont: &PdfFont{_eaeg: _cbad}, Encoding: _df.MakeName("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0048"), _gdbg: _addfg.NewEncoder()}
	if len(_addfg.Chars) > 0 {
		_afaf := make(map[_dgf.CharCode]rune, len(_addfg.Chars))
		for _caba, _ecdbc := range _addfg.Chars {
			_eeea := _dgf.CharCode(_ecdbc)
			if _fgcgg, _efbbe := _afaf[_eeea]; !_efbbe || (_efbbe && _fgcgg > _caba) {
				_afaf[_eeea] = _caba
			}
		}
		_fcfbg._afcbd = _dgf.NewToUnicodeCMap(_afaf)
	}
	_cccag := PdfFont{_eaeg: &_fcfbg}
	return &_cccag, nil
}

// SetViewArea sets the value of the viewArea.
func (_gfec *ViewerPreferences) SetViewArea(viewArea PageBoundary) { _gfec._ffbad = viewArea }

func (_dabce *pdfFontType0) baseFields() *fontCommon { return &_dabce.fontCommon }

// NewPdfActionLaunch returns a new "launch" action.
func NewPdfActionLaunch() *PdfActionLaunch {
	_dgd := NewPdfAction()
	_gd := &PdfActionLaunch{}
	_gd.PdfAction = _dgd
	_dgd.SetContext(_gd)
	return _gd
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// component PDF objects.
func (_gaegc *PdfColorspaceICCBased) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if _gaegc.Alternate == nil {
		if _gaegc.N == 1 {
			_gcdd := NewPdfColorspaceDeviceGray()
			return _gcdd.ColorFromPdfObjects(objects)
		} else if _gaegc.N == 3 {
			_deaf := NewPdfColorspaceDeviceRGB()
			return _deaf.ColorFromPdfObjects(objects)
		} else if _gaegc.N == 4 {
			_gafgb := NewPdfColorspaceDeviceCMYK()
			return _gafgb.ColorFromPdfObjects(objects)
		} else {
			return nil, _deb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	return _gaegc.Alternate.ColorFromPdfObjects(objects)
}

// PrintScaling represents the page scaling option that shall be selected
// when a print dialog is displayed for this document.
type PrintScaling string

// SetType sets the field button's type.  Can be one of:
// - PdfFieldButtonPush for push button fields
// - PdfFieldButtonCheckbox for checkbox fields
// - PdfFieldButtonRadio for radio button fields
// This sets the field's flag appropriately.
func (_ecdc *PdfFieldButton) SetType(btype ButtonType) {
	_daab := uint32(0)
	if _ecdc.Ff != nil {
		_daab = uint32(*_ecdc.Ff)
	}
	switch btype {
	case ButtonTypePush:
		_daab |= FieldFlagPushbutton.Mask()
	case ButtonTypeRadio:
		_daab |= FieldFlagRadio.Mask()
	}
	_ecdc.Ff = _df.MakeInteger(int64(_daab))
}

// PdfColorPatternType2 represents a color shading pattern type 2 (Axial).
type PdfColorPatternType2 struct {
	Color       PdfColor
	PatternName _df.PdfObjectName
}

// AddImageResource adds an image to the XObject resources.
func (_dcbca *PdfPage) AddImageResource(name _df.PdfObjectName, ximg *XObjectImage) error {
	var _eadag *_df.PdfObjectDictionary
	if _dcbca.Resources.XObject == nil {
		_eadag = _df.MakeDict()
		_dcbca.Resources.XObject = _eadag
	} else {
		var _dcegg bool
		_eadag, _dcegg = (_dcbca.Resources.XObject).(*_df.PdfObjectDictionary)
		if !_dcegg {
			return _deb.New("\u0069\u006e\u0076\u0061li\u0064\u0020\u0078\u0072\u0065\u0073\u0020\u0064\u0069\u0063\u0074\u0020\u0074\u0079p\u0065")
		}
	}
	_eadag.Set(name, ximg.ToPdfObject())
	return nil
}

func _cbdee(_ccfbc string) (string, error) {
	var _eebdg _ef.Buffer
	_eebdg.WriteString(_ccfbc)
	_gbagf := make([]byte, 8+16)
	_dcbdb := _fa.Now().UTC().UnixNano()
	_bd.BigEndian.PutUint64(_gbagf, uint64(_dcbdb))
	_, _cdeed := _ge.Read(_gbagf[8:])
	if _cdeed != nil {
		return "", _cdeed
	}
	_eebdg.WriteString(_ab.EncodeToString(_gbagf))
	return _eebdg.String(), nil
}

func (_fbbd *PdfPage) removeXObj(_afgc *_df.PdfObjectDictionary, _efddc _df.PdfObjectName) {
	_afgc.Remove(_efddc)
	_cfcdc := _df.NewFlateEncoder()
	_efgae := _fbbd.GetContentStreamObjs()
	_aafd := _df.MakeArray()
	for _, _feec := range _efgae {
		_ebbdc, _ := _fcdf(_feec)
		if _gc.Contains(_ebbdc, _efddc.String()) {
			_eecdb := _gc.Index(_ebbdc, _efddc.String())
			_egfd := _gc.LastIndex(_ebbdc[:_eecdb], "\u0071")
			_dagfg := _gc.Index(_ebbdc[_eecdb:], "\u0051") + _eecdb + 1
			if _egfd >= 0 && _dagfg >= 0 {
				var _bfefd _gc.Builder
				_bfefd.WriteString(_ebbdc[:_egfd])
				_bfefd.WriteString(_ebbdc[_dagfg:])
				_accdaa, _gedbgd := _df.MakeStream([]byte(_bfefd.String()), _cfcdc)
				if _gedbgd == nil {
					_aafd.Append(_accdaa)
					continue
				}
			}
		}
		_aafd.Append(_feec)
	}
	_fbbd.Contents = _aafd
}

// Set applies flag fl to the flag's bitmask and returns the combined flag.
func (_gedbg FieldFlag) Set(fl FieldFlag) FieldFlag { return FieldFlag(_gedbg.Mask() | fl.Mask()) }

func _adab(_eefde _df.PdfObject, _cddge _df.PdfObject, _bfdgg map[_df.PdfObject][]_df.PdfObject, _eaaca map[string]_df.PdfObject, _dfcgb *[]_df.PdfObject) {
	var _adddf *_df.PdfIndirectObject
	if _bffbc, _cbfde := _df.GetIndirect(_eefde); _cbfde {
		_adddf = _bffbc
		_eefde = _bffbc.PdfObject
	}
	switch _eace := _eefde.(type) {
	case *_df.PdfObjectDictionary:
		if _eace.Get("\u0053") == nil {
			return
		}
		_eace.Set("\u0050", _cddge)
		if _fbbfb := _eace.Get("\u0050\u0067"); _fbbfb != nil {
			if _gfebb, _ffad := _df.GetIndirect(_fbbfb); _ffad && _gfebb != nil && _gfebb.PdfObject != nil {
				_bfdgg[_fbbfb] = append(_bfdgg[_fbbfb], _adddf)
			}
		}
		if _fegfe := _eace.Get("\u0053"); _fegfe != nil {
			if _bfcba, _ggfecg := _df.GetNameVal(_fegfe); _ggfecg {
				if _bfcba == StructureTypeLink {
					if _ecgcf := _eace.Get("\u004b"); _ecgcf != nil {
						if _gffag, _abac := _df.GetArray(_ecgcf); _abac && _gffag.Len() == 2 {
							_cccg := false
							_egecc := false
							for _, _eefdg := range _gffag.Elements() {
								if _afeg, _bebbd := _df.GetDict(_eefdg); _bebbd {
									if _eccea, _gcabf := _df.GetName(_afeg.Get("\u0054\u0079\u0070\u0065")); _gcabf && _eccea.String() == "\u004f\u0042\u004a\u0052" {
										_egecc = true
									}
								} else if _, _cbgdf := _df.GetInt(_eefdg); _cbgdf {
									_cccg = true
								}
							}
							if _cccg && _egecc {
								*_dfcgb = append(*_dfcgb, _adddf)
							}
						} else if _cbdcg, _fcdd := _df.GetDict(_ecgcf); _fcdd {
							if _cbcafd, _dgfed := _df.GetName(_cbdcg.Get("\u0054\u0079\u0070\u0065")); _dgfed && _cbcafd.String() == "\u004f\u0042\u004a\u0052" {
								*_dfcgb = append(*_dfcgb, _adddf)
							}
						}
					}
				}
			}
		}
		if _gggeg := _eace.Get("\u0049\u0044"); _gggeg != nil {
			_eaaca[_gggeg.String()] = _eefde
		}
		if _cfgac := _eace.Get("\u004b"); _cfgac != nil {
			_adab(_cfgac, _adddf, _bfdgg, _eaaca, _dfcgb)
		}
	case *_df.PdfObjectArray:
		for _, _eagcg := range _eace.Elements() {
			_adab(_eagcg, _cddge, _bfdgg, _eaaca, _dfcgb)
		}
	default:
	}
}

// NewPdfActionMovie returns a new "movie" action.
func NewPdfActionMovie() *PdfActionMovie {
	_fc := NewPdfAction()
	_dfd := &PdfActionMovie{}
	_dfd.PdfAction = _fc
	_fc.SetContext(_dfd)
	return _dfd
}

// Tab order types.
type TabOrderType string

// ColorFromPdfObjects loads the color from PDF objects.
// The first objects (if present) represent the color in underlying colorspace.  The last one represents
// the name of the pattern.
func (_gdgd *PdfColorspaceSpecialPattern) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if len(objects) < 1 {
		return nil, _deb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066 \u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072\u0073")
	}
	_fgbg := &PdfColorPattern{}
	_ggee, _ggfa := objects[len(objects)-1].(*_df.PdfObjectName)
	if !_ggfa {
		_bcd.Log.Debug("\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020a\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", objects[len(objects)-1])
		return nil, ErrTypeCheck
	}
	_fgbg.PatternName = *_ggee
	if len(objects) > 1 {
		_aada := objects[0 : len(objects)-1]
		if _gdgd.UnderlyingCS == nil {
			_bcd.Log.Debug("P\u0061\u0074t\u0065\u0072\u006e\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0077\u0069\u0074\u0068\u0020\u0064\u0065\u0066\u0069\u006ee\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u0020\u0062\u0075\u0074\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079i\u006e\u0067\u0020\u0063\u0073\u0020\u006d\u0069\u0073\u0073\u0069n\u0067")
			return nil, _deb.New("\u0075n\u0064\u0065\u0072\u006cy\u0069\u006e\u0067\u0020\u0043S\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d")
		}
		_daad, _degc := _gdgd.UnderlyingCS.ColorFromPdfObjects(_aada)
		if _degc != nil {
			_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0076\u0069\u0061\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079\u0069\u006e\u0067\u0020\u0063\u0073\u003a\u0020\u0025\u0076", _degc)
			return nil, _degc
		}
		_fgbg.Color = _daad
	}
	return _fgbg, nil
}

// PdfShadingPatternType3 is shading patterns that will use a Type 3 shading pattern (Radial).
type PdfShadingPatternType3 struct {
	*PdfPattern
	Shading   *PdfShadingType3
	Matrix    *_df.PdfObjectArray
	ExtGState _df.PdfObject
}

func (_gbdcg *pdfFontType0) subsetRegistered() error {
	_ffebg, _adad := _gbdcg.DescendantFont._eaeg.(*pdfCIDFontType2)
	if !_adad {
		_bcd.Log.Debug("\u0046\u006fnt\u0020\u006e\u006ft\u0020\u0073\u0075\u0070por\u0074ed\u0020\u0066\u006f\u0072\u0020\u0073\u0075bs\u0065\u0074\u0074\u0069\u006e\u0067\u0020%\u0054", _gbdcg.DescendantFont)
		return nil
	}
	if _ffebg == nil {
		return nil
	}
	if _ffebg._agggb == nil {
		_bcd.Log.Debug("\u004d\u0069\u0073si\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u006f\u0072")
		return nil
	}
	if _gbdcg._gdbg == nil {
		_bcd.Log.Debug("\u004e\u006f\u0020e\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0073\u0075\u0062s\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u0067\u006e\u006f\u0072\u0065\u0064")
		return nil
	}
	_eagb, _adad := _df.GetStream(_ffebg._agggb.FontFile2)
	if !_adad {
		_bcd.Log.Debug("\u0045\u006d\u0062\u0065\u0064\u0064\u0065\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u002d\u002d\u0020\u0041\u0042\u004f\u0052T\u0020\u0073\u0075\u0062\u0073\u0065\u0074\u0074\u0069\u006e\u0067")
		return _deb.New("\u0066\u006f\u006e\u0074fi\u006c\u0065\u0032\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	_efdf, _ccca := _df.DecodeStream(_eagb)
	if _ccca != nil {
		_bcd.Log.Debug("\u0044\u0065c\u006f\u0064\u0065 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076", _ccca)
		return _ccca
	}
	_afadg, _ccca := _cf.Parse(_ef.NewReader(_efdf))
	if _ccca != nil {
		_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0064\u0020\u0062\u0079\u0074\u0065\u0020f\u006f\u006e\u0074", len(_eagb.Stream))
		return _ccca
	}
	var _eebb []rune
	var _gaaad *_cf.Font
	switch _bead := _gbdcg._gdbg.(type) {
	case *_abg.TrueTypeFontEncoder:
		_eebb = _bead.RegisteredRunes()
		_gaaad, _ccca = _afadg.SubsetKeepRunes(_eebb)
		if _ccca != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ccca)
			return _ccca
		}
		_bead.SubsetRegistered()
	case *_abg.IdentityEncoder:
		_eebb = _bead.RegisteredRunes()
		_bdfe := make([]_cf.GlyphIndex, len(_eebb))
		for _cfcea, _dfea := range _eebb {
			_bdfe[_cfcea] = _cf.GlyphIndex(_dfea)
		}
		_gaaad, _ccca = _afadg.SubsetKeepIndices(_bdfe)
		if _ccca != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ccca)
			return _ccca
		}
	case _abg.SimpleEncoder:
		_efae := _bead.Charcodes()
		for _, _fdbce := range _efae {
			_bggbd, _edbgg := _bead.CharcodeToRune(_fdbce)
			if !_edbgg {
				_bcd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0020\u0074\u006f \u0072\u0075\u006e\u0065\u003a\u0020\u0025\u0064", _fdbce)
				continue
			}
			_eebb = append(_eebb, _bggbd)
		}
	default:
		return _c.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020s\u0075\u0062\u0073\u0065\u0074t\u0069\u006eg\u003a\u0020\u0025\u0054", _gbdcg._gdbg)
	}
	var _deaec _ef.Buffer
	_ccca = _gaaad.Write(&_deaec)
	if _ccca != nil {
		_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ccca)
		return _ccca
	}
	if _gbdcg._afcbd != nil {
		_cacb := make(map[_dgf.CharCode]rune, len(_eebb))
		for _, _acag := range _eebb {
			_fbef, _edebg := _gbdcg._gdbg.RuneToCharcode(_acag)
			if !_edebg {
				continue
			}
			_cacb[_dgf.CharCode(_fbef)] = _acag
		}
		_gbdcg._afcbd = _dgf.NewToUnicodeCMap(_cacb)
	}
	_eagb, _ccca = _df.MakeStream(_deaec.Bytes(), _df.NewFlateEncoder())
	if _ccca != nil {
		_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ccca)
		return _ccca
	}
	_eagb.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _df.MakeInteger(int64(_deaec.Len())))
	if _effc, _fcfdg := _df.GetStream(_ffebg._agggb.FontFile2); _fcfdg {
		*_effc = *_eagb
	} else {
		_ffebg._agggb.FontFile2 = _eagb
	}
	_daffa := _cfbc()
	if len(_gbdcg._gddcf) > 0 {
		_gbdcg._gddcf = _gfegf(_gbdcg._gddcf, _daffa)
	}
	if len(_ffebg._gddcf) > 0 {
		_ffebg._gddcf = _gfegf(_ffebg._gddcf, _daffa)
	}
	if len(_gbdcg._ggad) > 0 {
		_gbdcg._ggad = _gfegf(_gbdcg._ggad, _daffa)
	}
	if _ffebg._agggb != nil {
		_gbead, _ccabg := _df.GetName(_ffebg._agggb.FontName)
		if _ccabg && len(_gbead.String()) > 0 {
			_ebge := _gfegf(_gbead.String(), _daffa)
			_ffebg._agggb.FontName = _df.MakeName(_ebge)
		}
	}
	return nil
}

// PdfActionResetForm represents a resetForm action.
type PdfActionResetForm struct {
	*PdfAction
	Fields _df.PdfObject
	Flags  _df.PdfObject
}

// GetRevision returns the specific version of the PdfReader for the current Pdf document
func (_cccb *PdfReader) GetRevision(revisionNumber int) (*PdfReader, error) {
	_dbcfc := _cccb._gfdaag.GetRevisionNumber()
	if revisionNumber < 0 || revisionNumber > _dbcfc {
		return nil, _deb.New("w\u0072\u006f\u006e\u0067 r\u0065v\u0069\u0073\u0069\u006f\u006e \u006e\u0075\u006d\u0062\u0065\u0072")
	}
	if revisionNumber == _dbcfc {
		return _cccb, nil
	}
	if _cccb._cbga[revisionNumber] != nil {
		return _cccb._cbga[revisionNumber], nil
	}
	_eddfc := _cccb
	for _adbfd := _dbcfc - 1; _adbfd >= revisionNumber; _adbfd-- {
		_egfac, _edffde := _eddfc.GetPreviousRevision()
		if _edffde != nil {
			return nil, _edffde
		}
		_cccb._cbga[_adbfd] = _egfac
		_eddfc = _egfac
	}
	return _eddfc, nil
}

// ToInteger convert to an integer format.
func (_dbfe *PdfColorDeviceGray) ToInteger(bits int) uint32 {
	_bfbgg := _faf.Pow(2, float64(bits)) - 1
	return uint32(_bfbgg * _dbfe.Val())
}

// NewStandard14FontMustCompile returns the standard 14 font named `basefont` as a *PdfFont.
// If `basefont` is one of the 14 Standard14Font values defined above then NewStandard14FontMustCompile
// is guaranteed to succeed.
func NewStandard14FontMustCompile(basefont StdFontName) *PdfFont {
	_ffgac, _aggc := NewStandard14Font(basefont)
	if _aggc != nil {
		panic(_c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0031\u0034\u0046\u006f\u006e\u0074 \u0025\u0023\u0071", basefont))
	}
	return _ffgac
}

// NewPdfColorspaceCalGray returns a new CalGray colorspace object.
func NewPdfColorspaceCalGray() *PdfColorspaceCalGray {
	_fgd := &PdfColorspaceCalGray{}
	_fgd.BlackPoint = []float64{0.0, 0.0, 0.0}
	_fgd.Gamma = 1
	return _fgd
}

func (_dcbga *PdfReader) newPdfAnnotationWidgetFromDict(_ggab *_df.PdfObjectDictionary) (*PdfAnnotationWidget, error) {
	_ddgc := PdfAnnotationWidget{}
	_ddgc.H = _ggab.Get("\u0048")
	_ddgc.MK = _ggab.Get("\u004d\u004b")
	_ddgc.A = _ggab.Get("\u0041")
	_ddgc.AA = _ggab.Get("\u0041\u0041")
	_ddgc.BS = _ggab.Get("\u0042\u0053")
	_ddgc.Parent = _ggab.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	return &_ddgc, nil
}

// GetCatalogMetadata gets the catalog defined XMP Metadata.
func (_adfc *PdfReader) GetCatalogMetadata() (_df.PdfObject, bool) {
	if _adfc._afbaf == nil {
		return nil, false
	}
	_aeba := _adfc._afbaf.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061")
	return _aeba, _aeba != nil
}

func (_dafda *PdfSignature) extractChainFromPKCS7() ([]*_ed.Certificate, error) {
	_cagcd, _afdfg := _ff.Parse(_dafda.Contents.Bytes())
	if _afdfg != nil {
		return nil, _afdfg
	}
	return _cagcd.Certificates, nil
}

// PdfAnnotationScreen represents Screen annotations.
// (Section 12.5.6.18).
type PdfAnnotationScreen struct {
	*PdfAnnotation
	T  _df.PdfObject
	MK _df.PdfObject
	A  _df.PdfObject
	AA _df.PdfObject
}

// NewPdfOutline returns an initialized PdfOutline.
func NewPdfOutline() *PdfOutline {
	_babeg := &PdfOutline{_edacg: _df.MakeIndirectObject(_df.MakeDict())}
	_babeg._dcgc = _babeg
	return _babeg
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_deag *PdfColorspaceDeviceRGB) ToPdfObject() _df.PdfObject {
	return _df.MakeName("\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B")
}

// PdfFontDescriptor specifies metrics and other attributes of a font and can refer to a FontFile
// for embedded fonts.
// 9.8 Font Descriptors (page 281)
type PdfFontDescriptor struct {
	FontName     _df.PdfObject
	FontFamily   _df.PdfObject
	FontStretch  _df.PdfObject
	FontWeight   _df.PdfObject
	Flags        _df.PdfObject
	FontBBox     _df.PdfObject
	ItalicAngle  _df.PdfObject
	Ascent       _df.PdfObject
	Descent      _df.PdfObject
	Leading      _df.PdfObject
	CapHeight    _df.PdfObject
	XHeight      _df.PdfObject
	StemV        _df.PdfObject
	StemH        _df.PdfObject
	AvgWidth     _df.PdfObject
	MaxWidth     _df.PdfObject
	MissingWidth _df.PdfObject
	FontFile     _df.PdfObject
	FontFile2    _df.PdfObject
	FontFile3    _df.PdfObject
	CharSet      _df.PdfObject
	_cadd        int
	_faeb        float64
	*fontFile
	_dcgaa *_da.TtfType

	// Additional entries for CIDFonts
	Style  _df.PdfObject
	Lang   _df.PdfObject
	FD     _df.PdfObject
	CIDSet _df.PdfObject
	_abaa  *_df.PdfIndirectObject
}

var (
	_ebdbe = _eb.MustCompile("\u005cd\u002b\u0020\u0064\u0069c\u0074\u005c\u0073\u002b\u0028d\u0075p\u005cs\u002b\u0029\u003f\u0062\u0065\u0067\u0069n")
	_feafa = _eb.MustCompile("\u005e\u005cs\u002a\u002f\u0028\u005c\u0053\u002b\u003f\u0029\u005c\u0073\u002b\u0028\u002e\u002b\u003f\u0029\u005c\u0073\u002b\u0064\u0065\u0066\\s\u002a\u0024")
	_bedda = _eb.MustCompile("\u005e\u005c\u0073*\u0064\u0075\u0070\u005c\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002a\u002f\u0028\u005c\u0077\u002b\u003f\u0029\u0028\u003f\u003a\u005c\u002e\u005c\u0064\u002b)\u003f\u005c\u0073\u002b\u0070\u0075\u0074\u0024")
	_feeb  = "\u002f\u0045\u006e\u0063od\u0069\u006e\u0067\u0020\u0032\u0035\u0036\u0020\u0061\u0072\u0072\u0061\u0079"
	_dfda  = "\u0072\u0065\u0061d\u006f\u006e\u006c\u0079\u0020\u0064\u0065\u0066"
	_aabe  = "\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u0066\u0069\u006c\u0065\u0020e\u0065\u0078\u0065\u0063"
)

// SetCatalogViewerPreferences sets the catalog ViewerPreferences dictionary.
func (_gcdba *PdfWriter) SetCatalogViewerPreferences(pref _df.PdfObject) error {
	if pref == nil {
		_gcdba._gdee.Remove("\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073")
		return nil
	}
	if _baabe, _adfbf := pref.(*_df.PdfObjectReference); _adfbf {
		pref = _baabe.Resolve()
		if pref == nil {
			_gcdba._gdee.Remove("\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073")
			return nil
		}
	}
	_gcdba.addObject(pref)
	_gcdba._gdee.Set("\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073", pref)
	return nil
}

func (_gfege *PdfReader) lookupPageByObject(_dcgga _df.PdfObject) (*PdfPage, error) {
	return nil, _deb.New("\u0070\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// PdfVersion returns version of the PDF file.
func (_bdcdg *PdfReader) PdfVersion() _df.Version { return _bdcdg._gfdaag.PdfVersion() }

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element.
func (_eeef *PdfColorspaceSpecialSeparation) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gadec, _afdf := _df.GetNumbersAsFloat(objects)
	if _afdf != nil {
		return nil, _afdf
	}
	return _eeef.ColorFromFloats(_gadec)
}

// AnnotFilterFunc represents a PDF annotation filtering function. If the function
// returns true, the annotation is kept, otherwise it is discarded.
type AnnotFilterFunc func(*PdfAnnotation) bool

// PdfColorDeviceCMYK is a CMYK32 color, where each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorDeviceCMYK [4]float64

func _cagf(_bfgeb _df.PdfObject) (*PdfColorspaceCalRGB, error) {
	_dbed := NewPdfColorspaceCalRGB()
	if _cfdgd, _bcbb := _bfgeb.(*_df.PdfIndirectObject); _bcbb {
		_dbed._bbed = _cfdgd
	}
	_bfgeb = _df.TraceToDirectObject(_bfgeb)
	_agga, _baaa := _bfgeb.(*_df.PdfObjectArray)
	if !_baaa {
		return nil, _c.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _agga.Len() != 2 {
		return nil, _c.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0043\u0061\u006c\u0052G\u0042 \u0063o\u006c\u006f\u0072\u0073\u0070\u0061\u0063e")
	}
	_bfgeb = _df.TraceToDirectObject(_agga.Get(0))
	_aeb, _baaa := _bfgeb.(*_df.PdfObjectName)
	if !_baaa {
		return nil, _c.Errorf("\u0043\u0061l\u0052\u0047\u0042\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062je\u0063\u0074")
	}
	if *_aeb != "\u0043\u0061\u006c\u0052\u0047\u0042" {
		return nil, _c.Errorf("\u006e\u006f\u0074 a\u0020\u0043\u0061\u006c\u0052\u0047\u0042\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	}
	_bfgeb = _df.TraceToDirectObject(_agga.Get(1))
	_bcgf, _baaa := _bfgeb.(*_df.PdfObjectDictionary)
	if !_baaa {
		return nil, _c.Errorf("\u0043\u0061l\u0052\u0047\u0042\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062je\u0063\u0074")
	}
	_bfgeb = _bcgf.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_bfgeb = _df.TraceToDirectObject(_bfgeb)
	_dfge, _baaa := _bfgeb.(*_df.PdfObjectArray)
	if !_baaa {
		return nil, _c.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050o\u0069\u006e\u0074")
	}
	if _dfge.Len() != 3 {
		return nil, _c.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0057h\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_baff, _ceea := _dfge.GetAsFloat64Slice()
	if _ceea != nil {
		return nil, _ceea
	}
	_dbed.WhitePoint = _baff
	_bfgeb = _bcgf.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _bfgeb != nil {
		_bfgeb = _df.TraceToDirectObject(_bfgeb)
		_efff, _eafa := _bfgeb.(*_df.PdfObjectArray)
		if !_eafa {
			return nil, _c.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050o\u0069\u006e\u0074")
		}
		if _efff.Len() != 3 {
			return nil, _c.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0042l\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074\u0020\u0061\u0072\u0072\u0061\u0079")
		}
		_abge, _bcaab := _efff.GetAsFloat64Slice()
		if _bcaab != nil {
			return nil, _bcaab
		}
		_dbed.BlackPoint = _abge
	}
	_bfgeb = _bcgf.Get("\u0047\u0061\u006dm\u0061")
	if _bfgeb != nil {
		_bfgeb = _df.TraceToDirectObject(_bfgeb)
		_dcdf, _cdggf := _bfgeb.(*_df.PdfObjectArray)
		if !_cdggf {
			return nil, _c.Errorf("C\u0061\u006c\u0052\u0047B:\u0020I\u006e\u0076\u0061\u006c\u0069d\u0020\u0047\u0061\u006d\u006d\u0061")
		}
		if _dcdf.Len() != 3 {
			return nil, _c.Errorf("C\u0061\u006c\u0052\u0047\u0042\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0047a\u006d\u006d\u0061 \u0061r\u0072\u0061\u0079")
		}
		_dafg, _gbfe := _dcdf.GetAsFloat64Slice()
		if _gbfe != nil {
			return nil, _gbfe
		}
		_dbed.Gamma = _dafg
	}
	_bfgeb = _bcgf.Get("\u004d\u0061\u0074\u0072\u0069\u0078")
	if _bfgeb != nil {
		_bfgeb = _df.TraceToDirectObject(_bfgeb)
		_aafg, _gbage := _bfgeb.(*_df.PdfObjectArray)
		if !_gbage {
			return nil, _c.Errorf("\u0043\u0061\u006c\u0052GB\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004d\u0061\u0074\u0072i\u0078")
		}
		if _aafg.Len() != 9 {
			_bcd.Log.Error("\u004d\u0061t\u0072\u0069\u0078 \u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073", _aafg.String())
			return nil, _c.Errorf("\u0043\u0061\u006c\u0052G\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u004da\u0074\u0072\u0069\u0078\u0020\u0061\u0072r\u0061\u0079")
		}
		_aaca, _dcag := _aafg.GetAsFloat64Slice()
		if _dcag != nil {
			return nil, _dcag
		}
		_dbed.Matrix = _aaca
	}
	return _dbed, nil
}

func (_ddad *PdfPage) flattenFieldsWithOpts(_aaaaa FieldAppearanceGenerator, _beafe *FieldFlattenOpts, _dbcec map[*PdfAnnotation]bool) error {
	var _cabbd []*PdfAnnotation
	if _aaaaa != nil {
		if _faba := _aaaaa.WrapContentStream(_ddad); _faba != nil {
			return _faba
		}
	}
	_ccfgg, _aeag := _ddad.GetAnnotations()
	if _aeag != nil {
		return _aeag
	}
	for _, _bfecd := range _ccfgg {
		_bcdgbg, _caec := _dbcec[_bfecd]
		if !_caec && _beafe.AnnotFilterFunc != nil {
			if _, _bcaf := _bfecd.GetContext().(*PdfAnnotationWidget); !_bcaf {
				_caec = _beafe.AnnotFilterFunc(_bfecd)
			}
		}
		if !_caec {
			_cabbd = append(_cabbd, _bfecd)
			continue
		}
		switch _bfecd.GetContext().(type) {
		case *PdfAnnotationPopup:
			continue
		case *PdfAnnotationLink:
			continue
		case *PdfAnnotationProjection:
			continue
		}
		_fbcdd, _bdge, _dgede := _efdg(_bfecd)
		if _dgede != nil {
			if !_bcdgbg {
				_bcd.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0077\u0069\u0074h\u006f\u0075\u0074\u0020\u0056\u0020\u002d\u003e\u0020\u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0077\u0069\u0074h\u006f\u0075t\u0020\u0061p\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073\u0074\u0072\u0065am\u0020\u002d\u0020\u0073\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u006f\u0076\u0065\u0072")
				continue
			}
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0077\u0069\u0074h\u006f\u0075\u0074\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d,\u0020\u0065\u0072\u0072\u0020\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0073\u006bi\u0070\u0070\u0069n\u0067\u0020\u006f\u0076\u0065\u0072", _dgede)
			continue
		}
		if _fbcdd == nil {
			continue
		}
		_ffce := _ddad.Resources.GenerateXObjectName()
		_ddad.Resources.SetXObjectFormByName(_ffce, _fbcdd)
		_bcdf, _gbcc, _dgede := _ecbe(_fbcdd)
		if _dgede != nil {
			_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0061\u0070p\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u004d\u0061\u0074\u0072\u0069\u0078\u002c\u0020s\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0078\u0066\u006f\u0072\u006d\u0020\u0062\u0062\u006f\u0078\u0020\u0061\u0064\u006a\u0075\u0073t\u006d\u0065\u006e\u0074\u003a \u0025\u0076", _dgede)
		} else {
			_cfcb := _dbc.IdentityMatrix()
			_cfcb = _cfcb.Translate(-_bcdf.Llx, -_bcdf.Lly)
			if _gbcc {
				_efad := 1.0
				if _bcdf.Width() > 0 {
					_efad = _faf.Round(_bdge.Width() / _bcdf.Width())
				}
				_cgec := 1.0
				if _bcdf.Height() > 0 {
					_cgec = _faf.Round(_bdge.Height() / _bcdf.Height())
				}
				_cfcb = _cfcb.Scale(_efad, _cgec)
			}
			_bdge.Transform(_cfcb)
		}
		_gfeaeb := _faf.Min(_bdge.Llx, _bdge.Urx)
		_gfee := _faf.Min(_bdge.Lly, _bdge.Ury)
		var _cebfe []string
		_cebfe = append(_cebfe, "\u0071")
		_cebfe = append(_cebfe, _c.Sprintf("\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020%\u002e6\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0063\u006d", 1.0, 0.0, 0.0, 1.0, _gfeaeb, _gfee))
		_cebfe = append(_cebfe, _c.Sprintf("\u002f\u0025\u0073\u0020\u0044\u006f", _ffce.String()))
		_cebfe = append(_cebfe, "\u0051")
		_gfefge := _gc.Join(_cebfe, "\u000a")
		_dgede = _ddad.AppendContentStream(_gfefge)
		if _dgede != nil {
			return _dgede
		}
		if _fbcdd.Resources != nil {
			_gggfc, _gagbc := _df.GetDict(_fbcdd.Resources.Font)
			if _gagbc {
				for _, _dbcga := range _gggfc.Keys() {
					if !_ddad.Resources.HasFontByName(_dbcga) {
						_ddad.Resources.SetFontByName(_dbcga, _gggfc.Get(_dbcga))
					}
				}
			}
		}
	}
	if len(_cabbd) > 0 {
		_ddad._adef = _cabbd
	} else {
		_ddad._adef = []*PdfAnnotation{}
	}
	return nil
}

// GetContext returns a reference to the subpattern entry: either PdfTilingPattern or PdfShadingPattern.
func (_efgda *PdfPattern) GetContext() PdfModel { return _efgda._ecfde }

// NewPdfAnnotationFileAttachment returns a new file attachment annotation.
func NewPdfAnnotationFileAttachment() *PdfAnnotationFileAttachment {
	_gffd := NewPdfAnnotation()
	_ggg := &PdfAnnotationFileAttachment{}
	_ggg.PdfAnnotation = _gffd
	_ggg.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_gffd.SetContext(_ggg)
	return _ggg
}

func _caged(_ffbbb map[_da.GID]int, _dbdcd uint16) *_df.PdfObjectArray {
	_dcdce := &_df.PdfObjectArray{}
	_daegc := _da.GID(_dbdcd)
	for _bceaf := _da.GID(0); _bceaf < _daegc; {
		_afbab, _ddcf := _ffbbb[_bceaf]
		if !_ddcf {
			_bceaf++
			continue
		}
		_bbge := _bceaf
		for _gede := _bbge + 1; _gede < _daegc; _gede++ {
			if _ceaa, _gcgb := _ffbbb[_gede]; !_gcgb || _afbab != _ceaa {
				break
			}
			_bbge = _gede
		}
		_dcdce.Append(_df.MakeInteger(int64(_bceaf)))
		_dcdce.Append(_df.MakeInteger(int64(_bbge)))
		_dcdce.Append(_df.MakeInteger(int64(_afbab)))
		_bceaf = _bbge + 1
	}
	return _dcdce
}

var _ pdfFont = (*pdfFontType0)(nil)

// GetVersion gets the document version.
func (_bdagf *PdfWriter) GetVersion() _df.Version { return _bdagf._aeffd }

func _fffe(_dcbgfa *_df.PdfObjectDictionary) (*PdfTilingPattern, error) {
	_bebf := &PdfTilingPattern{}
	_fdab := _dcbgfa.Get("\u0050a\u0069\u006e\u0074\u0054\u0079\u0070e")
	if _fdab == nil {
		_bcd.Log.Debug("\u0050\u0061\u0069\u006e\u0074\u0054\u0079\u0070\u0065\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_bgfbg, _feeeg := _fdab.(*_df.PdfObjectInteger)
	if !_feeeg {
		_bcd.Log.Debug("\u0050\u0061\u0069\u006e\u0074\u0054y\u0070\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006ft\u0020\u0025\u0054\u0029", _fdab)
		return nil, _df.ErrTypeError
	}
	_bebf.PaintType = _bgfbg
	_fdab = _dcbgfa.Get("\u0054\u0069\u006c\u0069\u006e\u0067\u0054\u0079\u0070\u0065")
	if _fdab == nil {
		_bcd.Log.Debug("\u0054i\u006ci\u006e\u0067\u0054\u0079\u0070e\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_bffdc, _feeeg := _fdab.(*_df.PdfObjectInteger)
	if !_feeeg {
		_bcd.Log.Debug("\u0054\u0069\u006cin\u0067\u0054\u0079\u0070\u0065\u0020\u006e\u006f\u0074 \u0061n\u0020i\u006et\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _fdab)
		return nil, _df.ErrTypeError
	}
	_bebf.TilingType = _bffdc
	_fdab = _dcbgfa.Get("\u0042\u0042\u006f\u0078")
	if _fdab == nil {
		_bcd.Log.Debug("\u0042\u0042\u006fx\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_fdab = _df.TraceToDirectObject(_fdab)
	_caffd, _feeeg := _fdab.(*_df.PdfObjectArray)
	if !_feeeg {
		_bcd.Log.Debug("\u0042B\u006f\u0078 \u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0073p\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061y\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _fdab)
		return nil, _df.ErrTypeError
	}
	_ddga, _cdegaa := NewPdfRectangle(*_caffd)
	if _cdegaa != nil {
		_bcd.Log.Debug("\u0042\u0042\u006f\u0078\u0020\u0065\u0072\u0072\u006fr\u003a\u0020\u0025\u0076", _cdegaa)
		return nil, _cdegaa
	}
	_bebf.BBox = _ddga
	_fdab = _dcbgfa.Get("\u0058\u0053\u0074e\u0070")
	if _fdab == nil {
		_bcd.Log.Debug("\u0058\u0053\u0074\u0065\u0070\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_ebcce, _cdegaa := _df.GetNumberAsFloat(_fdab)
	if _cdegaa != nil {
		_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0058S\u0074e\u0070\u0020\u0061\u0073\u0020\u0066\u006c\u006f\u0061\u0074\u003a\u0020\u0025\u0076", _ebcce)
		return nil, _cdegaa
	}
	_bebf.XStep = _df.MakeFloat(_ebcce)
	_fdab = _dcbgfa.Get("\u0059\u0053\u0074e\u0070")
	if _fdab == nil {
		_bcd.Log.Debug("\u0059\u0053\u0074\u0065\u0070\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_gfcce, _cdegaa := _df.GetNumberAsFloat(_fdab)
	if _cdegaa != nil {
		_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0059S\u0074e\u0070\u0020\u0061\u0073\u0020\u0066\u006c\u006f\u0061\u0074\u003a\u0020\u0025\u0076", _gfcce)
		return nil, _cdegaa
	}
	_bebf.YStep = _df.MakeFloat(_gfcce)
	_fdab = _dcbgfa.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s")
	if _fdab == nil {
		_bcd.Log.Debug("\u0052\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_dcbgfa, _feeeg = _df.TraceToDirectObject(_fdab).(*_df.PdfObjectDictionary)
	if !_feeeg {
		return nil, _c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063e\u0020d\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _fdab)
	}
	_adacc, _cdegaa := NewPdfPageResourcesFromDict(_dcbgfa)
	if _cdegaa != nil {
		return nil, _cdegaa
	}
	_bebf.Resources = _adacc
	if _gbff := _dcbgfa.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _gbff != nil {
		_gfde, _dbbgd := _gbff.(*_df.PdfObjectArray)
		if !_dbbgd {
			_bcd.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _gbff)
			return nil, _df.ErrTypeError
		}
		_bebf.Matrix = _gfde
	}
	return _bebf, nil
}

// ToPdfObject converts the pdfCIDFontType0 to a PDF representation.
func (_ecbg *pdfCIDFontType0) ToPdfObject() _df.PdfObject { return _df.MakeNull() }

// AcroFormNeedsRepair returns true if the document contains widget annotations
// linked to fields which are not referenced in the AcroForm. The AcroForm can
// be repaired using the RepairAcroForm method of the reader.
func (_febge *PdfReader) AcroFormNeedsRepair() (bool, error) {
	var _ddafa []*PdfField
	if _febge.AcroForm != nil {
		_ddafa = _febge.AcroForm.AllFields()
	}
	_daddg := make(map[*PdfField]struct{}, len(_ddafa))
	for _, _ggfecf := range _ddafa {
		_daddg[_ggfecf] = struct{}{}
	}
	for _, _feda := range _febge.PageList {
		_gfgfa, _acaefg := _feda.GetAnnotations()
		if _acaefg != nil {
			return false, _acaefg
		}
		for _, _beba := range _gfgfa {
			_dgbf, _cbgc := _beba.GetContext().(*PdfAnnotationWidget)
			if !_cbgc {
				continue
			}
			_ffdfa := _dgbf.Field()
			if _ffdfa == nil {
				return true, nil
			}
			if _, _gdggd := _daddg[_ffdfa]; !_gdggd {
				return true, nil
			}
		}
	}
	return false, nil
}

// PdfAnnotationPrinterMark represents PrinterMark annotations.
// (Section 12.5.6.20).
type PdfAnnotationPrinterMark struct {
	*PdfAnnotation
	MN _df.PdfObject
}

// HasXObjectByName checks if has XObject resource by name.
func (_dfdff *PdfPage) HasXObjectByName(name _df.PdfObjectName) bool {
	_egfba, _gdcb := _dfdff.Resources.XObject.(*_df.PdfObjectDictionary)
	if !_gdcb {
		return false
	}
	if _gcdbd := _egfba.Get(name); _gcdbd != nil {
		return true
	}
	return false
}

// NewPdfAnnotation3D returns a new 3d annotation.
func NewPdfAnnotation3D() *PdfAnnotation3D {
	_cga := NewPdfAnnotation()
	_edbe := &PdfAnnotation3D{}
	_edbe.PdfAnnotation = _cga
	_cga.SetContext(_edbe)
	return _edbe
}

func (_fde *PdfReader) newPdfAnnotationMarkupFromDict(_egfb *_df.PdfObjectDictionary) (*PdfAnnotationMarkup, error) {
	_adf := &PdfAnnotationMarkup{}
	if _aade := _egfb.Get("\u0054"); _aade != nil {
		_adf.T = _aade
	}
	if _faab := _egfb.Get("\u0050\u006f\u0070u\u0070"); _faab != nil {
		_bce, _gfc := _faab.(*_df.PdfIndirectObject)
		if !_gfc {
			if _, _ecd := _faab.(*_df.PdfObjectNull); !_ecd {
				return nil, _deb.New("p\u006f\u0070\u0075\u0070\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0070\u006f\u0069\u006e\u0074\u0020t\u006f\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074")
			}
		} else {
			_affg, _acdg := _fde.newPdfAnnotationFromIndirectObject(_bce)
			if _acdg != nil {
				return nil, _acdg
			}
			if _affg != nil {
				_caed, _cedfc := _affg._afaa.(*PdfAnnotationPopup)
				if !_cedfc {
					return nil, _deb.New("\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0072\u0065\u0066\u0065\u0072\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0020\u0070\u006f\u0070\u0075\u0070\u0020\u0061n\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e")
				}
				_adf.Popup = _caed
			}
		}
	}
	if _ceae := _egfb.Get("\u0043\u0041"); _ceae != nil {
		_adf.CA = _ceae
	}
	if _dgdf := _egfb.Get("\u0052\u0043"); _dgdf != nil {
		_adf.RC = _dgdf
	}
	if _gefa := _egfb.Get("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065"); _gefa != nil {
		_adf.CreationDate = _gefa
	}
	if _bfa := _egfb.Get("\u0049\u0052\u0054"); _bfa != nil {
		_adf.IRT = _bfa
	}
	if _fbgg := _egfb.Get("\u0053\u0075\u0062\u006a"); _fbgg != nil {
		_adf.Subj = _fbgg
	}
	if _gadg := _egfb.Get("\u0052\u0054"); _gadg != nil {
		_adf.RT = _gadg
	}
	if _dbceb := _egfb.Get("\u0049\u0054"); _dbceb != nil {
		_adf.IT = _dbceb
	}
	if _ccba := _egfb.Get("\u0045\u0078\u0044\u0061\u0074\u0061"); _ccba != nil {
		_adf.ExData = _ccba
	}
	return _adf, nil
}

// G returns the value of the green component of the color.
func (_aec *PdfColorDeviceRGB) G() float64 { return _aec[1] }

// PdfActionRendition represents a Rendition action.
type PdfActionRendition struct {
	*PdfAction
	R  _df.PdfObject
	AN _df.PdfObject
	OP _df.PdfObject
	JS _df.PdfObject
}

// PdfShadingType2 is an Axial shading.
type PdfShadingType2 struct {
	*PdfShading
	Coords   *_df.PdfObjectArray
	Domain   *_df.PdfObjectArray
	Function []PdfFunction
	Extend   *_df.PdfObjectArray
}

// NewMultipleFontEncoder returns instantiates a new *MultipleFontEncoder
func NewMultipleFontEncoder(fonts []*PdfFont) *MultipleFontEncoder {
	return &MultipleFontEncoder{_fbeed: fonts, CurrentFont: fonts[0]}
}

// GetFontByName gets the font specified by keyName. Returns the PdfObject which
// the entry refers to. Returns a bool value indicating whether or not the entry was found.
func (_agbac *PdfPageResources) GetFontByName(keyName _df.PdfObjectName) (_df.PdfObject, bool) {
	if _agbac.Font == nil {
		return nil, false
	}
	_cdba, _fdccc := _df.TraceToDirectObject(_agbac.Font).(*_df.PdfObjectDictionary)
	if !_fdccc {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0021\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _df.TraceToDirectObject(_agbac.Font))
		return nil, false
	}
	if _dbdcf := _cdba.Get(keyName); _dbdcf != nil {
		return _dbdcf, true
	}
	return nil, false
}

// Sign signs a specific page with a digital signature.
// The signature field parameter must have a valid signature dictionary
// specified by its V field.
func (_fafe *PdfAppender) Sign(pageNum int, field *PdfFieldSignature) error {
	if field == nil {
		return _deb.New("\u0073\u0069g\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 n\u0069\u006c")
	}
	_ffae := field.V
	if _ffae == nil {
		return _deb.New("\u0073\u0069\u0067na\u0074\u0075\u0072\u0065\u0020\u0064\u0069\u0063\u0074i\u006fn\u0061r\u0079 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c")
	}
	_cfc := pageNum - 1
	if _cfc < 0 || _cfc > len(_fafe._dgac)-1 {
		return _c.Errorf("\u0070\u0061\u0067\u0065\u0020\u0025\u0064\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064", pageNum)
	}
	_afbc := _fafe.Reader.PageList[_cfc]
	field.P = _afbc.ToPdfObject()
	if field.T == nil || field.T.String() == "" {
		field.T = _df.MakeString(_c.Sprintf("\u0053\u0069\u0067n\u0061\u0074\u0075\u0072\u0065\u0020\u0025\u0064", pageNum))
	}
	_afbc.AddAnnotation(field.PdfAnnotationWidget.PdfAnnotation)
	if _fafe._ffe == _fafe._abf.AcroForm {
		_fafe._ffe = _fafe.Reader.AcroForm
	}
	_ffda := _fafe._ffe
	if _ffda == nil {
		_ffda = NewPdfAcroForm()
	}
	_ffda.SigFlags = _df.MakeInteger(3)
	if _ffda.NeedAppearances != nil {
		_ffda.NeedAppearances = nil
	}
	_gccf := append(_ffda.AllFields(), field.PdfField)
	_ffda.Fields = &_gccf
	_fafe.ReplaceAcroForm(_ffda)
	_fafe.UpdatePage(_afbc)
	_fafe._dgac[_cfc] = _afbc
	if _, _ddgca := field.V.GetDocMDPPermission(); _ddgca {
		_fafe._gfedf = NewPermissions(field.V)
	}
	return nil
}

// ColorToRGB converts a DeviceN color to an RGB color.
func (_ebag *PdfColorspaceDeviceN) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _ebag.AlternateSpace == nil {
		return nil, _deb.New("\u0044\u0065\u0076\u0069\u0063\u0065N\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0065\u0020\u0073\u0070a\u0063\u0065\u0020\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064")
	}
	return _ebag.AlternateSpace.ColorToRGB(color)
}

func (_baaab *PdfReader) buildPageList(_bddbe *_df.PdfIndirectObject, _bdcgc *_df.PdfIndirectObject, _egcga map[_df.PdfObject]struct{}) error {
	if _bddbe == nil {
		return nil
	}
	if _, _cbbf := _egcga[_bddbe]; _cbbf {
		_bcd.Log.Debug("\u0043\u0079\u0063l\u0069\u0063\u0020\u0072e\u0063\u0075\u0072\u0073\u0069\u006f\u006e,\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0028\u0025\u0076\u0029", _bddbe.ObjectNumber)
		return nil
	}
	_egcga[_bddbe] = struct{}{}
	_ggadd, _cfdfd := _bddbe.PdfObject.(*_df.PdfObjectDictionary)
	if !_cfdfd {
		return _deb.New("n\u006f\u0064\u0065\u0020no\u0074 \u0061\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_dcgag, _cfdfd := (*_ggadd).Get("\u0054\u0079\u0070\u0065").(*_df.PdfObjectName)
	if !_cfdfd {
		if _ggadd.Get("\u004b\u0069\u0064\u0073") == nil {
			return _deb.New("\u006e\u006f\u0064\u0065 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0054\u0079p\u0065 \u0028\u0052\u0065\u0071\u0075\u0069\u0072e\u0064\u0029")
		}
		_bcd.Log.Debug("ER\u0052\u004fR\u003a\u0020\u006e\u006f\u0064\u0065\u0020\u006d\u0069s\u0073\u0069\u006e\u0067\u0020\u0054\u0079\u0070\u0065\u002c\u0020\u0062\u0075\u0074\u0020\u0068\u0061\u0073\u0020\u004b\u0069\u0064\u0073\u002e\u0020\u0041\u0073\u0073u\u006di\u006e\u0067\u0020\u0050\u0061\u0067\u0065\u0073 \u006eo\u0064\u0065.")
		_dcgag = _df.MakeName("\u0050\u0061\u0067e\u0073")
		_ggadd.Set("\u0054\u0079\u0070\u0065", _dcgag)
	}
	_bcd.Log.Trace("\u0062\u0075\u0069\u006c\u0064\u0050a\u0067\u0065\u004c\u0069\u0073\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0074y\u0070\u0065\u003a\u0020\u0025\u0073\u0020(\u0025\u002b\u0076\u0029", *_dcgag, _bddbe)
	if *_dcgag == "\u0050\u0061\u0067\u0065" {
		_fbace, _efeaf := _baaab.newPdfPageFromDict(_ggadd)
		if _efeaf != nil {
			return _efeaf
		}
		_fbace.setContainer(_bddbe)
		if _bdcgc != nil {
			_ggadd.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _bdcgc)
		}
		_baaab._dcfee = append(_baaab._dcfee, _bddbe)
		_baaab.PageList = append(_baaab.PageList, _fbace)
		return nil
	}
	if *_dcgag != "\u0050\u0061\u0067e\u0073" {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0063\u006fnt\u0065n\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067 \u006e\u006f\u006e\u0020\u0050\u0061\u0067\u0065\u002f\u0050\u0061\u0067\u0065\u0073\u0020\u006f\u0062j\u0065\u0063\u0074\u0021\u0020\u0028\u0025\u0073\u0029", _dcgag)
		return _deb.New("\u0074\u0061\u0062\u006c\u0065\u0020o\u0066\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067 \u006e\u006f\u006e\u0020\u0050\u0061\u0067\u0065\u002f\u0050\u0061\u0067\u0065\u0073 \u006fb\u006a\u0065\u0063\u0074")
	}
	if _bdcgc != nil {
		_ggadd.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _bdcgc)
	}
	if !_baaab._edbbdf {
		_ggcbbg := _baaab.traverseObjectData(_bddbe)
		if _ggcbbg != nil {
			return _ggcbbg
		}
	}
	_efgdg, _fecdf := _baaab._gfdaag.Resolve(_ggadd.Get("\u004b\u0069\u0064\u0073"))
	if _fecdf != nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069\u006eg\u0020\u004b\u0069\u0064\u0073\u0020\u006fb\u006a\u0065\u0063\u0074")
		return _fecdf
	}
	var _bdcacf *_df.PdfObjectArray
	_bdcacf, _cfdfd = _efgdg.(*_df.PdfObjectArray)
	if !_cfdfd {
		_baeb, _gddef := _efgdg.(*_df.PdfIndirectObject)
		if !_gddef {
			return _deb.New("\u0069\u006e\u0076\u0061li\u0064\u0020\u004b\u0069\u0064\u0073\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		}
		_bdcacf, _cfdfd = _baeb.PdfObject.(*_df.PdfObjectArray)
		if !_cfdfd {
			return _deb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u004b\u0069\u0064\u0073\u0020\u0069\u006ed\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074")
		}
	}
	_bcd.Log.Trace("\u004b\u0069\u0064\u0073\u003a\u0020\u0025\u0073", _bdcacf)
	for _decdd, _geeg := range _bdcacf.Elements() {
		_gacac, _gbaga := _df.GetIndirect(_geeg)
		if !_gbaga {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074 \u006f\u0062\u006a\u0065\u0063t\u0020\u002d \u0028\u0025\u0073\u0029", _gacac)
			return _deb.New("\u0070a\u0067\u0065\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0064\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		}
		_bdcacf.Set(_decdd, _gacac)
		_fecdf = _baaab.buildPageList(_gacac, _bddbe, _egcga)
		if _fecdf != nil {
			return _fecdf
		}
	}
	return nil
}

// SetImageHandler sets the image handler used by the package.
func SetImageHandler(imgHandling ImageHandler) { ImageHandling = imgHandling }

func _cagef(_fefb _df.PdfObject) (*PdfPattern, error) {
	_ecegf := &PdfPattern{}
	var _afdca *_df.PdfObjectDictionary
	if _acaae, _ceab := _df.GetIndirect(_fefb); _ceab {
		_ecegf._cbce = _acaae
		_gdced, _effa := _acaae.PdfObject.(*_df.PdfObjectDictionary)
		if !_effa {
			_bcd.Log.Debug("\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006fn\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079\u0020\u0028g\u006f\u0074\u0020%\u0054\u0029", _acaae.PdfObject)
			return nil, _df.ErrTypeError
		}
		_afdca = _gdced
	} else if _acba, _eefg := _df.GetStream(_fefb); _eefg {
		_ecegf._cbce = _acba
		_afdca = _acba.PdfObjectDictionary
	} else {
		_bcd.Log.Debug("\u0050a\u0074\u0074e\u0072\u006e\u0020\u006eo\u0074\u0020\u0061n\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074 o\u0062\u006a\u0065c\u0074\u0020o\u0072\u0020\u0073\u0074\u0072\u0065a\u006d\u002e \u0025\u0054", _fefb)
		return nil, _df.ErrTypeError
	}
	_agea := _afdca.Get("P\u0061\u0074\u0074\u0065\u0072\u006e\u0054\u0079\u0070\u0065")
	if _agea == nil {
		_bcd.Log.Debug("\u0050\u0064\u0066\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069n\u0067\u0020\u0050\u0061\u0074t\u0065\u0072n\u0054\u0079\u0070\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_ededa, _fgadc := _agea.(*_df.PdfObjectInteger)
	if !_fgadc {
		_bcd.Log.Debug("\u0050\u0061tt\u0065\u0072\u006e \u0074\u0079\u0070\u0065 no\u0074 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067er\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _agea)
		return nil, _df.ErrTypeError
	}
	if *_ededa != 1 && *_ededa != 2 {
		_bcd.Log.Debug("\u0050\u0061\u0074\u0074e\u0072\u006e\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d \u0031/\u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", *_ededa)
		return nil, _df.ErrRangeError
	}
	_ecegf.PatternType = int64(*_ededa)
	switch *_ededa {
	case 1:
		_ecaec, _cacd := _fffe(_afdca)
		if _cacd != nil {
			return nil, _cacd
		}
		_ecaec.PdfPattern = _ecegf
		_ecegf._ecfde = _ecaec
		return _ecegf, nil
	case 2:
		_ggdf, _effcd := _egad(_afdca)
		if _effcd != nil {
			return nil, _effcd
		}
		_ggdf.PdfPattern = _ecegf
		_ecegf._ecfde = _ggdf
		return _ecegf, nil
	}
	return nil, _deb.New("\u0075n\u006bn\u006f\u0077\u006e\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e")
}

// IsCenterWindow returns the value of the centerWindow flag.
func (_fcebg *ViewerPreferences) IsCenterWindow() bool {
	if _fcebg._agceg == nil {
		return false
	}
	return *_fcebg._agceg
}

// ToPdfObject implements interface PdfModel.
func (_acf *PdfActionHide) ToPdfObject() _df.PdfObject {
	_acf.PdfAction.ToPdfObject()
	_bcb := _acf._gcf
	_edg := _bcb.PdfObject.(*_df.PdfObjectDictionary)
	_edg.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeHide)))
	_edg.SetIfNotNil("\u0054", _acf.T)
	_edg.SetIfNotNil("\u0048", _acf.H)
	return _bcb
}

// HasExtGState checks if ExtGState name is available.
func (_dbbf *PdfPage) HasExtGState(name _df.PdfObjectName) bool {
	if _dbbf.Resources == nil {
		return false
	}
	if _dbbf.Resources.ExtGState == nil {
		return false
	}
	_bggc, _fcgde := _df.TraceToDirectObject(_dbbf.Resources.ExtGState).(*_df.PdfObjectDictionary)
	if !_fcgde {
		_bcd.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0045\u0078t\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0064i\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a\u0020\u0025\u0076", _df.TraceToDirectObject(_dbbf.Resources.ExtGState))
		return false
	}
	_ebbbc := _bggc.Get(name)
	_gdcdb := _ebbbc != nil
	return _gdcdb
}

// SetPrintArea sets the value of the printArea.
func (_ddgcb *ViewerPreferences) SetPrintArea(printArea PageBoundary) { _ddgcb._fbede = printArea }

func (_ggba *PdfReader) newPdfActionResetFormFromDict(_bgb *_df.PdfObjectDictionary) (*PdfActionResetForm, error) {
	return &PdfActionResetForm{Fields: _bgb.Get("\u0046\u0069\u0065\u006c\u0064\u0073"), Flags: _bgb.Get("\u0046\u006c\u0061g\u0073")}, nil
}

// ToPdfObject implements interface PdfModel.
func (_fcb *PdfActionResetForm) ToPdfObject() _df.PdfObject {
	_fcb.PdfAction.ToPdfObject()
	_cbd := _fcb._gcf
	_eagg := _cbd.PdfObject.(*_df.PdfObjectDictionary)
	_eagg.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeResetForm)))
	_eagg.SetIfNotNil("\u0046\u0069\u0065\u006c\u0064\u0073", _fcb.Fields)
	_eagg.SetIfNotNil("\u0046\u006c\u0061g\u0073", _fcb.Flags)
	return _cbd
}

// ToPdfObject implements interface PdfModel.
func (_ecad *PdfTransformParamsDocMDP) ToPdfObject() _df.PdfObject {
	_eedgf := _df.MakeDict()
	_eedgf.SetIfNotNil("\u0054\u0079\u0070\u0065", _ecad.Type)
	_eedgf.SetIfNotNil("\u0056", _ecad.V)
	_eedgf.SetIfNotNil("\u0050", _ecad.P)
	return _eedgf
}

// ToPdfObject implements interface PdfModel.
func (_gbabe *PdfSignature) ToPdfObject() _df.PdfObject {
	_cegcc := _gbabe._aeddbb
	var _deead *_df.PdfObjectDictionary
	if _aeddd, _dacb := _cegcc.PdfObject.(*pdfSignDictionary); _dacb {
		_deead = _aeddd.PdfObjectDictionary
	} else {
		_deead = _cegcc.PdfObject.(*_df.PdfObjectDictionary)
	}
	_deead.SetIfNotNil("\u0054\u0079\u0070\u0065", _gbabe.Type)
	_deead.SetIfNotNil("\u0046\u0069\u006c\u0074\u0065\u0072", _gbabe.Filter)
	_deead.SetIfNotNil("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r", _gbabe.SubFilter)
	_deead.SetIfNotNil("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e", _gbabe.ByteRange)
	_deead.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _gbabe.Contents)
	_deead.SetIfNotNil("\u0043\u0065\u0072\u0074", _gbabe.Cert)
	_deead.SetIfNotNil("\u004e\u0061\u006d\u0065", _gbabe.Name)
	_deead.SetIfNotNil("\u0052\u0065\u0061\u0073\u006f\u006e", _gbabe.Reason)
	_deead.SetIfNotNil("\u004d", _gbabe.M)
	_deead.SetIfNotNil("\u0052e\u0066\u0065\u0072\u0065\u006e\u0063e", _gbabe.Reference)
	_deead.SetIfNotNil("\u0043h\u0061\u006e\u0067\u0065\u0073", _gbabe.Changes)
	_deead.SetIfNotNil("C\u006f\u006e\u0074\u0061\u0063\u0074\u0049\u006e\u0066\u006f", _gbabe.ContactInfo)
	_deead.SetIfNotNil("\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e", _gbabe.Location)
	return _cegcc
}

// SetCenterWindow sets the value of the centerWindow flag.
func (_ebedd *ViewerPreferences) SetCenterWindow(centerWindow bool) { _ebedd._agceg = &centerWindow }

// NewPdfAnnotationProjection returns a new projection annotation.
func NewPdfAnnotationProjection() *PdfAnnotationProjection {
	_egd := NewPdfAnnotation()
	_ecee := &PdfAnnotationProjection{}
	_ecee.PdfAnnotation = _egd
	_ecee.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_egd.SetContext(_ecee)
	return _ecee
}

// String returns a string describing the font descriptor.
func (_geedg *PdfFontDescriptor) String() string {
	var _gfgbb []string
	if _geedg.FontName != nil {
		_gfgbb = append(_gfgbb, _geedg.FontName.String())
	}
	if _geedg.FontFamily != nil {
		_gfgbb = append(_gfgbb, _geedg.FontFamily.String())
	}
	if _geedg.fontFile != nil {
		_gfgbb = append(_gfgbb, _geedg.fontFile.String())
	}
	if _geedg._dcgaa != nil {
		_gfgbb = append(_gfgbb, _geedg._dcgaa.String())
	}
	_gfgbb = append(_gfgbb, _c.Sprintf("\u0046\u006f\u006et\u0046\u0069\u006c\u0065\u0033\u003d\u0025\u0074", _geedg.FontFile3 != nil))
	return _c.Sprintf("\u0046\u004f\u004e\u0054_D\u0045\u0053\u0043\u0052\u0049\u0050\u0054\u004f\u0052\u007b\u0025\u0073\u007d", _gc.Join(_gfgbb, "\u002c\u0020"))
}

// NewPdfAppenderWithOpts creates a new Pdf appender from a Pdf reader with options.
func NewPdfAppenderWithOpts(reader *PdfReader, opts *ReaderOpts, encryptOptions *EncryptOptions) (*PdfAppender, error) {
	_ceba := &PdfAppender{_fggb: reader._fbacd, Reader: reader, _gecd: reader._gfdaag, _abba: reader._eebc}
	_gfcc, _bdeb := _ceba._fggb.Seek(0, _bdd.SeekEnd)
	if _bdeb != nil {
		return nil, _bdeb
	}
	_ceba._bfgee = _gfcc
	if _, _bdeb = _ceba._fggb.Seek(0, _bdd.SeekStart); _bdeb != nil {
		return nil, _bdeb
	}
	_ceba._abf, _bdeb = NewPdfReaderWithOpts(_ceba._fggb, opts)
	if _bdeb != nil {
		return nil, _bdeb
	}
	for _, _ggea := range _ceba.Reader.GetObjectNums() {
		if _ceba._eadb < _ggea {
			_ceba._eadb = _ggea
		}
	}
	_ceba._bagc = _ceba._gecd.GetXrefTable()
	_ceba._cfeb = _ceba._gecd.GetXrefOffset()
	_ceba._dgac = append(_ceba._dgac, _ceba._abf.PageList...)
	_ceba._gceg = make(map[_df.PdfObject]struct{})
	_ceba._aggf = make(map[_df.PdfObject]int64)
	_ceba._bbba = make(map[_df.PdfObject]struct{})
	_ceba._ffe = _ceba._abf.AcroForm
	_ceba._cgebag = _ceba._abf.DSS
	if opts != nil {
		_ceba._aadbf = opts.Password
	}
	if encryptOptions != nil {
		_ceba._aeg = encryptOptions
	}
	return _ceba, nil
}

// Encoder returns the font's text encoder.
func (_bdbb pdfFontType3) Encoder() _abg.TextEncoder { return _bdbb._ceed }

// ToImage converts an object to an Image which can be transformed or saved out.
// The image data is decoded and the Image returned.
func (_addaf *XObjectImage) ToImage() (*Image, error) {
	_ebbdg := &Image{}
	if _addaf.Height == nil {
		return nil, _deb.New("\u0068e\u0069\u0067\u0068\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062u\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_ebbdg.Height = *_addaf.Height
	if _addaf.Width == nil {
		return nil, _deb.New("\u0077\u0069\u0064th\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_ebbdg.Width = *_addaf.Width
	if _addaf.BitsPerComponent == nil {
		switch _addaf.Filter.(type) {
		case *_df.CCITTFaxEncoder, *_df.JBIG2Encoder:
			_ebbdg.BitsPerComponent = 1
		case *_df.LZWEncoder, *_df.RunLengthEncoder:
			_ebbdg.BitsPerComponent = 8
		default:
			return nil, _deb.New("\u0062\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006d\u0069\u0073s\u0069\u006e\u0067")
		}
	} else {
		_ebbdg.BitsPerComponent = *_addaf.BitsPerComponent
	}
	_ebbdg.ColorComponents = _addaf.ColorSpace.GetNumComponents()
	_addaf._fgdgd.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _df.MakeInteger(int64(_ebbdg.ColorComponents)))
	_bbedf, _cfbagg := _df.DecodeStream(_addaf._fgdgd)
	if _cfbagg != nil {
		return nil, _cfbagg
	}
	_ebbdg.Data = _bbedf
	if _addaf.Decode != nil {
		_fdfge, _gcddg := _addaf.Decode.(*_df.PdfObjectArray)
		if !_gcddg {
			_bcd.Log.Debug("I\u006e\u0076\u0061\u006cid\u0020D\u0065\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074")
			return nil, _deb.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065")
		}
		_deadg, _bgbee := _fdfge.ToFloat64Array()
		if _bgbee != nil {
			return nil, _bgbee
		}
		switch _addaf.ColorSpace.(type) {
		case *PdfColorspaceDeviceCMYK:
			_ggdbe := _addaf.ColorSpace.DecodeArray()
			if _ggdbe[0] == _deadg[0] && _ggdbe[1] == _deadg[1] && _ggdbe[2] == _deadg[2] && _ggdbe[3] == _deadg[3] {
				_ebbdg._bebgb = _deadg
			}
		default:
			_ebbdg._bebgb = _deadg
		}
	}
	return _ebbdg, nil
}

// ToPdfObject implements interface PdfModel.
func (_cgdd *PdfAnnotationUnderline) ToPdfObject() _df.PdfObject {
	_cgdd.PdfAnnotation.ToPdfObject()
	_bgfde := _cgdd._bfde
	_dfbb := _bgfde.PdfObject.(*_df.PdfObjectDictionary)
	_cgdd.PdfAnnotationMarkup.appendToPdfDictionary(_dfbb)
	_dfbb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0055n\u0064\u0065\u0072\u006c\u0069\u006ee"))
	_dfbb.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _cgdd.QuadPoints)
	return _bgfde
}

// ToInteger convert to an integer format.
func (_gdca *PdfColorLab) ToInteger(bits int) [3]uint32 {
	_fegbg := _faf.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_fegbg * _gdca.L()), uint32(_fegbg * _gdca.A()), uint32(_fegbg * _gdca.B())}
}

// PdfActionMovie represents a movie action.
type PdfActionMovie struct {
	*PdfAction
	Annotation _df.PdfObject
	T          _df.PdfObject
	Operation  _df.PdfObject
}

// Encoder iterates through the list of fonts and returns a working encoder
func (_fege *MultipleFontEncoder) Encoder(rn rune) (_abg.TextEncoder, bool) {
	_fgaec := _fege.CurrentFont
	_eeabc := _fgaec.Encoder()
	_, _ccdb := _eeabc.RuneToCharcode(rn)
	for _cdce := 1; _cdce < len(_fege._fbeed) && !_ccdb; _cdce++ {
		_fgaec = _fege._fbeed[_cdce]
		_eeabc = _fgaec.Encoder()
		_, _ccdb = _eeabc.RuneToCharcode(rn)
		_fege.CurrentFont = _fgaec
	}
	return _eeabc, _ccdb
}

// GetContainingPdfObject returns the container of the outline (indirect object).
func (_edffd *PdfOutline) GetContainingPdfObject() _df.PdfObject { return _edffd._edacg }

// ToPdfObject returns the PDF representation of the VRI dictionary.
func (_fbgaa *VRI) ToPdfObject() *_df.PdfObjectDictionary {
	_ebeee := _df.MakeDict()
	_ebeee.SetIfNotNil(_df.PdfObjectName("\u0043\u0065\u0072\u0074"), _gcedg(_fbgaa.Cert))
	_ebeee.SetIfNotNil(_df.PdfObjectName("\u004f\u0043\u0053\u0050"), _gcedg(_fbgaa.OCSP))
	_ebeee.SetIfNotNil(_df.PdfObjectName("\u0043\u0052\u004c"), _gcedg(_fbgaa.CRL))
	_ebeee.SetIfNotNil("\u0054\u0055", _fbgaa.TU)
	_ebeee.SetIfNotNil("\u0054\u0053", _fbgaa.TS)
	return _ebeee
}

// PdfColorDeviceRGB represents a color in DeviceRGB colorspace with R, G, B components, where component is
// defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorDeviceRGB [3]float64

func (_dcdfd *PdfReader) loadOutlines() (*PdfOutlineTreeNode, error) {
	if _dcdfd._gfdaag.GetCrypter() != nil && !_dcdfd._gfdaag.IsAuthenticated() {
		return nil, _c.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_abccc := _dcdfd._afbaf
	_bbfcc := _abccc.Get("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
	if _bbfcc == nil {
		return nil, nil
	}
	_bcd.Log.Trace("\u002d\u0048\u0061\u0073\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
	_fgggf := _df.ResolveReference(_bbfcc)
	_bcd.Log.Trace("\u004f\u0075t\u006c\u0069\u006ee\u0020\u0072\u006f\u006f\u0074\u003a\u0020\u0025\u0076", _fgggf)
	if _dcbee := _df.IsNullObject(_fgggf); _dcbee {
		_bcd.Log.Trace("\u004f\u0075\u0074li\u006e\u0065\u0020\u0072\u006f\u006f\u0074\u0020\u0069s\u0020n\u0075l\u006c \u002d\u0020\u006e\u006f\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
		return nil, nil
	}
	_dfdb, _abga := _fgggf.(*_df.PdfIndirectObject)
	if !_abga {
		if _, _dgdbe := _df.GetDict(_fgggf); !_dgdbe {
			_bcd.Log.Debug("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020o\u0075\u0074\u006c\u0069\u006e\u0065\u0020r\u006f\u006f\u0074\u0020\u002d\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067")
			return nil, nil
		}
		_bcd.Log.Debug("\u004f\u0075t\u006c\u0069\u006e\u0065\u0020r\u006f\u006f\u0074\u0020\u0069s\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u002e\u0020\u0053\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		_dfdb = _df.MakeIndirectObject(_fgggf)
	}
	_fagee, _abga := _dfdb.PdfObject.(*_df.PdfObjectDictionary)
	if !_abga {
		return nil, _deb.New("\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072y")
	}
	_bcd.Log.Trace("O\u0075\u0074\u006c\u0069ne\u0020r\u006f\u006f\u0074\u0020\u0064i\u0063\u0074\u003a\u0020\u0025\u0076", _fagee)
	_adeab, _, _gefd := _dcdfd.buildOutlineTree(_dfdb, nil, nil, nil)
	if _gefd != nil {
		return nil, _gefd
	}
	_bcd.Log.Trace("\u0052\u0065\u0073\u0075\u006c\u0074\u0069\u006e\u0067\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065:\u0020\u0025\u0076", _adeab)
	return _adeab, nil
}

// NewPdfReaderFromFile creates a new PdfReader from the speficied PDF file.
// If ReaderOpts is nil it will be set to default value from NewReaderOpts.
func NewPdfReaderFromFile(pdfFile string, opts *ReaderOpts) (*PdfReader, *_bf.File, error) {
	const _gadf = "\u006d\u006f\u0064\u0065\u006c\u003a\u004e\u0065\u0077\u0050\u0064f\u0052\u0065\u0061\u0064\u0065\u0072\u0046\u0072\u006f\u006dF\u0069\u006c\u0065"
	_gfccf, _fceab := _bf.Open(pdfFile)
	if _fceab != nil {
		return nil, nil, _fceab
	}
	_bgcde, _fceab := _gafgf(_gfccf, opts, true, _gadf)
	if _fceab != nil {
		_gfccf.Close()
		return nil, nil, _fceab
	}
	_bgcde._effbb = pdfFile
	return _bgcde, _gfccf, nil
}

var ImageHandling ImageHandler = DefaultImageHandler{}

// NewPdfFilespecFromObj creates and returns a new PdfFilespec object.
func NewPdfFilespecFromObj(obj _df.PdfObject) (*PdfFilespec, error) {
	_fdfg := &PdfFilespec{}
	var _ddbff *_df.PdfObjectDictionary
	if _abce, _fagaf := _df.GetIndirect(obj); _fagaf {
		_fdfg._gaafd = _abce
		_bedgd, _gdea := _df.GetDict(_abce.PdfObject)
		if !_gdea {
			_bcd.Log.Debug("\u004f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074i\u006f\u006e\u0061\u0072\u0079\u0020\u0074y\u0070\u0065")
			return nil, _df.ErrTypeError
		}
		_ddbff = _bedgd
	} else if _daccg, _gggf := _df.GetDict(obj); _gggf {
		_fdfg._gaafd = _daccg
		_ddbff = _daccg
	} else {
		_bcd.Log.Debug("O\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0075\u006e\u0065\u0078\u0070e\u0063\u0074\u0065d\u0020(\u0025\u0054\u0029", obj)
		return nil, _df.ErrTypeError
	}
	if _ddbff == nil {
		_bcd.Log.Debug("\u0044i\u0063t\u0069\u006f\u006e\u0061\u0072y\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, _deb.New("\u0064\u0069\u0063t\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	if _acfe := _ddbff.Get("\u0054\u0079\u0070\u0065"); _acfe != nil {
		_dcbcc, _dage := _acfe.(*_df.PdfObjectName)
		if !_dage {
			_bcd.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _acfe)
		} else {
			if *_dcbcc != "\u0046\u0069\u006c\u0065\u0073\u0070\u0065\u0063" {
				_bcd.Log.Trace("\u0055\u006e\u0073\u0075\u0073\u0070e\u0063\u0074\u0065\u0064\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020F\u0069\u006c\u0065\u0073\u0070\u0065\u0063 \u0028\u0025\u0073\u0029", *_dcbcc)
			}
		}
	}
	if _gebcb := _ddbff.Get("\u0046\u0053"); _gebcb != nil {
		_fdfg.FS = _gebcb
	}
	if _cbaa := _ddbff.Get("\u0046"); _cbaa != nil {
		_fdfg.F = _cbaa
	}
	if _ddce := _ddbff.Get("\u0055\u0046"); _ddce != nil {
		_fdfg.UF = _ddce
	}
	if _aagd := _ddbff.Get("\u0044\u004f\u0053"); _aagd != nil {
		_fdfg.DOS = _aagd
	}
	if _abcfd := _ddbff.Get("\u004d\u0061\u0063"); _abcfd != nil {
		_fdfg.Mac = _abcfd
	}
	if _fabf := _ddbff.Get("\u0055\u006e\u0069\u0078"); _fabf != nil {
		_fdfg.Unix = _fabf
	}
	if _dbbga := _ddbff.Get("\u0049\u0044"); _dbbga != nil {
		_fdfg.ID = _dbbga
	}
	if _fgab := _ddbff.Get("\u0056"); _fgab != nil {
		_fdfg.V = _fgab
	}
	if _faff := _ddbff.Get("\u0045\u0046"); _faff != nil {
		_fdfg.EF = _faff
	}
	if _aafgef := _ddbff.Get("\u0052\u0046"); _aafgef != nil {
		_fdfg.RF = _aafgef
	}
	if _ebbd := _ddbff.Get("\u0044\u0065\u0073\u0063"); _ebbd != nil {
		_fdfg.Desc = _ebbd
	}
	if _cdddf := _ddbff.Get("\u0043\u0049"); _cdddf != nil {
		_fdfg.CI = _cdddf
	}
	if _dadda := _ddbff.Get("\u0041\u0046\u0052\u0065\u006c\u0061\u0074\u0069\u006fn\u0073\u0068\u0069\u0070"); _dadda != nil {
		_fdfg.AFRelationship = _dadda
	}
	return _fdfg, nil
}

// NewEmbeddedFileFromObject construct a new EmbeddedFile from supplied object.
func NewEmbeddedFileFromObject(obj _df.PdfObject) (*EmbeddedFile, error) {
	_fffg := _df.TraceToDirectObject(obj)
	_bdcac, _dada := _fffg.(*_df.PdfObjectDictionary)
	if !_dada {
		return nil, _deb.New("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006fb\u006a\u0065\u0063\u0074")
	}
	_dead := _df.TraceToDirectObject(_bdcac.Get("\u0046"))
	if _dead == nil {
		return nil, _deb.New("\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0073\u0074\u0072\u0075\u0063\u0074\u0075\u0072\u0065")
	}
	_deef, _dada := _dead.(*_df.PdfObjectStream)
	if !_dada {
		return nil, _deb.New("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073t\u0072\u0065\u0061\u006d")
	}
	_abfg := _deef.PdfObjectDictionary
	_gdcg := _abfg.Get("\u0050\u0061\u0072\u0061\u006d\u0073")
	if _gdcg == nil {
		return nil, _deb.New("P\u0061\u0072\u0061\u006d\u0073\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061i\u006ca\u0062\u006c\u0065")
	}
	_fgbf, _dada := _gdcg.(*_df.PdfObjectDictionary)
	if !_dada {
		return nil, _deb.New("I\u006e\u0076\u0061\u006cid\u0020P\u0061\u0072\u0061\u006d\u0073 \u006f\u0062\u006a\u0065\u0063\u0074")
	}
	_ffge := ""
	_gbfbb := _fgbf.Get("\u0043\u0068\u0065\u0063\u006b\u0053\u0075\u006d")
	if _gbfbb != nil {
		_ffge = _gbfbb.(*_df.PdfObjectString).Str()
	}
	_ccbaf, _bceaa := _df.DecodeStream(_deef)
	if _bceaa != nil {
		return nil, _bceaa
	}
	_efba := &EmbeddedFile{Content: _ccbaf, Hash: _ffge}
	return _efba, nil
}

// Val returns the color value.
func (_cdef *PdfColorDeviceGray) Val() float64 { return float64(*_cdef) }

func (_eadbg *LTV) getOCSPs(_aagga []*_ed.Certificate, _debe map[string]*_ed.Certificate) ([][]byte, error) {
	_eafge := make([][]byte, 0, len(_aagga))
	for _, _eafceg := range _aagga {
		for _, _ggce := range _eafceg.OCSPServer {
			if _eadbg.CertClient.IsCA(_eafceg) {
				continue
			}
			_agffa, _aabf := _debe[_eafceg.Issuer.CommonName]
			if !_aabf {
				_bcd.Log.Debug("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
				continue
			}
			_, _accgbd, _gegd := _eadbg.OCSPClient.MakeRequest(_ggce, _eafceg, _agffa)
			if _gegd != nil {
				_bcd.Log.Debug("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076", _gegd)
				continue
			}
			_eafge = append(_eafge, _accgbd)
		}
	}
	return _eafge, nil
}

// NewPdfOutlineItem returns an initialized PdfOutlineItem.
func NewPdfOutlineItem() *PdfOutlineItem {
	_ggdb := &PdfOutlineItem{_acfea: _df.MakeIndirectObject(_df.MakeDict())}
	_ggdb._dcgc = _ggdb
	return _ggdb
}

// NewPdfColorspaceDeviceN returns an initialized PdfColorspaceDeviceN.
func NewPdfColorspaceDeviceN() *PdfColorspaceDeviceN { _gegg := &PdfColorspaceDeviceN{}; return _gegg }

func (_cdfb *XObjectImage) getParamsDict() *_df.PdfObjectDictionary {
	_dgdbcg := _df.MakeDict()
	_dgdbcg.Set("\u0057\u0069\u0064t\u0068", _df.MakeInteger(*_cdfb.Width))
	_dgdbcg.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _df.MakeInteger(*_cdfb.Height))
	_dgdbcg.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _df.MakeInteger(int64(_cdfb.ColorSpace.GetNumComponents())))
	_dgdbcg.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _df.MakeInteger(*_cdfb.BitsPerComponent))
	return _dgdbcg
}

// WriteString outputs the object as it is to be written to file.
func (_fefa *PdfTransformParamsDocMDP) WriteString() string {
	return _fefa.ToPdfObject().WriteString()
}

// Duplicate creates a duplicate page based on the current one and returns it.
func (_becab *PdfPage) Duplicate() *PdfPage {
	_bdcf := *_becab
	_bdcf._gfcee = _df.MakeDict()
	_bdcf._gcced = _df.MakeIndirectObject(_bdcf._gfcee)
	_bdcf._agacd = *_bdcf._gfcee
	return &_bdcf
}

func _dacefe() *modelManager {
	_efdce := modelManager{}
	_efdce._cebgf = map[PdfModel]_df.PdfObject{}
	_efdce._fdge = map[_df.PdfObject]PdfModel{}
	return &_efdce
}

func _cadgb(_ggfeg _df.PdfObject) (map[_abg.CharCode]float64, error) {
	if _ggfeg == nil {
		return nil, nil
	}
	_bfcbe, _ffceb := _df.GetArray(_ggfeg)
	if !_ffceb {
		return nil, nil
	}
	_aabd := map[_abg.CharCode]float64{}
	_efeab := _bfcbe.Len()
	for _edbfb := 0; _edbfb < _efeab-1; _edbfb++ {
		_gfff := _df.TraceToDirectObject(_bfcbe.Get(_edbfb))
		_gagf, _dggg := _df.GetIntVal(_gfff)
		if !_dggg {
			return nil, _c.Errorf("\u0042a\u0064\u0020\u0066\u006fn\u0074\u0020\u0057\u0020\u006fb\u006a0\u003a \u0069\u003d\u0025\u0064\u0020\u0025\u0023v", _edbfb, _gfff)
		}
		_edbfb++
		if _edbfb > _efeab-1 {
			return nil, _c.Errorf("\u0042\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020a\u0072\u0072\u0061\u0079\u003a\u0020\u0061\u0072\u0072\u0032=\u0025\u002b\u0076", _bfcbe)
		}
		_dbccf := _df.TraceToDirectObject(_bfcbe.Get(_edbfb))
		switch _dbccf.(type) {
		case *_df.PdfObjectArray:
			_ddbee, _ := _df.GetArray(_dbccf)
			if _gecdd, _eeec := _ddbee.ToFloat64Array(); _eeec == nil {
				for _cdega := 0; _cdega < len(_gecdd); _cdega++ {
					_aabd[_abg.CharCode(_gagf+_cdega)] = _gecdd[_cdega]
				}
			} else {
				return nil, _c.Errorf("\u0042\u0061\u0064 \u0066\u006f\u006e\u0074 \u0057\u0020\u0061\u0072\u0072\u0061\u0079 \u006f\u0062\u006a\u0031\u003a\u0020\u0069\u003d\u0025\u0064\u0020\u0025\u0023\u0076", _edbfb, _dbccf)
			}
		case *_df.PdfObjectInteger:
			_cafa, _geceb := _df.GetIntVal(_dbccf)
			if !_geceb {
				return nil, _c.Errorf("\u0042\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020\u0069\u006e\u0074\u0020\u006f\u0062\u006a\u0031\u003a\u0020\u0069\u003d\u0025\u0064 %\u0023\u0076", _edbfb, _dbccf)
			}
			_edbfb++
			if _edbfb > _efeab-1 {
				return nil, _c.Errorf("\u0042\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020a\u0072\u0072\u0061\u0079\u003a\u0020\u0061\u0072\u0072\u0032=\u0025\u002b\u0076", _bfcbe)
			}
			_dadf := _bfcbe.Get(_edbfb)
			_bdef, _ddac := _df.GetNumberAsFloat(_dadf)
			if _ddac != nil {
				return nil, _c.Errorf("\u0042\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020\u0069\u006e\u0074\u0020\u006f\u0062\u006a\u0032\u003a\u0020\u0069\u003d\u0025\u0064 %\u0023\u0076", _edbfb, _dadf)
			}
			for _gcfda := _gagf; _gcfda <= _cafa; _gcfda++ {
				_aabd[_abg.CharCode(_gcfda)] = _bdef
			}
		default:
			return nil, _c.Errorf("\u0042\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057 \u006f\u0062\u006a\u0031\u0020\u0074\u0079p\u0065\u003a\u0020\u0069\u003d\u0025\u0064\u0020\u0025\u0023\u0076", _edbfb, _dbccf)
		}
	}
	return _aabd, nil
}

func (_adfbdc *PdfWriter) addObjects(_fadac _df.PdfObject) error {
	_bcd.Log.Trace("\u0041d\u0064i\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0073\u0021")
	if _fgdbg, _afcfc := _fadac.(*_df.PdfIndirectObject); _afcfc {
		_bcd.Log.Trace("\u0049\u006e\u0064\u0069\u0072\u0065\u0063\u0074")
		_bcd.Log.Trace("\u002d \u0025\u0073\u0020\u0028\u0025\u0070)", _fadac, _fgdbg)
		_bcd.Log.Trace("\u002d\u0020\u0025\u0073", _fgdbg.PdfObject)
		if _adfbdc.addObject(_fgdbg) {
			_dgdbeb := _adfbdc.addObjects(_fgdbg.PdfObject)
			if _dgdbeb != nil {
				return _dgdbeb
			}
		}
		return nil
	}
	if _efbca, _gbbfdg := _fadac.(*_df.PdfObjectStream); _gbbfdg {
		_bcd.Log.Trace("\u0053\u0074\u0072\u0065\u0061\u006d")
		_bcd.Log.Trace("\u002d \u0025\u0073\u0020\u0025\u0070", _fadac, _fadac)
		if _adfbdc.addObject(_efbca) {
			_dddgd := _adfbdc.addObjects(_efbca.PdfObjectDictionary)
			if _dddgd != nil {
				return _dddgd
			}
		}
		return nil
	}
	if _egbdd, _facad := _fadac.(*_df.PdfObjectDictionary); _facad {
		_bcd.Log.Trace("\u0044\u0069\u0063\u0074")
		_bcd.Log.Trace("\u002d\u0020\u0025\u0073", _fadac)
		for _, _bggff := range _egbdd.Keys() {
			_ecfcd := _egbdd.Get(_bggff)
			if _acad, _ffea := _ecfcd.(*_df.PdfObjectReference); _ffea {
				_ecfcd = _acad.Resolve()
				_egbdd.Set(_bggff, _ecfcd)
			}
			if _bggff != "\u0050\u0061\u0072\u0065\u006e\u0074" {
				if _dccgfb := _adfbdc.addObjects(_ecfcd); _dccgfb != nil {
					return _dccgfb
				}
			} else {
				if _, _fbegf := _ecfcd.(*_df.PdfObjectNull); _fbegf {
					continue
				}
				if _gbegbf := _adfbdc.hasObject(_ecfcd); !_gbegbf {
					_bcd.Log.Debug("P\u0061\u0072\u0065\u006e\u0074\u0020o\u0062\u006a\u0020\u006e\u006f\u0074 \u0061\u0064\u0064\u0065\u0064\u0020\u0079e\u0074\u0021\u0021\u0020\u0025\u0054\u0020\u0025\u0070\u0020%\u0076", _ecfcd, _ecfcd, _ecfcd)
					_adfbdc._acgefe[_ecfcd] = append(_adfbdc._acgefe[_ecfcd], _egbdd)
				}
			}
		}
		return nil
	}
	if _egfc, _afaad := _fadac.(*_df.PdfObjectArray); _afaad {
		_bcd.Log.Trace("\u0041\u0072\u0072a\u0079")
		_bcd.Log.Trace("\u002d\u0020\u0025\u0073", _fadac)
		if _egfc == nil {
			return _deb.New("\u0061\u0072\u0072a\u0079\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		}
		for _cdbfe, _egbddb := range _egfc.Elements() {
			if _gbdd, _ggbgc := _egbddb.(*_df.PdfObjectReference); _ggbgc {
				_egbddb = _gbdd.Resolve()
				_egfc.Set(_cdbfe, _egbddb)
			}
			if _gfbdd := _adfbdc.addObjects(_egbddb); _gfbdd != nil {
				return _gfbdd
			}
		}
		return nil
	}
	if _, _dcde := _fadac.(*_df.PdfObjectReference); _dcde {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0062\u0065\u0020\u0061\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u002d\u0020\u0067\u006f\u0074 \u0025\u0023\u0076\u0021", _fadac)
		return _deb.New("r\u0065\u0066\u0065\u0072en\u0063e\u0020\u006e\u006f\u0074\u0020a\u006c\u006c\u006f\u0077\u0065\u0064")
	}
	return nil
}

// ColorToRGB verifies that the input color is an RGB color. Method exists in
// order to satisfy the PdfColorspace interface.
func (_gefg *PdfColorspaceDeviceRGB) ColorToRGB(color PdfColor) (PdfColor, error) {
	_acbg, _cdgg := color.(*PdfColorDeviceRGB)
	if !_cdgg {
		_bcd.Log.Debug("\u0049\u006e\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006f\u0072 \u006e\u006f\u0074\u0020\u0064\u0065\u0076\u0069\u0063\u0065 \u0052\u0047\u0042")
		return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	return _acbg, nil
}

const (
	XObjectTypeUndefined XObjectType = iota
	XObjectTypeImage
	XObjectTypeForm
	XObjectTypePS
	XObjectTypeUnknown
)

// GetContainingPdfObject returns the page as a dictionary within an PdfIndirectObject.
func (_dedea *PdfPage) GetContainingPdfObject() _df.PdfObject { return _dedea._gcced }

// GetCatalogStructTreeRoot gets the catalog StructTreeRoot object.
func (_aebca *PdfReader) GetCatalogStructTreeRoot() (_df.PdfObject, bool) {
	_edeed := _df.ResolveReference(_aebca._afbaf.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065e\u0052\u006f\u006f\u0074"))
	if _edeed == nil {
		return nil, false
	}
	if !_aebca._edbbdf {
		_cdcfc := _aebca.traverseObjectData(_edeed)
		if _cdcfc != nil {
			_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046a\u0069\u006c\u0065\u0064\u0020t\u006f\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0065\u0020\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065\u0065\u0052\u006f\u006f\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029", _cdcfc)
			return nil, false
		}
	}
	return _edeed, true
}

// IsFitWindow returns the value of the fitWindow flag.
func (_bfabf *ViewerPreferences) IsFitWindow() bool {
	if _bfabf._eadcd == nil {
		return false
	}
	return *_bfabf._eadcd
}

func (_gbba *PdfReader) newPdfActionSubmitFormFromDict(_efdc *_df.PdfObjectDictionary) (*PdfActionSubmitForm, error) {
	_cfge, _dde := _cadf(_efdc.Get("\u0046"))
	if _dde != nil {
		return nil, _dde
	}
	return &PdfActionSubmitForm{F: _cfge, Fields: _efdc.Get("\u0046\u0069\u0065\u006c\u0064\u0073"), Flags: _efdc.Get("\u0046\u006c\u0061g\u0073")}, nil
}

// AppendContentBytes creates a PDF stream from `cs` and appends it to the
// array of streams specified by the pages's Contents entry.
// If `wrapContents` is true, the content stream of the page is wrapped using
// a `q/Q` operator pair, so that its state does not affect the appended
// content stream.
func (_acfcd *PdfPage) AppendContentBytes(cs []byte, wrapContents bool) error {
	_baba := _acfcd.GetContentStreamObjs()
	wrapContents = wrapContents && len(_baba) > 0
	_agdef := _df.NewFlateEncoder()
	_badgg := _df.MakeArray()
	if wrapContents {
		_bcdfd, _gege := _df.MakeStream([]byte("\u0071\u000a"), _agdef)
		if _gege != nil {
			return _gege
		}
		_badgg.Append(_bcdfd)
	}
	_badgg.Append(_baba...)
	if wrapContents {
		_ccgbf, _ceca := _df.MakeStream([]byte("\u000a\u0051\u000a"), _agdef)
		if _ceca != nil {
			return _ceca
		}
		_badgg.Append(_ccgbf)
	}
	_edefb, _cddfe := _df.MakeStream(cs, _agdef)
	if _cddfe != nil {
		return _cddfe
	}
	_badgg.Append(_edefb)
	_acfcd.Contents = _badgg
	return nil
}

// PdfOutlineItem represents an outline item dictionary (Table 153 - pp. 376 - 377).
type PdfOutlineItem struct {
	PdfOutlineTreeNode
	Title  *_df.PdfObjectString
	Parent *PdfOutlineTreeNode
	Prev   *PdfOutlineTreeNode
	Next   *PdfOutlineTreeNode
	Count  *int64
	Dest   _df.PdfObject
	A      _df.PdfObject
	SE     _df.PdfObject
	C      _df.PdfObject
	F      _df.PdfObject
	_acfea *_df.PdfIndirectObject
}

var (
	StructureTypeParagraph       = "\u0050"
	StructureTypeHeader          = "\u0048"
	StructureTypeHeading1        = "\u0048\u0031"
	StructureTypeHeading2        = "\u0048\u0032"
	StructureTypeHeading3        = "\u0048\u0033"
	StructureTypeHeading4        = "\u0048\u0034"
	StructureTypeHeading5        = "\u0048\u0035"
	StructureTypeHeading6        = "\u0048\u0036"
	StructureTypeList            = "\u004c"
	StructureTypeListItem        = "\u004c\u0049"
	StructureTypeLabel           = "\u004c\u0062\u006c"
	StructureTypeListBody        = "\u004c\u0042\u006fd\u0079"
	StructureTypeTable           = "\u0054\u0061\u0062l\u0065"
	StructureTypeTableRow        = "\u0054\u0052"
	StructureTypeTableHeaderCell = "\u0054\u0048"
	StructureTypeTableData       = "\u0054\u0044"
	StructureTypeTableHead       = "\u0054\u0048\u0065a\u0064"
	StructureTypeTableBody       = "\u0054\u0042\u006fd\u0079"
	StructureTypeTableFooter     = "\u0054\u0046\u006fo\u0074"
)

// Evaluate runs the function on the passed in slice and returns the results.
func (_ddebe *PdfFunctionType0) Evaluate(x []float64) ([]float64, error) {
	if len(x) != _ddebe.NumInputs {
		_bcd.Log.Error("\u004eu\u006d\u0062e\u0072\u0020\u006f\u0066 \u0069\u006e\u0070u\u0074\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061tc\u0068\u0069\u006eg\u0020\u0077h\u0061\u0074\u0020\u0069\u0073\u0020n\u0065\u0065d\u0065\u0064")
		return nil, _deb.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	}
	if _ddebe._fdfc == nil {
		_fcee := _ddebe.processSamples()
		if _fcee != nil {
			return nil, _fcee
		}
	}
	_bcgg := _ddebe.Encode
	if _bcgg == nil {
		_bcgg = []float64{}
		for _agefg := 0; _agefg < len(_ddebe.Size); _agefg++ {
			_bcgg = append(_bcgg, 0)
			_bcgg = append(_bcgg, float64(_ddebe.Size[_agefg]-1))
		}
	}
	_dcfcde := _ddebe.Decode
	if _dcfcde == nil {
		_dcfcde = _ddebe.Range
	}
	_fegfc := make([]int, len(x))
	for _gfeb := 0; _gfeb < len(x); _gfeb++ {
		_bfab := x[_gfeb]
		_bded := _faf.Min(_faf.Max(_bfab, _ddebe.Domain[2*_gfeb]), _ddebe.Domain[2*_gfeb+1])
		_gfcb := _bge.LinearInterpolate(_bded, _ddebe.Domain[2*_gfeb], _ddebe.Domain[2*_gfeb+1], _bcgg[2*_gfeb], _bcgg[2*_gfeb+1])
		_eacae := _faf.Min(_faf.Max(_gfcb, 0), float64(_ddebe.Size[_gfeb]-1))
		_gcbe := int(_faf.Floor(_eacae + 0.5))
		if _gcbe < 0 {
			_gcbe = 0
		} else if _gcbe > _ddebe.Size[_gfeb] {
			_gcbe = _ddebe.Size[_gfeb] - 1
		}
		_fegfc[_gfeb] = _gcbe
	}
	_dbfgg := _fegfc[0]
	for _dbbbf := 1; _dbbbf < _ddebe.NumInputs; _dbbbf++ {
		_egcg := _fegfc[_dbbbf]
		for _cfdef := 0; _cfdef < _dbbbf; _cfdef++ {
			_egcg *= _ddebe.Size[_cfdef]
		}
		_dbfgg += _egcg
	}
	_dbfgg *= _ddebe.NumOutputs
	var _dgcgg []float64
	for _egfg := 0; _egfg < _ddebe.NumOutputs; _egfg++ {
		_ffefdg := _dbfgg + _egfg
		if _ffefdg >= len(_ddebe._fdfc) {
			_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u003a \u006e\u006ft\u0020\u0065\u006eo\u0075\u0067\u0068\u0020\u0069\u006ep\u0075\u0074\u0020sa\u006dp\u006c\u0065\u0073\u0020\u0074\u006f\u0020d\u0065\u0074\u0065\u0072\u006d\u0069\u006e\u0065\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0076\u0061lu\u0065\u0073\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e")
			continue
		}
		_gbad := _ddebe._fdfc[_ffefdg]
		_abdbf := _bge.LinearInterpolate(float64(_gbad), 0, _faf.Pow(2, float64(_ddebe.BitsPerSample)), _dcfcde[2*_egfg], _dcfcde[2*_egfg+1])
		_ecafa := _faf.Min(_faf.Max(_abdbf, _ddebe.Range[2*_egfg]), _ddebe.Range[2*_egfg+1])
		_dgcgg = append(_dgcgg, _ecafa)
	}
	return _dgcgg, nil
}

// PdfInfo holds document information that will overwrite
// document information global variables defined above.
type PdfInfo struct {
	Title        *_df.PdfObjectString
	Author       *_df.PdfObjectString
	Subject      *_df.PdfObjectString
	Keywords     *_df.PdfObjectString
	Creator      *_df.PdfObjectString
	Producer     *_df.PdfObjectString
	CreationDate *PdfDate
	ModifiedDate *PdfDate
	Trapped      *_df.PdfObjectName
	_bcec        *_df.PdfObjectDictionary
}

// B returns the value of the B component of the color.
func (_cdbd *PdfColorLab) B() float64 { return _cdbd[2] }

// NewPdfAnnotationTrapNet returns a new trapnet annotation.
func NewPdfAnnotationTrapNet() *PdfAnnotationTrapNet {
	_dbbb := NewPdfAnnotation()
	_acfa := &PdfAnnotationTrapNet{}
	_acfa.PdfAnnotation = _dbbb
	_dbbb.SetContext(_acfa)
	return _acfa
}

// Reset sets the multi font encoder to its initial state.
func (_adcdd *MultipleFontEncoder) Reset() { _adcdd.CurrentFont = _adcdd._fbeed[0] }

// PrintArea returns the value of the printArea.
func (_bdfdd *ViewerPreferences) PrintArea() PageBoundary { return _bdfdd._fbede }

// GetContext returns the context of the outline tree node, which is either a
// *PdfOutline or a *PdfOutlineItem. The method returns nil for uninitialized
// tree nodes.
func (_gaaaf *PdfOutlineTreeNode) GetContext() PdfModel {
	if _fdebg, _gefgd := _gaaaf._dcgc.(*PdfOutline); _gefgd {
		return _fdebg
	}
	if _ddbdf, _ecfdc := _gaaaf._dcgc.(*PdfOutlineItem); _ecfdc {
		return _ddbdf
	}
	_bcd.Log.Debug("\u0045\u0052RO\u0052\u0020\u0049n\u0076\u0061\u006c\u0069d o\u0075tl\u0069\u006e\u0065\u0020\u0074\u0072\u0065e \u006e\u006f\u0064\u0065\u0020\u0069\u0074e\u006d")
	return nil
}

// SetPdfProducer sets the Producer attribute of the output PDF.
func SetPdfProducer(producer string) { _gcdec.Lock(); defer _gcdec.Unlock(); _fbcad = producer }

// EncryptionAlgorithm is used in EncryptOptions to change the default algorithm used to encrypt the document.
type EncryptionAlgorithm int

// GetCharMetrics returns the character metrics for the specified character code.  A bool flag is
// returned to indicate whether or not the entry was found in the glyph to charcode mapping.
// How it works:
//  1. Return a value the /Widths array (charWidths) if there is one.
//  2. If the font has the same name as a standard 14 font then return width=250.
//  3. Otherwise return no match and let the caller substitute a default.
func (_bbgec pdfFontSimple) GetCharMetrics(code _abg.CharCode) (_da.CharMetrics, bool) {
	if _dcgfa, _gegbe := _bbgec._ffefd[code]; _gegbe {
		return _da.CharMetrics{Wx: _dcgfa}, true
	}
	if _da.IsStdFont(_da.StdFontName(_bbgec._gddcf)) {
		return _da.CharMetrics{Wx: 250}, true
	}
	return _da.CharMetrics{}, false
}

func (_eaece *pdfFontSimple) addEncoding() error {
	var (
		_gcfc string
		_aafb map[_abg.CharCode]_abg.GlyphName
		_bedd _abg.SimpleEncoder
	)
	if _eaece.Encoder() != nil {
		_fbfgb, _eddbf := _eaece.Encoder().(_abg.SimpleEncoder)
		if _eddbf && _fbfgb != nil {
			_gcfc = _fbfgb.BaseName()
		}
	}
	if _eaece.Encoding != nil {
		_bbgbf, _geea, _bgbb := _eaece.getFontEncoding()
		if _bgbb != nil {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0073\u0065F\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0053u\u0062t\u0079\u0070\u0065\u003d\u0025\u0071\u0020\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003d\u0025\u0073 \u0028\u0025\u0054\u0029\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _eaece._gddcf, _eaece._fgfae, _eaece.Encoding, _eaece.Encoding, _bgbb)
			return _bgbb
		}
		if _bbgbf != "" {
			_gcfc = _bbgbf
		}
		_aafb = _geea
		_bedd, _bgbb = _abg.NewSimpleTextEncoder(_gcfc, _aafb)
		if _bgbb != nil {
			return _bgbb
		}
	}
	if _bedd == nil {
		_affcf := _eaece._agggb
		if _affcf != nil {
			switch _eaece._fgfae {
			case "\u0054\u0079\u0070e\u0031":
				if _affcf.fontFile != nil && _affcf.fontFile._dgacb != nil {
					_bcd.Log.Debug("\u0055\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006et\u0046\u0069\u006c\u0065")
					_bedd = _affcf.fontFile._dgacb
				}
			case "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065":
				if _affcf._dcgaa != nil {
					_bcd.Log.Debug("\u0055s\u0069n\u0067\u0020\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0032")
					_dcbgg, _cadbe := _affcf._dcgaa.MakeEncoder()
					if _cadbe == nil {
						_bedd = _dcbgg
					}
					if _eaece._afcbd == nil {
						_eaece._afcbd = _affcf._dcgaa.MakeToUnicode()
					}
				}
			}
		}
	}
	if _bedd != nil {
		if _aafb != nil {
			_bcd.Log.Trace("\u0064\u0069\u0066fe\u0072\u0065\u006e\u0063\u0065\u0073\u003d\u0025\u002b\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _aafb, _eaece.baseFields())
			_bedd = _abg.ApplyDifferences(_bedd, _aafb)
		}
		_eaece.SetEncoder(_bedd)
	}
	return nil
}

func (_gdead *Image) resampleLowBits(_eedaa []uint32) {
	_dcge := _bge.BytesPerLine(int(_gdead.Width), int(_gdead.BitsPerComponent), _gdead.ColorComponents)
	_eaebb := make([]byte, _gdead.ColorComponents*_dcge*int(_gdead.Height))
	_eeefa := int(_gdead.BitsPerComponent) * _gdead.ColorComponents * int(_gdead.Width)
	_ebggb := uint8(8)
	var (
		_cbecg, _ddgfe int
		_ffegb         uint32
	)
	for _eeggf := 0; _eeggf < int(_gdead.Height); _eeggf++ {
		_ddgfe = _eeggf * _dcge
		for _fdee := 0; _fdee < _eeefa; _fdee++ {
			_ffegb = _eedaa[_cbecg]
			_ebggb -= uint8(_gdead.BitsPerComponent)
			_eaebb[_ddgfe] |= byte(_ffegb) << _ebggb
			if _ebggb == 0 {
				_ebggb = 8
				_ddgfe++
			}
			_cbecg++
		}
	}
	_gdead.Data = _eaebb
}

func (_eff *PdfReader) newPdfActionThreadFromDict(_cedf *_df.PdfObjectDictionary) (*PdfActionThread, error) {
	_cbdc, _aca := _cadf(_cedf.Get("\u0046"))
	if _aca != nil {
		return nil, _aca
	}
	return &PdfActionThread{D: _cedf.Get("\u0044"), B: _cedf.Get("\u0042"), F: _cbdc}, nil
}

// NewPdfActionSound returns a new "sound" action.
func NewPdfActionSound() *PdfActionSound {
	_ee := NewPdfAction()
	_agg := &PdfActionSound{}
	_agg.PdfAction = _ee
	_ee.SetContext(_agg)
	return _agg
}

// DecodeArray returns the range of color component values in DeviceRGB colorspace.
func (_deba *PdfColorspaceDeviceRGB) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_ggfe pdfCIDFontType2) GetCharMetrics(code _abg.CharCode) (_da.CharMetrics, bool) {
	if _egbdf, _efdb := _ggfe._ddggg[code]; _efdb {
		return _da.CharMetrics{Wx: _egbdf}, true
	}
	_eccfd := rune(code)
	_afcae, _fgec := _ggfe._dbcecg[_eccfd]
	if !_fgec {
		_afcae = int(_ggfe._feab)
	}
	return _da.CharMetrics{Wx: float64(_afcae)}, true
}

// IsTiling specifies if the pattern is a tiling pattern.
func (_fbdg *PdfPattern) IsTiling() bool { return _fbdg.PatternType == 1 }

// String returns a string representation of PdfTransformParamsDocMDP.
func (_ddbegb *PdfTransformParamsDocMDP) String() string {
	return _c.Sprintf("\u0025\u0073\u0020\u0050\u003a\u0020\u0025\u0073\u0020V\u003a\u0020\u0025\u0073", _ddbegb.Type, _ddbegb.P, _ddbegb.V)
}

// SetCatalogStructTreeRoot sets the catalog struct tree root object.
func (_eceac *PdfWriter) SetCatalogStructTreeRoot(tree _df.PdfObject) error {
	if tree == nil {
		_eceac._gdee.Remove("\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065e\u0052\u006f\u006f\u0074")
		return nil
	}
	_eceac._gdee.Set("\u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065e\u0052\u006f\u006f\u0074", tree)
	return _eceac.addObjects(tree)
}

func _efbda(_ggga *_df.PdfIndirectObject) (*PdfOutline, error) {
	_efcg, _bdad := _ggga.PdfObject.(*_df.PdfObjectDictionary)
	if !_bdad {
		return nil, _c.Errorf("\u006f\u0075\u0074l\u0069\u006e\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_bega := NewPdfOutline()
	if _ccfdf := _efcg.Get("\u0054\u0079\u0070\u0065"); _ccfdf != nil {
		_gegae, _cagb := _ccfdf.(*_df.PdfObjectName)
		if _cagb {
			if *_gegae != "\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073" {
				_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u0020\u0054y\u0070\u0065\u0020\u0021\u003d\u0020\u004f\u0075\u0074l\u0069\u006e\u0065s\u0020(\u0025\u0073\u0029", *_gegae)
			}
		}
	}
	if _aggcc := _efcg.Get("\u0043\u006f\u0075n\u0074"); _aggcc != nil {
		_cccaa, _feaab := _df.GetNumberAsInt64(_aggcc)
		if _feaab != nil {
			return nil, _feaab
		}
		_bega.Count = &_cccaa
	}
	return _bega, nil
}

// GetContainingPdfObject implements interface PdfModel.
func (_fcaa *PdfAnnotation) GetContainingPdfObject() _df.PdfObject { return _fcaa._bfde }

const (
	BorderEffectNoEffect BorderEffect = iota
	BorderEffectCloudy   BorderEffect = iota
)

// PdfFunction interface represents the common methods of a function in PDF.
type PdfFunction interface {
	Evaluate([]float64) ([]float64, error)
	ToPdfObject() _df.PdfObject
}

// ColorAt returns the color of the image pixel specified by the x and y coordinates.
func (_gafgc *Image) ColorAt(x, y int) (_b.Color, error) {
	_edgbf := _bge.BytesPerLine(int(_gafgc.Width), int(_gafgc.BitsPerComponent), _gafgc.ColorComponents)
	switch _gafgc.ColorComponents {
	case 1:
		return _bge.ColorAtGrayscale(x, y, int(_gafgc.BitsPerComponent), _edgbf, _gafgc.Data, _gafgc._bebgb)
	case 3:
		return _bge.ColorAtNRGBA(x, y, int(_gafgc.Width), _edgbf, int(_gafgc.BitsPerComponent), _gafgc.Data, _gafgc._gebab, _gafgc._bebgb)
	case 4:
		return _bge.ColorAtCMYK(x, y, int(_gafgc.Width), _gafgc.Data, _gafgc._bebgb)
	}
	_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 i\u006da\u0067\u0065\u002e\u0020\u0025\u0064\u0020\u0063\u006f\u006d\u0070\u006fn\u0065\u006e\u0074\u0073\u002c\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073\u0020\u0070\u0065\u0072 \u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _gafgc.ColorComponents, _gafgc.BitsPerComponent)
	return nil, _deb.New("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006d\u0061g\u0065 \u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065")
}

func (_acedc *pdfFontSimple) getFontEncoding() (_fedb string, _cebe map[_abg.CharCode]_abg.GlyphName, _bdfec error) {
	_fedb = "\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"
	if _ecafb, _degd := _cefee[_acedc._gddcf]; _degd {
		_fedb = _ecafb
	} else if _acedc.fontFlags()&_gfbe != 0 {
		for _fdeba, _afbf := range _cefee {
			if _gc.Contains(_acedc._gddcf, _fdeba) {
				_fedb = _afbf
				break
			}
		}
	}
	if _acedc.Encoding == nil {
		return _fedb, nil, nil
	}
	switch _bgcd := _acedc.Encoding.(type) {
	case *_df.PdfObjectName:
		return string(*_bgcd), nil, nil
	case *_df.PdfObjectDictionary:
		_eaee, _agac := _df.GetName(_bgcd.Get("\u0042\u0061\u0073e\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
		if _agac {
			_fedb = _eaee.String()
		}
		if _eeaef := _bgcd.Get("D\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073"); _eeaef != nil {
			_cbeee, _ccdgc := _df.GetArray(_eeaef)
			if !_ccdgc {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042a\u0064\u0020\u0066on\u0074\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u003d\u0025\u002b\u0076\u0020\u0044\u0069f\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073=\u0025\u0054", _bgcd, _bgcd.Get("D\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073"))
				return "", nil, _df.ErrTypeError
			}
			_cebe, _bdfec = _abg.FromFontDifferences(_cbeee)
		}
		return _fedb, _cebe, _bdfec
	default:
		_bcd.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0061\u006d\u0065\u0020\u006f\u0072\u0020\u0064\u0069\u0063t\u0020\u0028\u0025\u0054\u0029\u0020\u0025\u0073", _acedc.Encoding, _acedc.Encoding)
		return "", nil, _df.ErrTypeError
	}
}

// ToGoTime returns the date in time.Time format.
func (_ecfdg PdfDate) ToGoTime() _fa.Time {
	_gaecf := int(_ecfdg._gabf*60*60 + _ecfdg._fgeefd*60)
	switch _ecfdg._cefda {
	case '-':
		_gaecf = -_gaecf
	case 'Z':
		_gaecf = 0
	}
	_cafca := _c.Sprintf("\u0055\u0054\u0043\u0025\u0063\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064", _ecfdg._cefda, _ecfdg._gabf, _ecfdg._fgeefd)
	_aefdc := _fa.FixedZone(_cafca, _gaecf)
	return _fa.Date(int(_ecfdg._gfddd), _fa.Month(_ecfdg._dgfba), int(_ecfdg._bgggf), int(_ecfdg._deagge), int(_ecfdg._bbcbg), int(_ecfdg._dgabf), 0, _aefdc)
}

// Optimizer is the interface that performs optimization of PDF object structure for output writing.
//
// Optimize receives a slice of input `objects`, performs optimization, including removing, replacing objects and
// output the optimized slice of objects.
type Optimizer interface {
	Optimize(_eaag []_df.PdfObject) ([]_df.PdfObject, error)
}

// NewStructTreeRoot creates a new structure tree root dictionary.
func NewStructTreeRoot() *StructTreeRoot {
	return &StructTreeRoot{K: []*KDict{}, RoleMap: _df.MakeDict(), ParentTreeNextKey: 0}
}

func (_ddcc *PdfReader) newPdfActionMovieFromDict(_dace *_df.PdfObjectDictionary) (*PdfActionMovie, error) {
	return &PdfActionMovie{Annotation: _dace.Get("\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e"), T: _dace.Get("\u0054"), Operation: _dace.Get("\u004fp\u0065\u0072\u0061\u0074\u0069\u006fn")}, nil
}

func (_eddedc *PdfWriter) writeObjectsInStreams(_ggadca map[_df.PdfObject]bool) error {
	for _, _cefg := range _eddedc._ceeac {
		if _gcafg := _ggadca[_cefg]; _gcafg {
			continue
		}
		_efgab := int64(0)
		switch _gbgcfa := _cefg.(type) {
		case *_df.PdfIndirectObject:
			_efgab = _gbgcfa.ObjectNumber
		case *_df.PdfObjectStream:
			_efgab = _gbgcfa.ObjectNumber
		case *_df.PdfObjectStreams:
			_efgab = _gbgcfa.ObjectNumber
		case *_df.PdfObjectDictionary, *_df.PdfObjectString:
		default:
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075p\u0070\u006f\u0072t\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069n\u0020wr\u0069\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0054\u0020\u0028\u0074\u0079\u0070\u0065\u0020\u0025\u0054\u0029", _cefg, _gbgcfa)
			return ErrTypeCheck
		}
		if _eddedc._fcdg != nil && _cefg != _eddedc._deega {
			_gggce := _eddedc._fcdg.Encrypt(_cefg, _efgab, 0)
			if _gggce != nil {
				_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067\u0020(%\u0073\u0029", _gggce)
				return _gggce
			}
		}
		_eddedc.writeObject(int(_efgab), _cefg)
	}
	return nil
}

// AlphaMapFunc represents a alpha mapping function: byte -> byte. Can be used for
// thresholding the alpha channel, i.e. setting all alpha values below threshold to transparent.
type AlphaMapFunc func(_gefed byte) byte

// SetPdfModifiedDate sets the ModDate attribute of the output PDF.
func SetPdfModifiedDate(modifiedDate _fa.Time) {
	_gcdec.Lock()
	defer _gcdec.Unlock()
	_dfbeb = modifiedDate
}

// GetPage returns the PdfPage model for the specified page number.
func (_agfac *PdfReader) GetPage(pageNumber int) (*PdfPage, error) {
	if _agfac._gfdaag.GetCrypter() != nil && !_agfac._gfdaag.IsAuthenticated() {
		return nil, _c.Errorf("\u0066\u0069\u006c\u0065\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	if len(_agfac._dcfee) < pageNumber {
		return nil, _deb.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0070\u0061\u0067\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0028\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0074o\u006f\u0020\u0073\u0068\u006f\u0072\u0074\u0029")
	}
	_gegdc := pageNumber - 1
	if _gegdc < 0 {
		return nil, _c.Errorf("\u0070\u0061\u0067\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0069\u006e\u0067\u0020\u006d\u0075\u0073t\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0061\u0074\u0020\u0031")
	}
	_ggbdae := _agfac.PageList[_gegdc]
	return _ggbdae, nil
}

// Names represents a PDF name tree.
//
// Ref: PDF32000_2008 chapter 7.7.4.
type Names struct {
	_dfag *_df.PdfIndirectObject

	// Dests is a name tree mapping name string to destinations.
	Dests *_df.PdfObjectDictionary

	// AP is a name tree mapping name strings to annotation appearance streams.
	AP *_df.PdfObjectDictionary

	// JavaScript is a name tree mapping name strings to JavaScript actions.
	JavaScript *_df.PdfObjectDictionary

	// Pages is a name tree mapping name strings to visible pages for use in interactive forms.
	Pages *_df.PdfObjectDictionary

	// Templates is a name tree mapping name strings to invisible (template) pages for use in interactive forms.
	Templates *_df.PdfObjectDictionary

	// IDS is a name tree mapping digital identifies to Web Capture content sets.
	IDS *_df.PdfObjectDictionary

	// URLS is a name tree mapping URLs to Web Capture content sets.
	URLS *_df.PdfObjectDictionary

	// EmbeddedFiles is a name tree mapping name strings to file specifications for embedded file streams.
	EmbeddedFiles *_df.PdfObjectDictionary

	// AlternatePresentations is a name tree mapping name strings to alternate presentations.
	AlternatePresentations *_df.PdfObjectDictionary

	// Renditions is a name tree mapping name strings (which shall have Unicode encoding) to rendition objects.
	Renditions *_df.PdfObjectDictionary
}

// SetEncoder sets the encoding for the underlying font.
// TODO(peterwilliams97): Change function signature to SetEncoder(encoder *textencoding.simpleEncoder).
// TODO(gunnsth): Makes sense if SetEncoder is removed from the interface fonts.Font as proposed in PR #260.
func (_ecfgc *pdfFontSimple) SetEncoder(encoder _abg.TextEncoder) { _ecfgc._ebgg = encoder }

// PdfAnnotationRichMedia represents Rich Media annotations.
type PdfAnnotationRichMedia struct {
	*PdfAnnotation
	RichMediaSettings _df.PdfObject
	RichMediaContent  _df.PdfObject
}

// ToPdfObject returns a *PdfIndirectObject containing a *PdfObjectArray representation of the DeviceN colorspace.
/*
	Format: [/DeviceN names alternateSpace tintTransform]
	    or: [/DeviceN names alternateSpace tintTransform attributes]
*/
func (_fabb *PdfColorspaceDeviceN) ToPdfObject() _df.PdfObject {
	_bbce := _df.MakeArray(_df.MakeName("\u0044e\u0076\u0069\u0063\u0065\u004e"))
	_bbce.Append(_fabb.ColorantNames)
	_bbce.Append(_fabb.AlternateSpace.ToPdfObject())
	_bbce.Append(_fabb.TintTransform.ToPdfObject())
	if _fabb.Attributes != nil {
		_bbce.Append(_fabb.Attributes.ToPdfObject())
	}
	if _fabb._dabgc != nil {
		_fabb._dabgc.PdfObject = _bbce
		return _fabb._dabgc
	}
	return _bbce
}

// EmbeddedFile represents an embedded file.
type EmbeddedFile struct {
	Name         string
	Content      []byte
	FileType     string
	Description  string
	Relationship FileRelationship
	Hash         string
	CreationTime _fa.Time
	ModTime      _fa.Time
}

// NewPdfAnnotation returns an initialized generic PDF annotation model.
func NewPdfAnnotation() *PdfAnnotation {
	_ggf := &PdfAnnotation{}
	_ggf._bfde = _df.MakeIndirectObject(_df.MakeDict())
	return _ggf
}

// GetContext returns the PdfField context which is the more specific field data type, e.g. PdfFieldButton
// for a button field.
func (_cadc *PdfField) GetContext() PdfModel { return _cadc._efcbg }

func (_fgcec *PdfWriter) addObject(_cbabg _df.PdfObject) bool {
	_cfccb := _fgcec.hasObject(_cbabg)
	if !_cfccb {
		_cbgde := _df.ResolveReferencesDeep(_cbabg, _fgcec._dfadb)
		if _cbgde != nil {
			_bcd.Log.Debug("E\u0052R\u004f\u0052\u003a\u0020\u0025\u0076\u0020\u002d \u0073\u006b\u0069\u0070pi\u006e\u0067", _cbgde)
		}
		_fgcec._ceeac = append(_fgcec._ceeac, _cbabg)
		_fgcec._aadfbg[_cbabg] = struct{}{}
		return true
	}
	return false
}

func _cbeb(_ffabc _df.PdfObject) (*PdfColorspaceCalGray, error) {
	_cefa := NewPdfColorspaceCalGray()
	if _dgced, _fgbbg := _ffabc.(*_df.PdfIndirectObject); _fgbbg {
		_cefa._faadg = _dgced
	}
	_ffabc = _df.TraceToDirectObject(_ffabc)
	_egbd, _fgfcb := _ffabc.(*_df.PdfObjectArray)
	if !_fgfcb {
		return nil, _c.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _egbd.Len() != 2 {
		return nil, _c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0061\u006cG\u0072\u0061\u0079\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065")
	}
	_ffabc = _df.TraceToDirectObject(_egbd.Get(0))
	_ddaa, _fgfcb := _ffabc.(*_df.PdfObjectName)
	if !_fgfcb {
		return nil, _c.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061\u0079\u0020\u006e\u0061m\u0065\u0020\u006e\u006f\u0074\u0020\u0061 \u004e\u0061\u006d\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	if *_ddaa != "\u0043a\u006c\u0047\u0072\u0061\u0079" {
		return nil, _c.Errorf("\u006eo\u0074\u0020\u0061\u0020\u0043\u0061\u006c\u0047\u0072\u0061\u0079 \u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	}
	_ffabc = _df.TraceToDirectObject(_egbd.Get(1))
	_gbeg, _fgfcb := _ffabc.(*_df.PdfObjectDictionary)
	if !_fgfcb {
		return nil, _c.Errorf("\u0043\u0061lG\u0072\u0061\u0079 \u0064\u0069\u0063\u0074 no\u0074 a\u0020\u0044\u0069\u0063\u0074\u0069\u006fna\u0072\u0079\u0020\u006f\u0062\u006a\u0065c\u0074")
	}
	_ffabc = _gbeg.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_ffabc = _df.TraceToDirectObject(_ffabc)
	_ace, _fgfcb := _ffabc.(*_df.PdfObjectArray)
	if !_fgfcb {
		return nil, _c.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020W\u0068\u0069\u0074e\u0050o\u0069\u006e\u0074")
	}
	if _ace.Len() != 3 {
		return nil, _c.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061y\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069t\u0065\u0050\u006f\u0069\u006e\u0074\u0020a\u0072\u0072\u0061\u0079")
	}
	_babe, _eaadce := _ace.GetAsFloat64Slice()
	if _eaadce != nil {
		return nil, _eaadce
	}
	_cefa.WhitePoint = _babe
	_ffabc = _gbeg.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _ffabc != nil {
		_ffabc = _df.TraceToDirectObject(_ffabc)
		_bgcc, _fdccb := _ffabc.(*_df.PdfObjectArray)
		if !_fdccb {
			return nil, _c.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020B\u006c\u0061\u0063k\u0050o\u0069\u006e\u0074")
		}
		if _bgcc.Len() != 3 {
			return nil, _c.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061y\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061c\u006b\u0050\u006f\u0069\u006e\u0074\u0020a\u0072\u0072\u0061\u0079")
		}
		_caeb, _ffde := _bgcc.GetAsFloat64Slice()
		if _ffde != nil {
			return nil, _ffde
		}
		_cefa.BlackPoint = _caeb
	}
	_ffabc = _gbeg.Get("\u0047\u0061\u006dm\u0061")
	if _ffabc != nil {
		_ffabc = _df.TraceToDirectObject(_ffabc)
		_cbfa, _gdge := _df.GetNumberAsFloat(_ffabc)
		if _gdge != nil {
			return nil, _c.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0067\u0061\u006d\u006d\u0061\u0020\u006e\u006ft\u0020\u0061\u0020n\u0075m\u0062\u0065\u0072")
		}
		_cefa.Gamma = _cbfa
	}
	return _cefa, nil
}

// XObjectImage (Table 89 in 8.9.5.1).
// Implements PdfModel interface.
type XObjectImage struct {

	//ColorSpace       PdfObject
	Width            *int64
	Height           *int64
	ColorSpace       PdfColorspace
	BitsPerComponent *int64
	Filter           _df.StreamEncoder
	Intent           _df.PdfObject
	ImageMask        _df.PdfObject
	Mask             _df.PdfObject
	Matte            _df.PdfObject
	Decode           _df.PdfObject
	Interpolate      _df.PdfObject
	Alternatives     _df.PdfObject
	SMask            _df.PdfObject
	SMaskInData      _df.PdfObject
	Name             _df.PdfObject
	StructParent     _df.PdfObject
	ID               _df.PdfObject
	OPI              _df.PdfObject
	Metadata         _df.PdfObject
	OC               _df.PdfObject
	Stream           []byte
	_fgdgd           *_df.PdfObjectStream
	_acgbea          bool
}

// EnableChain adds the specified certificate chain and validation data (OCSP
// and CRL information) for it to the global scope of the document DSS. The
// added data is used for validating any of the signatures present in the
// document. The LTV client attempts to build the certificate chain up to a
// trusted root by downloading any missing certificates.
func (_abaaa *LTV) EnableChain(chain []*_ed.Certificate) error {
	return _abaaa.enable(nil, chain, "")
}

func (_fdccce *PdfWriter) writeObject(_agdge int, _adbdbc _df.PdfObject) {
	_bcd.Log.Trace("\u0057\u0072\u0069\u0074\u0065\u0020\u006f\u0062\u006a \u0023\u0025\u0064\u000a", _agdge)
	if _ecdgf, _cdbac := _adbdbc.(*_df.PdfIndirectObject); _cdbac {
		_fdccce._cdgd[_agdge] = crossReference{Type: 1, Offset: _fdccce._afeab, Generation: _ecdgf.GenerationNumber}
		_gegcc := _c.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _agdge)
		if _cfbeba, _faaeag := _ecdgf.PdfObject.(*pdfSignDictionary); _faaeag {
			_cfbeba._ebeeda = _fdccce._afeab + int64(len(_gegcc))
		}
		if _ecdgf.PdfObject == nil {
			_bcd.Log.Debug("E\u0072\u0072\u006fr\u003a\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0027\u0073\u0020\u0050\u0064\u0066\u004f\u0062j\u0065\u0063\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020b\u0065\u0020\u006e\u0069l\u0020\u002d\u0020\u0073e\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063t\u004e\u0075\u006c\u006c")
			_ecdgf.PdfObject = _df.MakeNull()
		}
		_gegcc += _ecdgf.PdfObject.WriteString()
		_gegcc += "\u000a\u0065\u006e\u0064\u006f\u0062\u006a\u000a"
		_fdccce.writeString(_gegcc)
		return
	}
	if _afdfc, _fffff := _adbdbc.(*_df.PdfObjectStream); _fffff {
		_fdccce._cdgd[_agdge] = crossReference{Type: 1, Offset: _fdccce._afeab, Generation: _afdfc.GenerationNumber}
		_gcacb := _c.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _agdge)
		_gcacb += _afdfc.PdfObjectDictionary.WriteString()
		_gcacb += "\u000a\u0073\u0074\u0072\u0065\u0061\u006d\u000a"
		_fdccce.writeString(_gcacb)
		if _afdfc.Lazy {
			_bfacbb, _gcgf := _bf.ReadFile(_afdfc.TempFile)
			if _gcgf != nil {
				_bcd.Log.Info("\u0045\u0072\u0072\u006f\u0072\u0020\u0066\u0069\u006e\u0064\u0069\u006e\u0067\u0020\u006ca\u007ay\u0020\u0074\u0065\u006d\u0070\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _afdfc.TempFile)
				return
			}
			_fdccce.writeBytes(_bfacbb)
			_bf.Remove(_afdfc.TempFile)
		} else {
			_fdccce.writeBytes(_afdfc.Stream)
		}
		_fdccce.writeString("\u000ae\u006ed\u0073\u0074\u0072\u0065\u0061m\u000a\u0065n\u0064\u006f\u0062\u006a\u000a")
		return
	}
	if _cefac, _bcaga := _adbdbc.(*_df.PdfObjectStreams); _bcaga {
		_fdccce._cdgd[_agdge] = crossReference{Type: 1, Offset: _fdccce._afeab, Generation: _cefac.GenerationNumber}
		_gbggb := _c.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _agdge)
		var _effd []string
		var _fdada string
		var _ccbda int64
		for _ggeef, _ccfcba := range _cefac.Elements() {
			_fadded, _ebaga := _ccfcba.(*_df.PdfIndirectObject)
			if !_ebaga {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065am\u0073 \u004e\u0020\u0025\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006es\u0020\u006e\u006f\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u0070\u0064\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0076", _agdge, _ccfcba)
				continue
			}
			_gdcef := _fadded.PdfObject.WriteString() + "\u0020"
			_fdada = _fdada + _gdcef
			_effd = append(_effd, _c.Sprintf("\u0025\u0064\u0020%\u0064", _fadded.ObjectNumber, _ccbda))
			_fdccce._cdgd[int(_fadded.ObjectNumber)] = crossReference{Type: 2, ObjectNumber: _agdge, Index: _ggeef}
			_ccbda = _ccbda + int64(len([]byte(_gdcef)))
		}
		_efeb := _gc.Join(_effd, "\u0020") + "\u0020"
		_fbdead := _df.NewFlateEncoder()
		_dggdcc := _fbdead.MakeStreamDict()
		_dggdcc.Set(_df.PdfObjectName("\u0054\u0079\u0070\u0065"), _df.MakeName("\u004f\u0062\u006a\u0053\u0074\u006d"))
		_edcg := int64(_cefac.Len())
		_dggdcc.Set(_df.PdfObjectName("\u004e"), _df.MakeInteger(_edcg))
		_fcdcg := int64(len(_efeb))
		_dggdcc.Set(_df.PdfObjectName("\u0046\u0069\u0072s\u0074"), _df.MakeInteger(_fcdcg))
		_edfdg, _ := _fbdead.EncodeBytes([]byte(_efeb + _fdada))
		_adeec := int64(len(_edfdg))
		_dggdcc.Set(_df.PdfObjectName("\u004c\u0065\u006e\u0067\u0074\u0068"), _df.MakeInteger(_adeec))
		_gbggb += _dggdcc.WriteString()
		_gbggb += "\u000a\u0073\u0074\u0072\u0065\u0061\u006d\u000a"
		_fdccce.writeString(_gbggb)
		_fdccce.writeBytes(_edfdg)
		_fdccce.writeString("\u000ae\u006ed\u0073\u0074\u0072\u0065\u0061m\u000a\u0065n\u0064\u006f\u0062\u006a\u000a")
		return
	}
	_fdccce.writeString(_adbdbc.WriteString())
}

func (_becee *Names) addEmbeddedFile(_edad *EmbeddedFile) error {
	if _becee.EmbeddedFiles == nil {
		_becee.EmbeddedFiles = _df.MakeDict()
		_becee.EmbeddedFiles.Set("\u004e\u0061\u006de\u0073", _df.MakeArray())
	}
	_feag := NewPdfFileSpecFromEmbeddedFile(_edad)
	_cede := _becee.EmbeddedFiles.Get("\u004e\u0061\u006de\u0073")
	_dgdag, _dcab := _cede.(*_df.PdfObjectArray)
	if !_dcab {
		return _deb.New("\u0049\u006e\u0076\u0061li\u0064\u0020\u004e\u0061\u006d\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	type FileSpecMap struct {
		_bggba string
		_deee  *PdfFilespec
	}
	_gaceb := []FileSpecMap{}
	for _ccadd := 0; _ccadd < len(_dgdag.Elements()); _ccadd += 2 {
		if _ccadd%2 == 0 {
			_fddaf := _dgdag.Get(_ccadd)
			if _fddaf != nil {
				_dfadee := _fddaf.(*_df.PdfObjectString)
				_ddefd := _dgdag.Get(_ccadd + 1)
				_ddaaa, _cggg := NewPdfFilespecFromObj(_ddefd)
				if _cggg != nil {
					return _cggg
				}
				_gaceb = append(_gaceb, FileSpecMap{_bggba: _dfadee.String(), _deee: _ddaaa})
			}
		}
	}
	_gaceb = append(_gaceb, FileSpecMap{_bggba: _edad.Name, _deee: _feag})
	_f.Slice(_gaceb, func(_badac, _eaaeeg int) bool { return _gaceb[_badac]._bggba < _gaceb[_eaaeeg]._bggba })
	_dgdag = _df.MakeArray()
	for _, _cgbdg := range _gaceb {
		_dgdag.Append(_df.MakeString(_cgbdg._bggba))
		_dgdag.Append(_cgbdg._deee.ToPdfObject())
	}
	_becee.EmbeddedFiles.Set("\u004e\u0061\u006de\u0073", _dgdag)
	return nil
}

func _bddb(_gadggd *_df.PdfObjectDictionary) (*PdfFieldText, error) {
	_ccfgc := &PdfFieldText{}
	_ccfgc.DA, _ = _df.GetString(_gadggd.Get("\u0044\u0041"))
	_ccfgc.Q, _ = _df.GetInt(_gadggd.Get("\u0051"))
	_ccfgc.DS, _ = _df.GetString(_gadggd.Get("\u0044\u0053"))
	_ccfgc.RV = _gadggd.Get("\u0052\u0056")
	_ccfgc.MaxLen, _ = _df.GetInt(_gadggd.Get("\u004d\u0061\u0078\u004c\u0065\u006e"))
	return _ccfgc, nil
}

func (_edga *PdfColorspaceICCBased) String() string {
	return "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064"
}

// GetContainingPdfObject gets the primitive used to parse the color space.
func (_acgc *PdfColorspaceICCBased) GetContainingPdfObject() _df.PdfObject { return _acgc._gdgeg }

func (_caebd *PdfPage) generateImage(_afcc string, _decf float64, _fcecd string, _dfbfg _b.Color) ([]byte, error) {
	_fdde, _bfbca, _faggb, _ := _dfbfg.RGBA()
	_caacb := _b.RGBA{uint8(_fdde >> 8), uint8(_bfbca >> 8), uint8(_faggb >> 8), 255}
	_ggfec := _b.RGBA{0xff, 0xff, 0xff, 0x00}
	_agbd, _dgdeb := _caebd.loadFont(_fcecd)
	if _dgdeb != nil {
		return nil, _dgdeb
	}
	_abecc := _gc.Replace(_afcc, "\u0009", "\u0020\u0020\u0020\u0020", -1)
	_dfada := _gc.Split(_abecc, "\u000a")
	_ffcga := 1.0
	for _, _ddfgf := range _dfada {
		if float64(len(_ddfgf))*_decf > _ffcga {
			_ffcga = float64(len(_ddfgf)) * _decf
		}
	}
	if _ffcga > _caebd.MediaBox.Width() {
		_ffcga = _caebd.MediaBox.Width()
	}
	_ccadb := _cg.NewUniform(_caacb)
	_cddf := _cg.NewUniform(_ggfec)
	_eggff := _cg.NewRGBA(_cg.Rect(0, 0, int(_ffcga), int(_decf*1.5*float64(len(_dfada)))))
	_a.Draw(_eggff, _eggff.Bounds(), _cddf, _cg.Pt(0, 0), _a.Src)
	_bagcf := _ggb.NewContext()
	_bagcf.SetDPI(72)
	_bagcf.SetFont(_agbd)
	_bagcf.SetFontSize(_decf)
	_bagcf.SetHinting(_fb.HintingNone)
	_bagcf.SetClip(_eggff.Bounds())
	_bagcf.SetDst(_eggff)
	_bagcf.SetSrc(_ccadb)
	_fbbe := 50
	_afed := 10 + int(_bagcf.PointToFixed(_decf)>>6)
	_fdgfb := _ggb.Pt(_fbbe, _afed)
	for _, _agfbc := range _dfada {
		_, _dgdeb = _bagcf.DrawString(_gc.Replace(_agfbc, "\u000d", "", -1), _fdgfb)
		if _dgdeb != nil {
			return nil, _dgdeb
		}
		_fdgfb.Y += _bagcf.PointToFixed(_decf * 1.5)
	}
	_acac := new(_ef.Buffer)
	if _bfgd := _bb.Encode(_acac, _eggff); _bfgd != nil {
		return nil, _bfgd
	}
	return _acac.Bytes(), nil
}

// SetContext sets the sub action (context).
func (_ccc *PdfAction) SetContext(ctx PdfModel) { _ccc._aab = ctx }

// GetContainingPdfObject returns the XObject Form's containing object (indirect object).
func (_fccce *XObjectForm) GetContainingPdfObject() _df.PdfObject { return _fccce._bbfeg }

// NewPdfActionGoToR returns a new "go to remote" action.
func NewPdfActionGoToR() *PdfActionGoToR {
	_fbe := NewPdfAction()
	_cbb := &PdfActionGoToR{}
	_cbb.PdfAction = _fbe
	_fbe.SetContext(_cbb)
	return _cbb
}

func _ddega(_bggcd _df.PdfObject) []*_df.PdfObjectStream {
	if _bggcd == nil {
		return nil
	}
	_gaac, _addfe := _df.GetArray(_bggcd)
	if !_addfe || _gaac.Len() == 0 {
		return nil
	}
	_gcdad := make([]*_df.PdfObjectStream, 0, _gaac.Len())
	for _, _ddcac := range _gaac.Elements() {
		if _defa, _fbcfg := _df.GetStream(_ddcac); _fbcfg {
			_gcdad = append(_gcdad, _defa)
		}
	}
	return _gcdad
}

func (_caea *PdfReader) newPdfAnnotationProjectionFromDict(_bddc *_df.PdfObjectDictionary) (*PdfAnnotationProjection, error) {
	_cgcb := &PdfAnnotationProjection{}
	_gbfd, _bbde := _caea.newPdfAnnotationMarkupFromDict(_bddc)
	if _bbde != nil {
		return nil, _bbde
	}
	_cgcb.PdfAnnotationMarkup = _gbfd
	return _cgcb, nil
}

// ToPdfObject returns the PDF representation of the outline tree node.
func (_gcceg *PdfOutlineTreeNode) ToPdfObject() _df.PdfObject {
	return _gcceg.GetContext().ToPdfObject()
}

func (_beb *PdfReader) newPdfAnnotationInkFromDict(_cgd *_df.PdfObjectDictionary) (*PdfAnnotationInk, error) {
	_egda := PdfAnnotationInk{}
	_bbg, _ccda := _beb.newPdfAnnotationMarkupFromDict(_cgd)
	if _ccda != nil {
		return nil, _ccda
	}
	_egda.PdfAnnotationMarkup = _bbg
	_egda.InkList = _cgd.Get("\u0049n\u006b\u004c\u0069\u0073\u0074")
	_egda.BS = _cgd.Get("\u0042\u0053")
	return &_egda, nil
}

// GetEncryptionMethod returns a descriptive information string about the encryption method used.
func (_dfdfe *PdfReader) GetEncryptionMethod() string {
	_aecdc := _dfdfe._gfdaag.GetCrypter()
	return _aecdc.String()
}

// PdfFunctionType4 is a Postscript calculator functions.
type PdfFunctionType4 struct {
	Domain  []float64
	Range   []float64
	Program *_eg.PSProgram
	_bdage  *_eg.PSExecutor
	_acbe   []byte
	_ebea   *_df.PdfObjectStream
}

// PdfBorderEffect represents a PDF border effect.
type PdfBorderEffect struct {
	S *BorderEffect
	I *float64
}

// PdfFilespec represents a file specification which can either refer to an external or embedded file.
type PdfFilespec struct {
	Type           _df.PdfObject
	FS             _df.PdfObject
	F              _df.PdfObject
	UF             _df.PdfObject
	DOS            _df.PdfObject
	Mac            _df.PdfObject
	Unix           _df.PdfObject
	ID             _df.PdfObject
	V              _df.PdfObject
	EF             _df.PdfObject
	RF             _df.PdfObject
	Desc           _df.PdfObject
	CI             _df.PdfObject
	AFRelationship _df.PdfObject
	_gaafd         _df.PdfObject
}

// NewPdfColorPatternType2 returns an empty color shading pattern type 2 (Axial).
func NewPdfColorPatternType2() *PdfColorPatternType2 { _eggd := &PdfColorPatternType2{}; return _eggd }

// GetContext returns a reference to the subshading entry as represented by PdfShadingType1-7.
func (_abdaa *PdfShading) GetContext() PdfModel { return _abdaa._dggab }

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 4 for a CMYK32 device.
func (_bfaf *PdfColorspaceDeviceCMYK) GetNumComponents() int { return 4 }

// RemoveWatermarkImage removes watermark.
// If you don't know exact name of watermark PDF object, pass empty string as an argument.
func (_ggeba *PdfPage) RemoveWatermarkImage(name string) error {
	if _ggeba.Resources != nil && _ggeba.Resources.XObject != nil {
		if _dbcf, _gcgcb := _df.GetDict(_ggeba.Resources.XObject); _gcgcb {
			for _, _acdd := range _dbcf.Keys() {
				if name == _acdd.String() {
					_ggeba.removeXObj(_dbcf, _acdd)
					continue
				}
				_dgbgg, _dedb := _df.GetStream(_dbcf.Get(_acdd))
				if !_dedb {
					continue
				}
				_gcaa, _dedb := _df.GetDict(_dgbgg.Get("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o"))
				if !_dedb {
					continue
				}
				_cdcbb, _dedb := _df.GetDict(_gcaa.Get("\u0041\u0044\u0042\u0045\u005f\u0043\u006f\u006d\u0070\u006f\u0075\u006ed\u0054\u0079\u0070\u0065"))
				if !_dedb {
					continue
				}
				if _cdcbb.Get("\u0050r\u0069\u0076\u0061\u0074\u0065") != nil && _cdcbb.Get("\u0050r\u0069\u0076\u0061\u0074\u0065").String() == "\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k" {
					_ggeba.removeXObj(_dbcf, _acdd)
				}
			}
		}
	}
	_ffgdb, _debcd := _ggeba.GetAnnotations()
	if _debcd == nil {
		_cfdd := make([]*PdfAnnotation, 0)
		for _, _eefba := range _ffgdb {
			switch _eefba.GetContext().(type) {
			case *PdfAnnotationWatermark:
			default:
				_cfdd = append(_cfdd, _eefba)
			}
		}
		_ggeba.SetAnnotations(_cfdd)
	}
	return nil
}

func _daegd(_dfgf *_df.PdfObjectDictionary) (*PdfFieldChoice, error) {
	_ebdb := &PdfFieldChoice{}
	_ebdb.Opt, _ = _df.GetArray(_dfgf.Get("\u004f\u0070\u0074"))
	_ebdb.TI, _ = _df.GetInt(_dfgf.Get("\u0054\u0049"))
	_ebdb.I, _ = _df.GetArray(_dfgf.Get("\u0049"))
	return _ebdb, nil
}

// PdfAnnotationStamp represents Stamp annotations.
// (Section 12.5.6.12).
type PdfAnnotationStamp struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Name _df.PdfObject
}

// ColorToRGB converts a Lab color to an RGB color.
func (_gafg *PdfColorspaceLab) ColorToRGB(color PdfColor) (PdfColor, error) {
	_bbga := func(_deg float64) float64 {
		if _deg >= 6.0/29 {
			return _deg * _deg * _deg
		}
		return 108.0 / 841 * (_deg - 4.0/29.0)
	}
	_gcgd, _ebab := color.(*PdfColorLab)
	if !_ebab {
		_bcd.Log.Debug("\u0069\u006e\u0070\u0075t \u0063\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u006c\u0061\u0062")
		return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	LStar := _gcgd.L()
	AStar := _gcgd.A()
	BStar := _gcgd.B()
	L := (LStar+16)/116 + AStar/500
	M := (LStar + 16) / 116
	N := (LStar+16)/116 - BStar/200
	X := _gafg.WhitePoint[0] * _bbga(L)
	Y := _gafg.WhitePoint[1] * _bbga(M)
	Z := _gafg.WhitePoint[2] * _bbga(N)
	_bgda := 3.240479*X + -1.537150*Y + -0.498535*Z
	_aagb := -0.969256*X + 1.875992*Y + 0.041556*Z
	_afca := 0.055648*X + -0.204043*Y + 1.057311*Z
	_bgda = _faf.Min(_faf.Max(_bgda, 0), 1.0)
	_aagb = _faf.Min(_faf.Max(_aagb, 0), 1.0)
	_afca = _faf.Min(_faf.Max(_afca, 0), 1.0)
	return NewPdfColorDeviceRGB(_bgda, _aagb, _afca), nil
}

func (_dbcad *PdfWriter) flushWriter() error {
	if _dbcad._bbecc == nil {
		_dbcad._bbecc = _dbcad._cfddc.Flush()
	}
	return _dbcad._bbecc
}

func _dbdfd(_eecad _df.PdfObject) {
	_bcd.Log.Debug("\u006f\u0062\u006a\u003a\u0020\u0025\u0054\u0020\u0025\u0073", _eecad, _eecad.String())
	if _deefd, _aeagg := _eecad.(*_df.PdfObjectStream); _aeagg {
		_acabf, _gfceed := _df.DecodeStream(_deefd)
		if _gfceed != nil {
			_bcd.Log.Debug("\u0045r\u0072\u006f\u0072\u003a\u0020\u0025v", _gfceed)
			return
		}
		_bcd.Log.Debug("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073", _acabf)
	} else if _eged, _bbdce := _eecad.(*_df.PdfIndirectObject); _bbdce {
		_bcd.Log.Debug("\u0025\u0054\u0020%\u0076", _eged.PdfObject, _eged.PdfObject)
		_bcd.Log.Debug("\u0025\u0073", _eged.PdfObject.String())
	}
}

var _ffcfc = map[string]struct{}{"\u0054\u0069\u0074l\u0065": {}, "\u0041\u0075\u0074\u0068\u006f\u0072": {}, "\u0053u\u0062\u006a\u0065\u0063\u0074": {}, "\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073": {}, "\u0043r\u0065\u0061\u0074\u006f\u0072": {}, "\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072": {}, "\u0054r\u0061\u0070\u0070\u0065\u0064": {}, "\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065": {}, "\u004do\u0064\u0044\u0061\u0074\u0065": {}}

// SetHideMenubar sets the value of the hideMenubar flag.
func (_adecd *ViewerPreferences) SetHideMenubar(hideMenubar bool) { _adecd._abebaec = &hideMenubar }

// ToPdfObject implements interface PdfModel.
func (_cabd *PdfAnnotationSound) ToPdfObject() _df.PdfObject {
	_cabd.PdfAnnotation.ToPdfObject()
	_ebacb := _cabd._bfde
	_fbdc := _ebacb.PdfObject.(*_df.PdfObjectDictionary)
	_cabd.PdfAnnotationMarkup.appendToPdfDictionary(_fbdc)
	_fbdc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0053\u006f\u0075n\u0064"))
	_fbdc.SetIfNotNil("\u0053\u006f\u0075n\u0064", _cabd.Sound)
	_fbdc.SetIfNotNil("\u004e\u0061\u006d\u0065", _cabd.Name)
	return _ebacb
}

// Encoder returns the font's text encoder.
func (_fgeaf *pdfFontSimple) Encoder() _abg.TextEncoder {
	if _fgeaf._ebgg != nil {
		return _fgeaf._ebgg
	}
	if _fgeaf._geecc != nil {
		return _fgeaf._geecc
	}
	_dcda, _ := _abg.NewSimpleTextEncoder("\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", nil)
	return _dcda
}

// ColorToRGB converts a color in Separation colorspace to RGB colorspace.
func (_cedd *PdfColorspaceSpecialSeparation) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _cedd.AlternateSpace == nil {
		return nil, _deb.New("\u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0065\u0020c\u006f\u006c\u006f\u0072\u0073\u0070\u0061c\u0065\u0020\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064")
	}
	return _cedd.AlternateSpace.ColorToRGB(color)
}

// FlattenFieldsWithOpts flattens the AcroForm fields of the page using the
// provided field appearance generator and the specified options. If no options
// are specified, all form fields are flattened for the page.
// If a filter function is provided using the opts parameter, only the filtered
// fields are flattened. Otherwise, all form fields are flattened.
func (_ceaea *PdfPage) FlattenFieldsWithOpts(appgen FieldAppearanceGenerator, opts *FieldFlattenOpts) error {
	_ggbac := map[*PdfAnnotation]bool{}
	_gcda, _afcd := _ceaea.GetAnnotations()
	if _afcd != nil {
		return _afcd
	}
	_bceae := false
	for _, _dfbf := range _gcda {
		if opts.AnnotFilterFunc != nil {
			_ggbac[_dfbf] = opts.AnnotFilterFunc(_dfbf)
		} else {
			_ggbac[_dfbf] = true
		}
		if _ggbac[_dfbf] {
			_bceae = true
		}
	}
	if !_bceae {
		return nil
	}
	return _ceaea.flattenFieldsWithOpts(appgen, opts, _ggbac)
}

// PdfFont represents an underlying font structure which can be of type:
// - Type0
// - Type1
// - TrueType
// etc.
type PdfFont struct{ _eaeg pdfFont }

// NewPdfActionGoToE returns a new "go to embedded" action.
func NewPdfActionGoToE() *PdfActionGoToE {
	_dbcc := NewPdfAction()
	_cfe := &PdfActionGoToE{}
	_cfe.PdfAction = _dbcc
	_dbcc.SetContext(_cfe)
	return _cfe
}

// PdfColorspaceDeviceN represents a DeviceN color space. DeviceN color spaces are similar to Separation color
// spaces, except they can contain an arbitrary number of color components.
/*
	Format: [/DeviceN names alternateSpace tintTransform]
        or: [/DeviceN names alternateSpace tintTransform attributes]
*/
type PdfColorspaceDeviceN struct {
	ColorantNames  *_df.PdfObjectArray
	AlternateSpace PdfColorspace
	TintTransform  PdfFunction
	Attributes     *PdfColorspaceDeviceNAttributes
	_dabgc         *_df.PdfIndirectObject
}

// ToPdfObject converts the PdfPage to a dictionary within an indirect object container.
func (_fbdfa *PdfPage) ToPdfObject() _df.PdfObject {
	_fdagf := _fbdfa._gcced
	_fbdfa.GetPageDict()
	return _fdagf
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_ccae *PdfShadingType6) ToPdfObject() _df.PdfObject {
	_ccae.PdfShading.ToPdfObject()
	_gafbe, _bfed := _ccae.getShadingDict()
	if _bfed != nil {
		_bcd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _ccae.BitsPerCoordinate != nil {
		_gafbe.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _ccae.BitsPerCoordinate)
	}
	if _ccae.BitsPerComponent != nil {
		_gafbe.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _ccae.BitsPerComponent)
	}
	if _ccae.BitsPerFlag != nil {
		_gafbe.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _ccae.BitsPerFlag)
	}
	if _ccae.Decode != nil {
		_gafbe.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _ccae.Decode)
	}
	if _ccae.Function != nil {
		if len(_ccae.Function) == 1 {
			_gafbe.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _ccae.Function[0].ToPdfObject())
		} else {
			_ddcgc := _df.MakeArray()
			for _, _dbdgg := range _ccae.Function {
				_ddcgc.Append(_dbdgg.ToPdfObject())
			}
			_gafbe.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _ddcgc)
		}
	}
	return _ccae._bgdag
}

// PdfAnnotationRedact represents Redact annotations.
// (Section 12.5.6.23).
type PdfAnnotationRedact struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints  _df.PdfObject
	IC          _df.PdfObject
	RO          _df.PdfObject
	OverlayText _df.PdfObject
	Repeat      _df.PdfObject
	DA          _df.PdfObject
	Q           _df.PdfObject
}

func (_dgcgfb SignatureValidationResult) String() string {
	var _ccadg _ef.Buffer
	_ccadg.WriteString(_c.Sprintf("\u004ea\u006d\u0065\u003a\u0020\u0025\u0073\n", _dgcgfb.Name))
	if _dgcgfb.Date._gfddd > 0 {
		_ccadg.WriteString(_c.Sprintf("\u0044a\u0074\u0065\u003a\u0020\u0025\u0073\n", _dgcgfb.Date.ToGoTime().String()))
	} else {
		_ccadg.WriteString("\u0044\u0061\u0074\u0065 n\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u000a")
	}
	if len(_dgcgfb.Reason) > 0 {
		_ccadg.WriteString(_c.Sprintf("R\u0065\u0061\u0073\u006f\u006e\u003a\u0020\u0025\u0073\u000a", _dgcgfb.Reason))
	} else {
		_ccadg.WriteString("N\u006f \u0072\u0065\u0061\u0073\u006f\u006e\u0020\u0073p\u0065\u0063\u0069\u0066ie\u0064\u000a")
	}
	if len(_dgcgfb.Location) > 0 {
		_ccadg.WriteString(_c.Sprintf("\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u000a", _dgcgfb.Location))
	} else {
		_ccadg.WriteString("\u004c\u006f\u0063at\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u000a")
	}
	if len(_dgcgfb.ContactInfo) > 0 {
		_ccadg.WriteString(_c.Sprintf("\u0043\u006f\u006e\u0074\u0061\u0063\u0074\u0020\u0049\u006e\u0066\u006f:\u0020\u0025\u0073\u000a", _dgcgfb.ContactInfo))
	} else {
		_ccadg.WriteString("C\u006f\u006e\u0074\u0061\u0063\u0074 \u0069\u006e\u0066\u006f\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063i\u0066i\u0065\u0064\u000a")
	}
	_ccadg.WriteString(_c.Sprintf("F\u0069\u0065\u006c\u0064\u0073\u003a\u0020\u0025\u0064\u000a", len(_dgcgfb.Fields)))
	if _dgcgfb.IsSigned {
		_ccadg.WriteString("S\u0069\u0067\u006e\u0065\u0064\u003a \u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073\u0020\u0073i\u0067n\u0065\u0064\u000a")
	} else {
		_ccadg.WriteString("\u0053\u0069\u0067\u006eed\u003a\u0020\u004e\u006f\u0074\u0020\u0073\u0069\u0067\u006e\u0065\u0064\u000a")
	}
	if _dgcgfb.IsVerified {
		_ccadg.WriteString("\u0053\u0069\u0067n\u0061\u0074\u0075\u0072e\u0020\u0076\u0061\u006c\u0069\u0064\u0061t\u0069\u006f\u006e\u003a\u0020\u0049\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u000a")
	} else {
		_ccadg.WriteString("\u0053\u0069\u0067\u006e\u0061\u0074u\u0072\u0065\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e:\u0020\u0049\u0073\u0020\u0069\u006e\u0076a\u006c\u0069\u0064\u000a")
	}
	if _dgcgfb.IsTrusted {
		_ccadg.WriteString("\u0054\u0072\u0075\u0073\u0074\u0065\u0064\u003a\u0020\u0043\u0065\u0072\u0074\u0069\u0066i\u0063a\u0074\u0065\u0020\u0069\u0073\u0020\u0074\u0072\u0075\u0073\u0074\u0065\u0064\u000a")
	} else {
		_ccadg.WriteString("\u0054\u0072\u0075s\u0074\u0065\u0064\u003a \u0055\u006e\u0074\u0072\u0075\u0073\u0074e\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u000a")
	}
	if !_dgcgfb.GeneralizedTime.IsZero() {
		_ccadg.WriteString(_c.Sprintf("G\u0065n\u0065\u0072\u0061\u006c\u0069\u007a\u0065\u0064T\u0069\u006d\u0065\u003a %\u0073\u000a", _dgcgfb.GeneralizedTime.String()))
	}
	if _dgcgfb.DiffResults != nil {
		_ccadg.WriteString(_c.Sprintf("\u0064\u0069\u0066\u0066 i\u0073\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064\u003a\u0020\u0025v\u000a", _dgcgfb.DiffResults.IsPermitted()))
		if len(_dgcgfb.DiffResults.Warnings) > 0 {
			_ccadg.WriteString("\u004d\u0044\u0050\u0020\u0077\u0061\u0072\u006e\u0069n\u0067\u0073\u003a\u000a")
			for _, _aeac := range _dgcgfb.DiffResults.Warnings {
				_ccadg.WriteString(_c.Sprintf("\u0009\u0025\u0073\u000a", _aeac))
			}
		}
		if len(_dgcgfb.DiffResults.Errors) > 0 {
			_ccadg.WriteString("\u004d\u0044\u0050 \u0065\u0072\u0072\u006f\u0072\u0073\u003a\u000a")
			for _, _cbdca := range _dgcgfb.DiffResults.Errors {
				_ccadg.WriteString(_c.Sprintf("\u0009\u0025\u0073\u000a", _cbdca))
			}
		}
	}
	if _dgcgfb.IsCrlFound {
		_ccadg.WriteString("R\u0065\u0076\u006f\u0063\u0061\u0074i\u006f\u006e\u0020\u0064\u0061\u0074\u0061\u003a\u0020C\u0052\u004c\u0020f\u006fu\u006e\u0064\u000a")
	} else {
		_ccadg.WriteString("\u0052\u0065\u0076o\u0063\u0061\u0074\u0069o\u006e\u0020\u0064\u0061\u0074\u0061\u003a \u0043\u0052\u004c\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u000a")
	}
	if _dgcgfb.IsOcspFound {
		_ccadg.WriteString("\u0052\u0065\u0076\u006fc\u0061\u0074\u0069\u006f\u006e\u0020\u0064\u0061\u0074\u0061:\u0020O\u0043\u0053\u0050\u0020\u0066\u006f\u0075n\u0064\u000a")
	} else {
		_ccadg.WriteString("\u0052\u0065\u0076\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u0020\u0064\u0061\u0074\u0061:\u0020O\u0043\u0053\u0050\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u000a")
	}
	return _ccadg.String()
}

// NewPdfAnnotationCircle returns a new circle annotation.
func NewPdfAnnotationCircle() *PdfAnnotationCircle {
	_daf := NewPdfAnnotation()
	_eec := &PdfAnnotationCircle{}
	_eec.PdfAnnotation = _daf
	_eec.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_daf.SetContext(_eec)
	return _eec
}

// Register registers (caches) a model to primitive object relationship.
func (_affdd *modelManager) Register(primitive _df.PdfObject, model PdfModel) {
	_affdd._cebgf[model] = primitive
	_affdd._fdge[primitive] = model
}

// SetViewClip sets the value of the viewClip.
func (_cfdbe *ViewerPreferences) SetViewClip(viewClip PageBoundary) { _cfdbe._geabe = viewClip }

// NewPdfAnnotationMovie returns a new movie annotation.
func NewPdfAnnotationMovie() *PdfAnnotationMovie {
	_gdbd := NewPdfAnnotation()
	_aee := &PdfAnnotationMovie{}
	_aee.PdfAnnotation = _gdbd
	_gdbd.SetContext(_aee)
	return _aee
}

// GetContainingPdfObject returns the container of the DSS (indirect object).
func (_efde *DSS) GetContainingPdfObject() _df.PdfObject { return _efde._dbdf }

// GetContainingPdfObject returns the container of the resources object (indirect object).
func (_ebdbd *PdfPageResources) GetContainingPdfObject() _df.PdfObject { return _ebdbd._cecgg }

// PdfOutputIntent provides a means for matching the color characteristics of a PDF document with
// those of a target output device.
// Multiple PdfOutputIntents allows the production process to be customized to the expected workflow and the specific
// tools available.
type PdfOutputIntent struct {

	// Type is an optional PDF object that this dictionary describes.
	// If present, must be OutputIntent for an output intent dictionary.
	Type string

	// S defines the OutputIntent subtype which should match the standard used in given document i.e:
	// for PDF/X use PdfOutputIntentTypeX.
	S PdfOutputIntentType

	// OutputCondition is an optional field that is identifying the intended output device or production condition in
	// human-readable form. This is preferred method of defining such a string for presentation to the user.
	OutputCondition string

	// OutputConditionIdentifier is a required field identifying the intended output device or production condition in
	// human or machine-readable form. If human-readable, this string may be used
	// in lieu of an OutputCondition for presentation to the user.
	// A typical value for this entry would be the name of a production condition  maintained
	// in  an  industry-standard registry such  as the ICC Characterization Data Registry
	// If the intended production condition is not a recognized standard, the value Custom is recommended for this entry.
	// the DestOutputProfile entry defines the ICC profile, and the Info entry is used for further
	// human-readable identification.
	OutputConditionIdentifier string

	// RegistryName is an optional string field (conventionally URI) identifying the registry in which the condition
	// designated by OutputConditionIdentifier is defined.
	RegistryName string

	// Info is a required field if OutputConditionIdentifier does not specify a standard production condition.
	// A human-readable text string containing additional information  or comments about intended
	// target device or production condition.
	Info string

	// DestOutputProfile is required if OutputConditionIdentifier does not specify a standard production condition.
	// It is an ICC profile stream defining the transformation from the PDF document's source colors to output device colorants.
	DestOutputProfile []byte

	// ColorComponents is the number of color components supported by given output profile.
	ColorComponents int
	_eeff           *_df.PdfObjectDictionary
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 1 for a grayscale device.
func (_cfeg *PdfColorspaceDeviceGray) GetNumComponents() int { return 1 }

// String returns string value of output intent for given type
// ISO_19005-2 6.2.3: GTS_PDFA1 value should be used for PDF/A-1, A-2 and A-3 at least
func (_dcgb PdfOutputIntentType) String() string {
	switch _dcgb {
	case PdfOutputIntentTypeA1:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeA2:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeA3:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeA4:
		return "\u0047T\u0053\u005f\u0050\u0044\u0046\u00411"
	case PdfOutputIntentTypeX:
		return "\u0047\u0054\u0053\u005f\u0050\u0044\u0046\u0058"
	default:
		return "\u0055N\u0044\u0045\u0046\u0049\u004e\u0045D"
	}
}

// GetOutlinesFlattened returns a flattened list of tree nodes and titles.
// NOTE: for most use cases, it is recommended to use the high-level GetOutlines
// method instead, which also provides information regarding the destination
// of the outline items.
func (_adcdc *PdfReader) GetOutlinesFlattened() ([]*PdfOutlineTreeNode, []string, error) {
	var _ebgde []*PdfOutlineTreeNode
	var _fagdd []string
	var _gagfb func(*PdfOutlineTreeNode, *[]*PdfOutlineTreeNode, *[]string, int)
	_gagfb = func(_deeef *PdfOutlineTreeNode, _dbad *[]*PdfOutlineTreeNode, _ggcbb *[]string, _dgegf int) {
		if _deeef == nil {
			return
		}
		if _deeef._dcgc == nil {
			_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020M\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006e\u006fd\u0065\u002e\u0063o\u006et\u0065\u0078\u0074")
			return
		}
		_gegbg, _fgcgd := _deeef._dcgc.(*PdfOutlineItem)
		if _fgcgd {
			*_dbad = append(*_dbad, &_gegbg.PdfOutlineTreeNode)
			_cbab := _gc.Repeat("\u0020", _dgegf*2) + _gegbg.Title.Decoded()
			*_ggcbb = append(*_ggcbb, _cbab)
		}
		if _deeef.First != nil {
			_afbce := _gc.Repeat("\u0020", _dgegf*2) + "\u002b"
			*_ggcbb = append(*_ggcbb, _afbce)
			_gagfb(_deeef.First, _dbad, _ggcbb, _dgegf+1)
		}
		if _fgcgd && _gegbg.Next != nil {
			_gagfb(_gegbg.Next, _dbad, _ggcbb, _dgegf)
		}
	}
	_gagfb(_adcdc._baaeg, &_ebgde, &_fagdd, 0)
	return _ebgde, _fagdd, nil
}

// ToPdfObject convert PdfInfo to pdf object.
func (_ffaeb *PdfInfo) ToPdfObject() _df.PdfObject {
	_aede := _df.MakeDict()
	_aede.SetIfNotNil("\u0054\u0069\u0074l\u0065", _ffaeb.Title)
	_aede.SetIfNotNil("\u0041\u0075\u0074\u0068\u006f\u0072", _ffaeb.Author)
	_aede.SetIfNotNil("\u0053u\u0062\u006a\u0065\u0063\u0074", _ffaeb.Subject)
	_aede.SetIfNotNil("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073", _ffaeb.Keywords)
	_aede.SetIfNotNil("\u0043r\u0065\u0061\u0074\u006f\u0072", _ffaeb.Creator)
	_aede.SetIfNotNil("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072", _ffaeb.Producer)
	_aede.SetIfNotNil("\u0054r\u0061\u0070\u0070\u0065\u0064", _ffaeb.Trapped)
	if _ffaeb.CreationDate != nil {
		_aede.SetIfNotNil("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _ffaeb.CreationDate.ToPdfObject())
	}
	if _ffaeb.ModifiedDate != nil {
		_aede.SetIfNotNil("\u004do\u0064\u0044\u0061\u0074\u0065", _ffaeb.ModifiedDate.ToPdfObject())
	}
	for _, _fcbgd := range _ffaeb._bcec.Keys() {
		_aede.SetIfNotNil(_fcbgd, _ffaeb._bcec.Get(_fcbgd))
	}
	return _aede
}

var (
	CourierName              = _da.CourierName
	CourierBoldName          = _da.CourierBoldName
	CourierObliqueName       = _da.CourierObliqueName
	CourierBoldObliqueName   = _da.CourierBoldObliqueName
	HelveticaName            = _da.HelveticaName
	HelveticaBoldName        = _da.HelveticaBoldName
	HelveticaObliqueName     = _da.HelveticaObliqueName
	HelveticaBoldObliqueName = _da.HelveticaBoldObliqueName
	SymbolName               = _da.SymbolName
	ZapfDingbatsName         = _da.ZapfDingbatsName
	TimesRomanName           = _da.TimesRomanName
	TimesBoldName            = _da.TimesBoldName
	TimesItalicName          = _da.TimesItalicName
	TimesBoldItalicName      = _da.TimesBoldItalicName
)

// NewPdfAction returns an initialized generic PDF action model.
func NewPdfAction() *PdfAction {
	_ccb := &PdfAction{}
	_ccb._gcf = _df.MakeIndirectObject(_df.MakeDict())
	return _ccb
}

// PdfColorspaceSpecialIndexed is an indexed color space is a lookup table, where the input element
// is an index to the lookup table and the output is a color defined in the lookup table in the Base
// colorspace.
// [/Indexed base hival lookup]
type PdfColorspaceSpecialIndexed struct {
	Base   PdfColorspace
	HiVal  int
	Lookup _df.PdfObject
	_befa  []byte
	_bade  *_df.PdfIndirectObject
}

// GetPdfInfo returns the PDF info dictionary.
func (_cgdce *PdfReader) GetPdfInfo() (*PdfInfo, error) {
	_fceb, _cabgf := _cgdce.GetTrailer()
	if _cabgf != nil {
		return nil, _cabgf
	}
	var _fcfeb *_df.PdfObjectDictionary
	_beafee := _fceb.Get("\u0049\u006e\u0066\u006f")
	switch _efbgg := _beafee.(type) {
	case *_df.PdfObjectReference:
		_fbde := _efbgg
		_beafee, _cabgf = _cgdce.GetIndirectObjectByNumber(int(_fbde.ObjectNumber))
		_beafee = _df.TraceToDirectObject(_beafee)
		if _cabgf != nil {
			return nil, _cabgf
		}
		_fcfeb, _ = _beafee.(*_df.PdfObjectDictionary)
	case *_df.PdfObjectDictionary:
		_fcfeb = _efbgg
	}
	if _fcfeb == nil {
		return nil, _deb.New("I\u006e\u0066\u006f\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006eo\u0074\u0020\u0070r\u0065s\u0065\u006e\u0074")
	}
	_fffbg, _cabgf := NewPdfInfoFromObject(_fcfeb)
	if _cabgf != nil {
		return nil, _cabgf
	}
	return _fffbg, nil
}

// DecodeArray returns an empty slice as there are no components associated with pattern colorspace.
func (_eedbe *PdfColorspaceSpecialPattern) DecodeArray() []float64 { return []float64{} }

// ToPdfObject returns colorspace in a PDF object format [name stream]
func (_eaaf *PdfColorspaceICCBased) ToPdfObject() _df.PdfObject {
	_ggbg := &_df.PdfObjectArray{}
	_ggbg.Append(_df.MakeName("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064"))
	var _dbff *_df.PdfObjectStream
	if _eaaf._gdgeg != nil {
		_dbff = _eaaf._gdgeg
	} else {
		_dbff = &_df.PdfObjectStream{}
	}
	_ccaf := _df.MakeDict()
	_ccaf.Set("\u004e", _df.MakeInteger(int64(_eaaf.N)))
	if _eaaf.Alternate != nil {
		_ccaf.Set("\u0041l\u0074\u0065\u0072\u006e\u0061\u0074e", _eaaf.Alternate.ToPdfObject())
	}
	if _eaaf.Metadata != nil {
		_ccaf.Set("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _eaaf.Metadata)
	}
	if _eaaf.Range != nil {
		var _ffdf []_df.PdfObject
		for _, _egge := range _eaaf.Range {
			_ffdf = append(_ffdf, _df.MakeFloat(_egge))
		}
		_ccaf.Set("\u0052\u0061\u006eg\u0065", _df.MakeArray(_ffdf...))
	}
	_ccaf.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _df.MakeInteger(int64(len(_eaaf.Data))))
	_dbff.Stream = _eaaf.Data
	_dbff.PdfObjectDictionary = _ccaf
	_ggbg.Append(_dbff)
	if _eaaf._cdggfa != nil {
		_eaaf._cdggfa.PdfObject = _ggbg
		return _eaaf._cdggfa
	}
	return _ggbg
}

// Hasher is the interface that wraps the basic Write method.
type Hasher interface {
	Write(_dabeb []byte) (_ggda int, _fbdbfe error)
}

func (_ebbc *PdfWriter) AttachFile(file *EmbeddedFile) error {
	_fbfd := _ebbc._adadc
	if _fbfd == nil {
		_fbfd = _febd()
	}
	_caced := _fbfd.addEmbeddedFile(file)
	if _caced != nil {
		return _caced
	}
	_ebbc._adadc = _fbfd
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_bba *PdfActionSetOCGState) ToPdfObject() _df.PdfObject {
	_bba.PdfAction.ToPdfObject()
	_gda := _bba._gcf
	_cad := _gda.PdfObject.(*_df.PdfObjectDictionary)
	_cad.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeSetOCGState)))
	_cad.SetIfNotNil("\u0053\u0074\u0061t\u0065", _bba.State)
	_cad.SetIfNotNil("\u0050\u0072\u0065\u0073\u0065\u0072\u0076\u0065\u0052\u0042", _bba.PreserveRB)
	return _gda
}

func (_ebgb *PdfReader) newPdfFieldSignatureFromDict(_eece *_df.PdfObjectDictionary) (*PdfFieldSignature, error) {
	_gffcb := &PdfFieldSignature{}
	_ecdg, _dcbe := _df.GetIndirect(_eece.Get("\u0056"))
	if _dcbe {
		var _cdgf error
		_gffcb.V, _cdgf = _ebgb.newPdfSignatureFromIndirect(_ecdg)
		if _cdgf != nil {
			return nil, _cdgf
		}
	}
	_gffcb.Lock, _ = _df.GetIndirect(_eece.Get("\u004c\u006f\u0063\u006b"))
	_gffcb.SV, _ = _df.GetIndirect(_eece.Get("\u0053\u0056"))
	return _gffcb, nil
}

func _dcgg(_eaeb *fontCommon) *pdfFontSimple { return &pdfFontSimple{fontCommon: *_eaeb} }

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// L (range 0-100), A (range -100-100) and B (range -100-100) components of
// the color.
func (_gefgf *PdfColorspaceLab) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_abee := vals[0]
	if _abee < 0.0 || _abee > 100.0 {
		_bcd.Log.Debug("\u004c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0030-\u0031\u0030\u0030\u0029", _abee)
		return nil, ErrColorOutOfRange
	}
	_gbgf := vals[1]
	_fgee := float64(-100)
	_bagce := float64(100)
	if len(_gefgf.Range) > 1 {
		_fgee = _gefgf.Range[0]
		_bagce = _gefgf.Range[1]
	}
	if _gbgf < _fgee || _gbgf > _bagce {
		_bcd.Log.Debug("\u0041\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u003b\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0025\u0076\u0020\u0074o\u0020\u0025\u0076\u0029", _gbgf, _fgee, _bagce)
		return nil, ErrColorOutOfRange
	}
	_cbda := vals[2]
	_cdfg := float64(-100)
	_dcff := float64(100)
	if len(_gefgf.Range) > 3 {
		_cdfg = _gefgf.Range[2]
		_dcff = _gefgf.Range[3]
	}
	if _cbda < _cdfg || _cbda > _dcff {
		_bcd.Log.Debug("\u0062\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u003b\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0025\u0076\u0020\u0074o\u0020\u0025\u0076\u0029", _cbda, _cdfg, _dcff)
		return nil, ErrColorOutOfRange
	}
	_fdade := NewPdfColorLab(_abee, _gbgf, _cbda)
	return _fdade, nil
}

// UpdateXObjectImageFromImage creates a new XObject Image from an
// Image object `img` and default masks from xobjIn.
// The default masks are overridden if img.hasAlpha
// If `encoder` is nil, uses raw encoding (none).
func UpdateXObjectImageFromImage(xobjIn *XObjectImage, img *Image, cs PdfColorspace, encoder _df.StreamEncoder) (*XObjectImage, error) {
	if encoder == nil {
		var _cfgfb error
		encoder, _cfgfb = img.getSuitableEncoder()
		if _cfgfb != nil {
			_bcd.Log.Debug("F\u0061\u0069l\u0075\u0072\u0065\u0020\u006f\u006e\u0020\u0066\u0069\u006e\u0064\u0069\u006e\u0067\u0020\u0073\u0075\u0069\u0074\u0061b\u006c\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072,\u0020\u0066\u0061\u006c\u006c\u0062\u0061\u0063\u006b\u0020\u0074\u006f\u0020R\u0061\u0077\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020%\u0076", _cfgfb)
			encoder = _df.NewRawEncoder()
		}
	}
	encoder.UpdateParams(img.GetParamsDict())
	_bgfdc, _abegef := encoder.EncodeBytes(img.Data)
	if _abegef != nil {
		_bcd.Log.Debug("\u0045\u0072\u0072or\u0020\u0077\u0069\u0074\u0068\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0076", _abegef)
		return nil, _abegef
	}
	_bfebe := NewXObjectImage()
	_ecdac := img.Width
	_faeaf := img.Height
	_bfebe.Width = &_ecdac
	_bfebe.Height = &_faeaf
	_dagec := img.BitsPerComponent
	_bfebe.BitsPerComponent = &_dagec
	_bfebe.Filter = encoder
	_bfebe.Stream = _bgfdc
	if cs == nil {
		if img.ColorComponents == 1 {
			_bfebe.ColorSpace = NewPdfColorspaceDeviceGray()
			if img.BitsPerComponent == 16 {
				switch encoder.(type) {
				case *_df.DCTEncoder:
					_bfebe.ColorSpace = NewPdfColorspaceDeviceRGB()
					_dagec = 8
					_bfebe.BitsPerComponent = &_dagec
				}
			}
		} else if img.ColorComponents == 3 {
			_bfebe.ColorSpace = NewPdfColorspaceDeviceRGB()
		} else if img.ColorComponents == 4 {
			switch encoder.(type) {
			case *_df.DCTEncoder:
				_bfebe.ColorSpace = NewPdfColorspaceDeviceRGB()
			default:
				_bfebe.ColorSpace = NewPdfColorspaceDeviceCMYK()
			}
		} else {
			return nil, _deb.New("c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020u\u006e\u0064\u0065\u0066in\u0065\u0064")
		}
	} else {
		_bfebe.ColorSpace = cs
	}
	if len(img._gebab) != 0 {
		_ebdff := NewXObjectImage()
		_ebdff.Filter = encoder
		_bdfeaa, _cfgeab := encoder.EncodeBytes(img._gebab)
		if _cfgeab != nil {
			_bcd.Log.Debug("\u0045\u0072\u0072or\u0020\u0077\u0069\u0074\u0068\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0076", _cfgeab)
			return nil, _cfgeab
		}
		_ebdff.Stream = _bdfeaa
		_ebdff.BitsPerComponent = _bfebe.BitsPerComponent
		_ebdff.Width = &img.Width
		_ebdff.Height = &img.Height
		_ebdff.ColorSpace = NewPdfColorspaceDeviceGray()
		_bfebe.SMask = _ebdff.ToPdfObject()
	} else {
		_bfebe.SMask = xobjIn.SMask
		_bfebe.ImageMask = xobjIn.ImageMask
		if _bfebe.ColorSpace.GetNumComponents() == 1 {
			_bfgba(_bfebe)
		}
	}
	return _bfebe, nil
}

// ToPdfOutlineItem returns a low level PdfOutlineItem object,
// based on the current instance.
func (_aeded *OutlineItem) ToPdfOutlineItem() (*PdfOutlineItem, int64) {
	_aecb := NewPdfOutlineItem()
	_aecb.Title = _df.MakeEncodedString(_aeded.Title, true)
	_aecb.Dest = _aeded.Dest.ToPdfObject()
	var _debgb []*PdfOutlineItem
	var _bbaaa int64
	var _cegfe *PdfOutlineItem
	for _, _bcece := range _aeded.Entries {
		_gcac, _baegc := _bcece.ToPdfOutlineItem()
		_gcac.Parent = &_aecb.PdfOutlineTreeNode
		if _cegfe != nil {
			_cegfe.Next = &_gcac.PdfOutlineTreeNode
			_gcac.Prev = &_cegfe.PdfOutlineTreeNode
		}
		_debgb = append(_debgb, _gcac)
		_bbaaa += _baegc
		_cegfe = _gcac
	}
	_cfgg := len(_debgb)
	_bbaaa += int64(_cfgg)
	if _cfgg > 0 {
		_aecb.First = &_debgb[0].PdfOutlineTreeNode
		_aecb.Last = &_debgb[_cfgg-1].PdfOutlineTreeNode
		_aecb.Count = &_bbaaa
	}
	return _aecb, _bbaaa
}

// SetPage directly sets the page object.
func (_cdadc *KDict) SetPage(page *_df.PdfIndirectObject) { _cdadc.Pg = page }

func _addec(_bfce _df.PdfObject) (*fontFile, error) {
	_bcd.Log.Trace("\u006e\u0065\u0077\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0046\u0072\u006f\u006dP\u0064f\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u006f\u0062\u006a\u003d\u0025\u0073", _bfce)
	_gdaac := &fontFile{}
	_bfce = _df.TraceToDirectObject(_bfce)
	_bdda, _ggaf := _bfce.(*_df.PdfObjectStream)
	if !_ggaf {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020F\u006f\u006et\u0046\u0069\u006c\u0065\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0028\u0025\u0054\u0029", _bfce)
		return nil, _df.ErrTypeError
	}
	_gagba := _bdda.PdfObjectDictionary
	_acfbb, _bgcf := _df.DecodeStream(_bdda)
	if _bgcf != nil {
		return nil, _bgcf
	}
	_eded, _ggaf := _df.GetNameVal(_gagba.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"))
	if !_ggaf {
		_gdaac._gdde = _eded
		if _eded == "\u0054\u0079\u0070\u0065\u0031\u0043" {
			_bcd.Log.Debug("T\u0079\u0070\u0065\u0031\u0043\u0020\u0066\u006f\u006e\u0074\u0073\u0020\u0061\u0072\u0065\u0020\u0063\u0075r\u0072\u0065\u006e\u0074\u006c\u0079\u0020\u006e\u006f\u0074 s\u0075\u0070\u0070o\u0072t\u0065\u0064")
			return nil, ErrType1CFontNotSupported
		}
	}
	_eceee, _ := _df.GetIntVal(_gagba.Get("\u004ce\u006e\u0067\u0074\u0068\u0031"))
	_gfdbc, _ := _df.GetIntVal(_gagba.Get("\u004ce\u006e\u0067\u0074\u0068\u0032"))
	if _eceee > len(_acfbb) {
		_eceee = len(_acfbb)
	}
	if _eceee+_gfdbc > len(_acfbb) {
		_gfdbc = len(_acfbb) - _eceee
	}
	_ggbc := _acfbb[:_eceee]
	var _gbbaf []byte
	if _gfdbc > 0 {
		_gbbaf = _acfbb[_eceee : _eceee+_gfdbc]
	}
	if _eceee > 0 && _gfdbc > 0 {
		_eege := _gdaac.loadFromSegments(_ggbc, _gbbaf)
		if _eege != nil {
			return nil, _eege
		}
	}
	return _gdaac, nil
}

// Set sets the colorspace corresponding to key. Add to Names if not set.
func (_agag *PdfPageResourcesColorspaces) Set(key _df.PdfObjectName, val PdfColorspace) {
	if _, _afgda := _agag.Colorspaces[string(key)]; !_afgda {
		_agag.Names = append(_agag.Names, string(key))
	}
	_agag.Colorspaces[string(key)] = val
}

// AddExtGState add External Graphics State (GState). The gsDict can be specified
// either directly as a dictionary or an indirect object containing a dictionary.
func (_cfgea *PdfPageResources) AddExtGState(gsName _df.PdfObjectName, gsDict _df.PdfObject) error {
	if _cfgea.ExtGState == nil {
		_cfgea.ExtGState = _df.MakeDict()
	}
	_bcgcb := _cfgea.ExtGState
	_ebdbcc, _efdge := _df.TraceToDirectObject(_bcgcb).(*_df.PdfObjectDictionary)
	if !_efdge {
		_bcd.Log.Debug("\u0045\u0078\u0074\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0074\u0079\u0070\u0065\u0020e\u0072r\u006f\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u002f\u0025\u0054\u0029", _bcgcb, _df.TraceToDirectObject(_bcgcb))
		return _df.ErrTypeError
	}
	_ebdbcc.Set(gsName, gsDict)
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_aaea *PdfAnnotationWidget) ToPdfObject() _df.PdfObject {
	_aaea.PdfAnnotation.ToPdfObject()
	_dag := _aaea._bfde
	_cgddd := _dag.PdfObject.(*_df.PdfObjectDictionary)
	if _aaea._dcb {
		return _dag
	}
	_aaea._dcb = true
	_cgddd.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0057\u0069\u0064\u0067\u0065\u0074"))
	_cgddd.SetIfNotNil("\u0048", _aaea.H)
	_cgddd.SetIfNotNil("\u004d\u004b", _aaea.MK)
	_cgddd.SetIfNotNil("\u0041", _aaea.A)
	_cgddd.SetIfNotNil("\u0041\u0041", _aaea.AA)
	_cgddd.SetIfNotNil("\u0042\u0053", _aaea.BS)
	_dcdd := _aaea.Parent
	if _aaea._aeaf != nil {
		if _aaea._aeaf._cdbc == _aaea._bfde {
			_aaea._aeaf.ToPdfObject()
		}
		_dcdd = _aaea._aeaf.GetContainingPdfObject()
	}
	if _dcdd != _dag {
		_cgddd.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _dcdd)
	}
	_aaea._dcb = false
	return _dag
}

// SetContext sets the specific fielddata type, e.g. would be PdfFieldButton for a button field.
func (_adbd *PdfField) SetContext(ctx PdfModel) { _adbd._efcbg = ctx }

// ToPdfObject returns the PDF representation of the tiling pattern.
func (_efdab *PdfTilingPattern) ToPdfObject() _df.PdfObject {
	_efdab.PdfPattern.ToPdfObject()
	_dgfcge := _efdab.getDict()
	if _efdab.PaintType != nil {
		_dgfcge.Set("\u0050a\u0069\u006e\u0074\u0054\u0079\u0070e", _efdab.PaintType)
	}
	if _efdab.TilingType != nil {
		_dgfcge.Set("\u0054\u0069\u006c\u0069\u006e\u0067\u0054\u0079\u0070\u0065", _efdab.TilingType)
	}
	if _efdab.BBox != nil {
		_dgfcge.Set("\u0042\u0042\u006f\u0078", _efdab.BBox.ToPdfObject())
	}
	if _efdab.XStep != nil {
		_dgfcge.Set("\u0058\u0053\u0074e\u0070", _efdab.XStep)
	}
	if _efdab.YStep != nil {
		_dgfcge.Set("\u0059\u0053\u0074e\u0070", _efdab.YStep)
	}
	if _efdab.Resources != nil {
		_dgfcge.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _efdab.Resources.ToPdfObject())
	}
	if _efdab.Matrix != nil {
		_dgfcge.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _efdab.Matrix)
	}
	return _efdab._cbce
}

func _fefg(_gecdg _df.PdfObject) (*PdfColorspaceICCBased, error) {
	_cgaf := &PdfColorspaceICCBased{}
	if _aedff, _eaec := _gecdg.(*_df.PdfIndirectObject); _eaec {
		_cgaf._cdggfa = _aedff
	}
	_gecdg = _df.TraceToDirectObject(_gecdg)
	_gedc, _daea := _gecdg.(*_df.PdfObjectArray)
	if !_daea {
		return nil, _c.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _gedc.Len() != 2 {
		return nil, _c.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020c\u006f\u006c\u006fr\u0073p\u0061\u0063\u0065")
	}
	_gecdg = _df.TraceToDirectObject(_gedc.Get(0))
	_ebeg, _daea := _gecdg.(*_df.PdfObjectName)
	if !_daea {
		return nil, _c.Errorf("\u0049\u0043\u0043B\u0061\u0073\u0065\u0064 \u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	if *_ebeg != "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064" {
		return nil, _c.Errorf("\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0049\u0043\u0043\u0042a\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065")
	}
	_gecdg = _gedc.Get(1)
	_abeb, _daea := _df.GetStream(_gecdg)
	if !_daea {
		_bcd.Log.Error("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u006e\u006f\u0074\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067\u0020t\u006f\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020%\u0054", _gecdg)
		return nil, _c.Errorf("\u0049\u0043\u0043Ba\u0073\u0065\u0064\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	_ebabd := _abeb.PdfObjectDictionary
	_fade, _daea := _ebabd.Get("\u004e").(*_df.PdfObjectInteger)
	if !_daea {
		return nil, _c.Errorf("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u006d\u0069\u0073\u0073\u0069n\u0067\u0020\u004e\u0020\u0066\u0072\u006fm\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074")
	}
	if *_fade != 1 && *_fade != 3 && *_fade != 4 {
		return nil, _c.Errorf("\u0049\u0043\u0043\u0042\u0061s\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065 \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020\u0028\u006e\u006f\u0074\u0020\u0031\u002c\u0033\u002c\u0034\u0029")
	}
	_cgaf.N = int(*_fade)
	if _cbfad := _ebabd.Get("\u0041l\u0074\u0065\u0072\u006e\u0061\u0074e"); _cbfad != nil {
		_fabe, _deaeac := NewPdfColorspaceFromPdfObject(_cbfad)
		if _deaeac != nil {
			return nil, _deaeac
		}
		_cgaf.Alternate = _fabe
	}
	if _gbbg := _ebabd.Get("\u0052\u0061\u006eg\u0065"); _gbbg != nil {
		_gbbg = _df.TraceToDirectObject(_gbbg)
		_acede, _fbabc := _gbbg.(*_df.PdfObjectArray)
		if !_fbabc {
			return nil, _c.Errorf("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u0052\u0061\u006e\u0067\u0065\u0020\u006e\u006ft\u0020\u0061\u006e \u0061r\u0072\u0061\u0079")
		}
		if _acede.Len() != 2*_cgaf.N {
			return nil, _c.Errorf("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020\u0052\u0061\u006e\u0067e\u0020\u0077\u0072\u006f\u006e\u0067 \u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0065\u006c\u0065m\u0065\u006e\u0074\u0073")
		}
		_egea, _edbb := _acede.GetAsFloat64Slice()
		if _edbb != nil {
			return nil, _edbb
		}
		_cgaf.Range = _egea
	} else {
		_cgaf.Range = make([]float64, 2*_cgaf.N)
		for _fcaff := 0; _fcaff < _cgaf.N; _fcaff++ {
			_cgaf.Range[2*_fcaff] = 0.0
			_cgaf.Range[2*_fcaff+1] = 1.0
		}
	}
	if _ffcca := _ebabd.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _ffcca != nil {
		_gdaae, _gbea := _ffcca.(*_df.PdfObjectStream)
		if !_gbea {
			return nil, _c.Errorf("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020\u004de\u0074\u0061\u0064\u0061\u0074\u0061\u0020n\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d")
		}
		_cgaf.Metadata = _gdaae
	}
	_dcbgf, _eebaa := _df.DecodeStream(_abeb)
	if _eebaa != nil {
		return nil, _eebaa
	}
	_cgaf.Data = _dcbgf
	_cgaf._gdgeg = _abeb
	return _cgaf, nil
}

// NewStandard14Font returns the standard 14 font named `basefont` as a *PdfFont, or an error if it
// `basefont` is not one of the standard 14 font names.
func NewStandard14Font(basefont StdFontName) (*PdfFont, error) {
	_fcfeg, _cbfeb := _aedd(basefont)
	if _cbfeb != nil {
		return nil, _cbfeb
	}
	if basefont != SymbolName && basefont != ZapfDingbatsName {
		_fcfeg._ebgg = _abg.NewWinAnsiEncoder()
	}
	return &PdfFont{_eaeg: &_fcfeg}, nil
}

// PdfAnnotationFileAttachment represents FileAttachment annotations.
// (Section 12.5.6.15).
type PdfAnnotationFileAttachment struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	FS   _df.PdfObject
	Name _df.PdfObject
}

func _bbdeg() string { _gcdec.Lock(); defer _gcdec.Unlock(); return _eabgb }

// AddCerts adds certificates to DSS.
func (_dgfe *DSS) AddCerts(certs [][]byte) ([]*_df.PdfObjectStream, error) {
	return _dgfe.add(&_dgfe.Certs, _dgfe._cdeb, certs)
}

// NewPdfColorspaceDeviceRGB returns a new RGB colorspace object.
func NewPdfColorspaceDeviceRGB() *PdfColorspaceDeviceRGB { return &PdfColorspaceDeviceRGB{} }

// NewPdfAnnotationPolyLine returns a new polyline annotation.
func NewPdfAnnotationPolyLine() *PdfAnnotationPolyLine {
	_bfbg := NewPdfAnnotation()
	_gbbd := &PdfAnnotationPolyLine{}
	_gbbd.PdfAnnotation = _bfbg
	_gbbd.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_bfbg.SetContext(_gbbd)
	return _gbbd
}

// SetOCProperties sets the optional content properties.
func (_gedg *PdfWriter) SetOCProperties(ocProperties _df.PdfObject) error {
	_bddaa := _gedg._gdee
	if ocProperties != nil {
		_bcd.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u004f\u0043\u0020\u0050\u0072o\u0070\u0065\u0072\u0074\u0069\u0065\u0073\u002e\u002e\u002e")
		_bddaa.Set("\u004f\u0043\u0050r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073", ocProperties)
		return _gedg.addObjects(ocProperties)
	}
	return nil
}

// PdfActionLaunch represents a launch action.
type PdfActionLaunch struct {
	*PdfAction
	F         *PdfFilespec
	Win       _df.PdfObject
	Mac       _df.PdfObject
	Unix      _df.PdfObject
	NewWindow _df.PdfObject
}

// PageCallback callback function used in page loading
// that could be used to modify the page content.
//
// Deprecated: will be removed in v4. Use PageProcessCallback instead.
type PageCallback func(_bcbde int, _fedfa *PdfPage)

// ColorToRGB converts gray -> rgb for a single color component.
func (_dbfa *PdfColorspaceDeviceGray) ColorToRGB(color PdfColor) (PdfColor, error) {
	_dcbce, _egcc := color.(*PdfColorDeviceGray)
	if !_egcc {
		_bcd.Log.Debug("\u0049\u006e\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006fr\u0020\u006e\u006f\u0074\u0020\u0064\u0065v\u0069\u0063\u0065\u0020\u0067\u0072\u0061\u0079\u0020\u0025\u0054", color)
		return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	return NewPdfColorDeviceRGB(float64(*_dcbce), float64(*_dcbce), float64(*_dcbce)), nil
}

// PdfAnnotationLink represents Link annotations.
// (Section 12.5.6.5 p. 403).
type PdfAnnotationLink struct {
	*PdfAnnotation
	A          _df.PdfObject
	Dest       _df.PdfObject
	H          _df.PdfObject
	PA         _df.PdfObject
	QuadPoints _df.PdfObject
	BS         _df.PdfObject
	_aefc      *PdfAction
	_caae      *PdfReader
}

// GetRefObject returns the reference object of the KValue.
func (_caffdd *KValue) GetRefObject() _df.PdfObject { return _caffdd._ccgeg }

// DecodeArray returns the range of color component values in DeviceCMYK colorspace.
func (_ddae *PdfColorspaceDeviceCMYK) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}

// PdfAnnotationMarkup represents additional fields for mark-up annotations.
// (Section 12.5.6.2 p. 399).
type PdfAnnotationMarkup struct {
	T            _df.PdfObject
	Popup        *PdfAnnotationPopup
	CA           _df.PdfObject
	RC           _df.PdfObject
	CreationDate _df.PdfObject
	IRT          _df.PdfObject
	Subj         _df.PdfObject
	RT           _df.PdfObject
	IT           _df.PdfObject
	ExData       _df.PdfObject
}

func (_geceg *PdfWriter) checkPendingObjects() {
	for _gfag, _bgdaa := range _geceg._acgefe {
		if !_geceg.hasObject(_gfag) {
			_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u0020\u0050\u0065n\u0064\u0069\u006eg\u0020\u006f\u0062j\u0065\u0063t\u0020\u0025\u002b\u0076\u0020\u0025T\u0020(%\u0070\u0029\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0061\u0064\u0064\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0077\u0072\u0069\u0074\u0069\u006e\u0067", _gfag, _gfag, _gfag)
			for _, _cbdcc := range _bgdaa {
				for _, _addc := range _cbdcc.Keys() {
					_cceac := _cbdcc.Get(_addc)
					if _cceac == _gfag {
						_bcd.Log.Debug("\u0050e\u006e\u0064i\u006e\u0067\u0020\u006fb\u006a\u0065\u0063t\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0061nd\u0020\u0072\u0065p\u006c\u0061c\u0065\u0064\u0020\u0077\u0069\u0074h\u0020\u006eu\u006c\u006c")
						_cbdcc.Set(_addc, _df.MakeNull())
						break
					}
				}
			}
		}
	}
}

func (_daffc *PdfSignature) extractChainFromCert() ([]*_ed.Certificate, error) {
	var _bfdcba *_df.PdfObjectArray
	switch _dcec := _daffc.Cert.(type) {
	case *_df.PdfObjectString:
		_bfdcba = _df.MakeArray(_dcec)
	case *_df.PdfObjectArray:
		_bfdcba = _dcec
	default:
		return nil, _c.Errorf("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054", _dcec)
	}
	var _cdbad _ef.Buffer
	for _, _gbfbd := range _bfdcba.Elements() {
		_ccede, _dbeff := _df.GetString(_gbfbd)
		if !_dbeff {
			return nil, _c.Errorf("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054", _gbfbd)
		}
		if _, _dbfebf := _cdbad.Write(_ccede.Bytes()); _dbfebf != nil {
			return nil, _dbfebf
		}
	}
	return _ed.ParseCertificates(_cdbad.Bytes())
}

// IsHideMenubar returns the value of the hideMenubar flag.
func (_ggbcf *ViewerPreferences) IsHideMenubar() bool {
	if _ggbcf._abebaec == nil {
		return false
	}
	return *_ggbcf._abebaec
}

// ToPdfObject implements interface PdfModel.
func (_gbaa *PdfAnnotation3D) ToPdfObject() _df.PdfObject {
	_gbaa.PdfAnnotation.ToPdfObject()
	_bgad := _gbaa._bfde
	_dbaa := _bgad.PdfObject.(*_df.PdfObjectDictionary)
	_dbaa.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0033\u0044"))
	_dbaa.SetIfNotNil("\u0033\u0044\u0044", _gbaa.T3DD)
	_dbaa.SetIfNotNil("\u0033\u0044\u0056", _gbaa.T3DV)
	_dbaa.SetIfNotNil("\u0033\u0044\u0041", _gbaa.T3DA)
	_dbaa.SetIfNotNil("\u0033\u0044\u0049", _gbaa.T3DI)
	_dbaa.SetIfNotNil("\u0033\u0044\u0042", _gbaa.T3DB)
	return _bgad
}

// ToPdfObject implements model.PdfModel interface.
func (_acbc *PdfOutputIntent) ToPdfObject() _df.PdfObject {
	if _acbc._eeff == nil {
		_acbc._eeff = _df.MakeDict()
	}
	_debba := _acbc._eeff
	if _acbc.Type != "" {
		_debba.Set("\u0054\u0079\u0070\u0065", _df.MakeName(_acbc.Type))
	}
	_debba.Set("\u0053", _df.MakeName(_acbc.S.String()))
	if _acbc.OutputCondition != "" {
		_debba.Set("\u004fu\u0074p\u0075\u0074\u0043\u006f\u006e\u0064\u0069\u0074\u0069\u006f\u006e", _df.MakeString(_acbc.OutputCondition))
	}
	_debba.Set("\u004fu\u0074\u0070\u0075\u0074C\u006f\u006e\u0064\u0069\u0074i\u006fn\u0049d\u0065\u006e\u0074\u0069\u0066\u0069\u0065r", _df.MakeString(_acbc.OutputConditionIdentifier))
	_debba.Set("\u0052\u0065\u0067i\u0073\u0074\u0072\u0079\u004e\u0061\u006d\u0065", _df.MakeString(_acbc.RegistryName))
	if _acbc.Info != "" {
		_debba.Set("\u0049\u006e\u0066\u006f", _df.MakeString(_acbc.Info))
	}
	if len(_acbc.DestOutputProfile) != 0 {
		_afgbg, _cgef := _df.MakeStream(_acbc.DestOutputProfile, _df.NewFlateEncoder())
		if _cgef != nil {
			_bcd.Log.Error("\u004d\u0061\u006b\u0065\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0044\u0065s\u0074\u004f\u0075\u0074\u0070\u0075t\u0050\u0072\u006f\u0066\u0069\u006c\u0065\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076", _cgef)
		}
		_afgbg.PdfObjectDictionary.Set("\u004e", _df.MakeInteger(int64(_acbc.ColorComponents)))
		_badc := make([]float64, _acbc.ColorComponents*2)
		for _eefdd := 0; _eefdd < _acbc.ColorComponents*2; _eefdd++ {
			_cgcag := 0.0
			if _eefdd%2 != 0 {
				_cgcag = 1.0
			}
			_badc[_eefdd] = _cgcag
		}
		_afgbg.PdfObjectDictionary.Set("\u0052\u0061\u006eg\u0065", _df.MakeArrayFromFloats(_badc))
		_debba.Set("\u0044\u0065\u0073\u0074\u004f\u0075\u0074\u0070\u0075\u0074\u0050\u0072o\u0066\u0069\u006c\u0065", _afgbg)
	}
	return _debba
}

// GetOptimizer returns current PDF optimizer.
func (_bfebc *PdfWriter) GetOptimizer() Optimizer { return _bfebc._bgagb }

func (_aeaec *LTV) enable(_efbbcc, _bfcac []*_ed.Certificate, _acdb string) error {
	_eafce, _gaff, _cegg := _aeaec.buildCertChain(_efbbcc, _bfcac)
	if _cegg != nil {
		return _cegg
	}
	_aecd, _cegg := _aeaec.getCerts(_eafce)
	if _cegg != nil {
		return _cegg
	}
	var _dgbec, _dbcgaa [][]byte
	if _aeaec.OCSPClient != nil {
		_dgbec, _cegg = _aeaec.getOCSPs(_eafce, _gaff)
		if _cegg != nil {
			return _cegg
		}
	}
	if _aeaec.CRLClient != nil {
		_dbcgaa, _cegg = _aeaec.getCRLs(_eafce)
		if _cegg != nil {
			return _cegg
		}
	}
	_cbagd := _aeaec._dfcg
	_gagfe, _cegg := _cbagd.AddCerts(_aecd)
	if _cegg != nil {
		return _cegg
	}
	_agcac, _cegg := _cbagd.AddOCSPs(_dgbec)
	if _cegg != nil {
		return _cegg
	}
	_bbfcg, _cegg := _cbagd.AddCRLs(_dbcgaa)
	if _cegg != nil {
		return _cegg
	}
	if _acdb != "" {
		_cbagd.VRI[_acdb] = &VRI{Cert: _gagfe, OCSP: _agcac, CRL: _bbfcg}
	}
	_aeaec._cdad.SetDSS(_cbagd)
	return nil
}

func _fdgdb(_ebfee _df.PdfObject) (*PdfColorspaceSpecialPattern, error) {
	_bcd.Log.Trace("\u004e\u0065\u0077\u0020\u0050\u0061\u0074\u0074\u0065\u0072n\u0020\u0043\u0053\u0020\u0066\u0072\u006fm\u0020\u006f\u0062\u006a\u003a\u0020\u0025\u0073\u0020\u0025\u0054", _ebfee.String(), _ebfee)
	_bafce := NewPdfColorspaceSpecialPattern()
	if _egcab, _beebg := _ebfee.(*_df.PdfIndirectObject); _beebg {
		_bafce._gbee = _egcab
	}
	_ebfee = _df.TraceToDirectObject(_ebfee)
	if _aefbg, _efgde := _ebfee.(*_df.PdfObjectName); _efgde {
		if *_aefbg != "\u0050a\u0074\u0074\u0065\u0072\u006e" {
			return nil, _c.Errorf("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
		}
		return _bafce, nil
	}
	_eage, _dbba := _ebfee.(*_df.PdfObjectArray)
	if !_dbba {
		_bcd.Log.Error("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061t\u0074\u0065\u0072\u006e\u0020\u0043\u0053 \u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0023\u0076", _ebfee)
		return nil, _c.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0050\u0061\u0074\u0074e\u0072n\u0020C\u0053\u0020\u006f\u0062\u006a\u0065\u0063t")
	}
	if _eage.Len() != 1 && _eage.Len() != 2 {
		_bcd.Log.Error("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0043\u0053\u0020\u0061\u0072\u0072\u0061\u0079\u003a %\u0023\u0076", _eage)
		return nil, _c.Errorf("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065r\u006e\u0020\u0043\u0053\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_ebfee = _eage.Get(0)
	if _bbac, _fcce := _ebfee.(*_df.PdfObjectName); _fcce {
		if *_bbac != "\u0050a\u0074\u0074\u0065\u0072\u006e" {
			_bcd.Log.Error("\u0049\u006e\u0076al\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065\u0072n\u0020C\u0053 \u0061r\u0072\u0061\u0079\u0020\u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0023\u0076", _bbac)
			return nil, _c.Errorf("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
		}
	}
	if _eage.Len() > 1 {
		_ebfee = _eage.Get(1)
		_ebfee = _df.TraceToDirectObject(_ebfee)
		_bcaad, _gfbd := NewPdfColorspaceFromPdfObject(_ebfee)
		if _gfbd != nil {
			return nil, _gfbd
		}
		_bafce.UnderlyingCS = _bcaad
	}
	_bcd.Log.Trace("R\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0077i\u0074\u0068\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079in\u0067\u0020\u0063s\u003a \u0025\u0054", _bafce.UnderlyingCS)
	return _bafce, nil
}

// NewPdfShadingPatternType2 creates an empty shading pattern type 2 object.
func NewPdfShadingPatternType2() *PdfShadingPatternType2 {
	_fbeefg := &PdfShadingPatternType2{}
	_fbeefg.Matrix = _df.MakeArrayFromIntegers([]int{1, 0, 0, 1, 0, 0})
	_fbeefg.PdfPattern = &PdfPattern{}
	_fbeefg.PdfPattern.PatternType = int64(*_df.MakeInteger(2))
	_fbeefg.PdfPattern._ecfde = _fbeefg
	_fbeefg.PdfPattern._cbce = _df.MakeIndirectObject(_df.MakeDict())
	return _fbeefg
}

// OutlineItem represents a PDF outline item dictionary (Table 153 - pp. 376 - 377).
type OutlineItem struct {
	Title   string         `json:"title"`
	Dest    OutlineDest    `json:"dest"`
	Entries []*OutlineItem `json:"entries,omitempty"`
}

// StandardImplementer is an interface that defines specified PDF standards like PDF/A-1A (pdfa.Profile1A)
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
type StandardImplementer interface {
	StandardValidator
	StandardApplier

	// StandardName gets the human-readable name of the standard.
	StandardName() string
}

// AddExtGState adds a graphics state to the XObject resources.
func (_cgfad *PdfPage) AddExtGState(name _df.PdfObjectName, egs *_df.PdfObjectDictionary) error {
	if _cgfad.Resources == nil {
		_cgfad.Resources = NewPdfPageResources()
	}
	if _cgfad.Resources.ExtGState == nil {
		_cgfad.Resources.ExtGState = _df.MakeDict()
	}
	_cbcb, _eeac := _df.TraceToDirectObject(_cgfad.Resources.ExtGState).(*_df.PdfObjectDictionary)
	if !_eeac {
		_bcd.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0045\u0078t\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0064i\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a\u0020\u0025\u0076", _df.TraceToDirectObject(_cgfad.Resources.ExtGState))
		return _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_cbcb.Set(name, egs)
	return nil
}

// ReplaceAcroForm replaces the acrobat form. It appends a new form to the Pdf which
// replaces the original AcroForm.
func (_cgad *PdfAppender) ReplaceAcroForm(acroForm *PdfAcroForm) {
	if acroForm != nil {
		_cgad.updateObjectsDeep(acroForm.ToPdfObject(), nil)
	}
	_cgad._ffe = acroForm
}

// NewPdfReader returns a new PdfReader for an input io.ReadSeeker interface. Can be used to read PDF from
// memory or file. Immediately loads and traverses the PDF structure including pages and page contents (if
// not encrypted). Loads entire document structure into memory.
// Alternatively a lazy-loading reader can be created with NewPdfReaderLazy which loads only references,
// and references are loaded from disk into memory on an as-needed basis.
func NewPdfReader(rs _bdd.ReadSeeker) (*PdfReader, error) {
	const _acaec = "\u006do\u0064e\u006c\u003a\u004e\u0065\u0077P\u0064\u0066R\u0065\u0061\u0064\u0065\u0072"
	return _gafgf(rs, &ReaderOpts{}, false, _acaec)
}

// AddCRLs adds CRLs to DSS.
func (_egde *DSS) AddCRLs(crls [][]byte) ([]*_df.PdfObjectStream, error) {
	return _egde.add(&_egde.CRLs, _egde._fcba, crls)
}

// SetDate sets the `M` field of the signature.
func (_ccddbe *PdfSignature) SetDate(date _fa.Time, format string) {
	if format == "" {
		format = "\u0044\u003a\u003200\u0036\u0030\u0031\u0030\u0032\u0031\u0035\u0030\u0034\u0030\u0035\u002d\u0030\u0037\u0027\u0030\u0030\u0027"
	}
	_ccddbe.M = _df.MakeString(date.Format(format))
}

func _ebacbe(_geabd *[]*PdfField, _fdec FieldFilterFunc, _dbegc bool) []*PdfField {
	if _geabd == nil {
		return nil
	}
	_bbaa := *_geabd
	if len(*_geabd) == 0 {
		return nil
	}
	_gfbb := _bbaa[:0]
	if _fdec == nil {
		_fdec = func(*PdfField) bool { return true }
	}
	var _dcaad []*PdfField
	for _, _dafe := range _bbaa {
		_dffce := _fdec(_dafe)
		if _dffce {
			_dcaad = append(_dcaad, _dafe)
			if len(_dafe.Kids) > 0 {
				_dcaad = append(_dcaad, _ebacbe(&_dafe.Kids, _fdec, _dbegc)...)
			}
		}
		if !_dbegc || !_dffce || len(_dafe.Kids) > 0 {
			_gfbb = append(_gfbb, _dafe)
		}
	}
	*_geabd = _gfbb
	return _dcaad
}

func (_acceg *PdfWriter) copyObject(_egecg _df.PdfObject, _bdege map[_df.PdfObject]_df.PdfObject, _fcbga map[_df.PdfObject]struct{}, _gfbf bool) _df.PdfObject {
	_ccabe := !_acceg._gebfg && _fcbga != nil
	if _aeebbb, _cdcga := _bdege[_egecg]; _cdcga {
		if _ccabe && !_gfbf {
			delete(_fcbga, _egecg)
		}
		return _aeebbb
	}
	if _egecg == nil {
		_bafff := _df.MakeNull()
		return _bafff
	}
	_cedfb := _egecg
	switch _beeee := _egecg.(type) {
	case *_df.PdfObjectArray:
		_cfdbg := _df.MakeArray()
		_cedfb = _cfdbg
		_bdege[_egecg] = _cedfb
		for _, _cfgca := range _beeee.Elements() {
			_cfdbg.Append(_acceg.copyObject(_cfgca, _bdege, _fcbga, _gfbf))
		}
	case *_df.PdfObjectStreams:
		_begdc := &_df.PdfObjectStreams{PdfObjectReference: _beeee.PdfObjectReference}
		_cedfb = _begdc
		_bdege[_egecg] = _cedfb
		for _, _eceba := range _beeee.Elements() {
			_begdc.Append(_acceg.copyObject(_eceba, _bdege, _fcbga, _gfbf))
		}
	case *_df.PdfObjectStream:
		_ffaeba := &_df.PdfObjectStream{Stream: _beeee.Stream, PdfObjectReference: _beeee.PdfObjectReference, Lazy: _beeee.Lazy, TempFile: _beeee.TempFile}
		_cedfb = _ffaeba
		_bdege[_egecg] = _cedfb
		_ffaeba.PdfObjectDictionary = _acceg.copyObject(_beeee.PdfObjectDictionary, _bdege, _fcbga, _gfbf).(*_df.PdfObjectDictionary)
	case *_df.PdfObjectDictionary:
		var _gcfcfc bool
		if _ccabe && !_gfbf {
			if _cdddg, _ := _df.GetNameVal(_beeee.Get("\u0054\u0079\u0070\u0065")); _cdddg == "\u0050\u0061\u0067\u0065" {
				_, _faegce := _acceg._fddef[_beeee]
				_gfbf = !_faegce
				_gcfcfc = _gfbf
			}
		}
		_cgfdb := _df.MakeDict()
		_cedfb = _cgfdb
		_bdege[_egecg] = _cedfb
		for _, _begfd := range _beeee.Keys() {
			_cgfdb.Set(_begfd, _acceg.copyObject(_beeee.Get(_begfd), _bdege, _fcbga, _gfbf))
		}
		if _gcfcfc {
			_cedfb = _df.MakeNull()
			_gfbf = false
		}
	case *_df.PdfIndirectObject:
		_agebge := &_df.PdfIndirectObject{PdfObjectReference: _beeee.PdfObjectReference}
		_cedfb = _agebge
		_bdege[_egecg] = _cedfb
		_agebge.PdfObject = _acceg.copyObject(_beeee.PdfObject, _bdege, _fcbga, _gfbf)
	case *_df.PdfObjectString:
		_efdaa := *_beeee
		_cedfb = &_efdaa
		_bdege[_egecg] = _cedfb
	case *_df.PdfObjectName:
		_dfgdd := *_beeee
		_cedfb = &_dfgdd
		_bdege[_egecg] = _cedfb
	case *_df.PdfObjectNull:
		_cedfb = _df.MakeNull()
		_bdege[_egecg] = _cedfb
	case *_df.PdfObjectInteger:
		_baedf := *_beeee
		_cedfb = &_baedf
		_bdege[_egecg] = _cedfb
	case *_df.PdfObjectReference:
		_dcgge := *_beeee
		_cedfb = &_dcgge
		_bdege[_egecg] = _cedfb
	case *_df.PdfObjectFloat:
		_abadd := *_beeee
		_cedfb = &_abadd
		_bdege[_egecg] = _cedfb
	case *_df.PdfObjectBool:
		_ebfgc := *_beeee
		_cedfb = &_ebfgc
		_bdege[_egecg] = _cedfb
	case *pdfSignDictionary:
		_bgfce := &pdfSignDictionary{PdfObjectDictionary: _df.MakeDict(), _dabb: _beeee._dabb, _gbbba: _beeee._gbbba}
		_cedfb = _bgfce
		_bdege[_egecg] = _cedfb
		for _, _edffda := range _beeee.Keys() {
			_bgfce.Set(_edffda, _acceg.copyObject(_beeee.Get(_edffda), _bdege, _fcbga, _gfbf))
		}
	default:
		_bcd.Log.Info("\u0054\u004f\u0044\u004f\u0028\u0061\u0035\u0069\u0029\u003a\u0020\u0069\u006dp\u006c\u0065\u006d\u0065\u006e\u0074 \u0063\u006f\u0070\u0079\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0066\u006fr\u0020\u0025\u002b\u0076", _egecg)
	}
	if _ccabe && _gfbf {
		_fcbga[_egecg] = struct{}{}
	}
	return _cedfb
}

// Inspect inspects the object types, subtypes and content in the PDF file returning a map of
// object type to number of instances of each.
func (_cbdd *PdfReader) Inspect() (map[string]int, error) { return _cbdd._gfdaag.Inspect() }

// SetXObjectByName adds the XObject from the passed in stream to the page resources.
// The added XObject is identified by the specified name.
func (_gbfge *PdfPageResources) SetXObjectByName(keyName _df.PdfObjectName, stream *_df.PdfObjectStream) error {
	if _gbfge.XObject == nil {
		_gbfge.XObject = _df.MakeDict()
	}
	_bccb := _df.TraceToDirectObject(_gbfge.XObject)
	_aggfa, _aebfb := _bccb.(*_df.PdfObjectDictionary)
	if !_aebfb {
		_bcd.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0058\u004f\u0062j\u0065\u0063\u0074\u002c\u0020\u0067\u006f\u0074\u0020\u0025T\u002f\u0025\u0054", _gbfge.XObject, _bccb)
		return _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_aggfa.Set(keyName, stream)
	return nil
}

// SetNameDictionary sets the Names entry in the PDF catalog.
// See section 7.7.4 "Name Dictionary" (p. 80 PDF32000_2008).
func (_ebgff *PdfWriter) SetNameDictionary(names _df.PdfObject) error {
	if names == nil {
		return nil
	}
	_ebgff._adadc = _fcgd(names)
	_bcd.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006co\u0067\u0020\u004e\u0061\u006d\u0065\u0073\u002e\u002e\u002e")
	_ebgff._gdee.Set("\u004e\u0061\u006de\u0073", names)
	return _ebgff.addObjects(names)
}

// CharMetrics represents width and height metrics of a glyph.
type CharMetrics = _da.CharMetrics

// ColorToRGB only converts color used with uncolored patterns (defined in underlying colorspace).  Does not go into the
// pattern objects and convert those.  If that is desired, needs to be done separately.  See for example
// grayscale conversion example in unidoc-examples repo.
func (_dbdc *PdfColorspaceSpecialPattern) ColorToRGB(color PdfColor) (PdfColor, error) {
	_cdcb, _afdb := color.(*PdfColorPattern)
	if !_afdb {
		_bcd.Log.Debug("\u0043\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0070a\u0074\u0074\u0065\u0072\u006e\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", color)
		return nil, ErrTypeCheck
	}
	if _cdcb.Color == nil {
		return color, nil
	}
	if _dbdc.UnderlyingCS == nil {
		return nil, _deb.New("\u0075n\u0064\u0065\u0072\u006cy\u0069\u006e\u0067\u0020\u0043S\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d")
	}
	return _dbdc.UnderlyingCS.ColorToRGB(_cdcb.Color)
}

func (_ecdd *PdfAppender) addNewObject(_bfef _df.PdfObject) {
	if _, _abfb := _ecdd._gceg[_bfef]; !_abfb {
		_ecdd._eaad = append(_ecdd._eaad, _bfef)
		_ecdd._gceg[_bfef] = struct{}{}
	}
}

// GetContainingPdfObject implements interface PdfModel.
func (_gbfbdc *Permissions) GetContainingPdfObject() _df.PdfObject { return _gbfbdc._abddf }

// ViewClip returns the value of the viewClip.
func (_dagg *ViewerPreferences) ViewClip() PageBoundary { return _dagg._geabe }

// RepairAcroForm attempts to rebuild the AcroForm fields using the widget
// annotations present in the document pages. Pass nil for the opts parameter
// in order to use the default options.
// NOTE: Currently, the opts parameter is declared in order to enable adding
// future options, but passing nil will always result in the default options
// being used.
func (_ffeeg *PdfReader) RepairAcroForm(opts *AcroFormRepairOptions) error {
	var _eedfc []*PdfField
	_bceaag := map[*_df.PdfIndirectObject]struct{}{}
	for _, _fedfb := range _ffeeg.PageList {
		_dacfaf, _acgba := _fedfb.GetAnnotations()
		if _acgba != nil {
			return _acgba
		}
		for _, _dfffb := range _dacfaf {
			var _ecaeb *PdfField
			switch _bcfdg := _dfffb.GetContext().(type) {
			case *PdfAnnotationWidget:
				if _bcfdg._aeaf != nil {
					_ecaeb = _bcfdg._aeaf
					break
				}
				if _cfcbb, _deacbf := _df.GetIndirect(_bcfdg.Parent); _deacbf {
					_ecaeb, _acgba = _ffeeg.newPdfFieldFromIndirectObject(_cfcbb, nil)
					if _acgba == nil {
						break
					}
					_bcd.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072s\u0065\u0020\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065ld\u0020\u0025\u002bv\u003a \u0025\u0076", _cfcbb, _acgba)
				}
				if _bcfdg._bfde != nil {
					_ecaeb, _acgba = _ffeeg.newPdfFieldFromIndirectObject(_bcfdg._bfde, nil)
					if _acgba == nil {
						break
					}
					_bcd.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072s\u0065\u0020\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065ld\u0020\u0025\u002bv\u003a \u0025\u0076", _bcfdg._bfde, _acgba)
				}
			}
			if _ecaeb == nil {
				continue
			}
			if _, _bacdc := _bceaag[_ecaeb._cdbc]; _bacdc {
				continue
			}
			_bceaag[_ecaeb._cdbc] = struct{}{}
			_eedfc = append(_eedfc, _ecaeb)
		}
	}
	if len(_eedfc) == 0 {
		return nil
	}
	if _ffeeg.AcroForm == nil {
		_ffeeg.AcroForm = NewPdfAcroForm()
	}
	_ffeeg.AcroForm.Fields = &_eedfc
	return nil
}

// NewKValue creates a new K value object.
func NewKValue() *KValue { return &KValue{} }

// ImageToRGB converts ICCBased colorspace image to RGB and returns the result.
func (_dedc *PdfColorspaceICCBased) ImageToRGB(img Image) (Image, error) {
	if _dedc.Alternate == nil {
		_bcd.Log.Debug("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		if _dedc.N == 1 {
			_bcd.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061y\u0020\u0028\u004e\u003d\u0031\u0029")
			_efce := NewPdfColorspaceDeviceGray()
			return _efce.ImageToRGB(img)
		} else if _dedc.N == 3 {
			_bcd.Log.Debug("\u0049\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006eg\u0020\u0044\u0065\u0076\u0069\u0063e\u0052\u0047B\u0020\u0028N\u003d3\u0029")
			return img, nil
		} else if _dedc.N == 4 {
			_bcd.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059K\u0020\u0028\u004e\u003d\u0034\u0029")
			_bddgc := NewPdfColorspaceDeviceCMYK()
			return _bddgc.ImageToRGB(img)
		} else {
			return img, _deb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	_bcd.Log.Trace("\u0049\u0043\u0043 \u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0069\u0076\u0065\u003a\u0020\u0025\u0023\u0076", _dedc)
	_aefb, _gfce := _dedc.Alternate.ImageToRGB(img)
	_bcd.Log.Trace("I\u0043C\u0020\u0049\u006e\u0070\u0075\u0074\u0020\u0069m\u0061\u0067\u0065\u003a %\u002b\u0076", img)
	_bcd.Log.Trace("I\u0043\u0043\u0020\u004fut\u0070u\u0074\u0020\u0069\u006d\u0061g\u0065\u003a\u0020\u0025\u002b\u0076", _aefb)
	return _aefb, _gfce
}

// PdfAnnotationMovie represents Movie annotations.
// (Section 12.5.6.17).
type PdfAnnotationMovie struct {
	*PdfAnnotation
	T     _df.PdfObject
	Movie _df.PdfObject
	A     _df.PdfObject
}

// NewStandard14FontWithEncoding returns the standard 14 font named `basefont` as a *PdfFont and
// a TextEncoder that encodes all the runes in `alphabet`, or an error if this is not possible.
// An error can occur if `basefont` is not one the standard 14 font names.
func NewStandard14FontWithEncoding(basefont StdFontName, alphabet map[rune]int) (*PdfFont, _abg.SimpleEncoder, error) {
	_cebd, _daddf := _aedd(basefont)
	if _daddf != nil {
		return nil, nil, _daddf
	}
	_accge, _fbbb := _cebd.Encoder().(_abg.SimpleEncoder)
	if !_fbbb {
		return nil, nil, _c.Errorf("\u006f\u006e\u006c\u0079\u0020s\u0069\u006d\u0070\u006c\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u0073\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u002c\u0020\u0067\u006f\u0074\u0020\u0025\u0054", _cebd.Encoder())
	}
	_ddeg := make(map[rune]_abg.GlyphName)
	for _cfdba := range alphabet {
		if _, _dgeff := _accge.RuneToCharcode(_cfdba); !_dgeff {
			_, _ffcfda := _cebd._aeeed.Read(_cfdba)
			if !_ffcfda {
				_bcd.Log.Trace("r\u0075\u006e\u0065\u0020\u0025\u0023x\u003d\u0025\u0071\u0020\u006e\u006f\u0074\u0020\u0069n\u0020\u0074\u0068e\u0020f\u006f\u006e\u0074", _cfdba, _cfdba)
				continue
			}
			_gcbbc, _ffcfda := _abg.RuneToGlyph(_cfdba)
			if !_ffcfda {
				_bcd.Log.Debug("\u006eo\u0020\u0067\u006c\u0079\u0070\u0068\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u0020\u0025\u0023\u0078\u003d\u0025\u0071", _cfdba, _cfdba)
				continue
			}
			if len(_ddeg) >= 255 {
				return nil, nil, _deb.New("\u0074\u006f\u006f\u0020\u006d\u0061\u006e\u0079\u0020\u0063\u0068\u0061\u0072a\u0063\u0074\u0065\u0072\u0073\u0020f\u006f\u0072\u0020\u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067")
			}
			_ddeg[_cfdba] = _gcbbc
		}
	}
	var (
		_deaac  []_abg.CharCode
		_gedcge []_abg.CharCode
	)
	for _gbge := _abg.CharCode(1); _gbge <= 0xff; _gbge++ {
		_face, _cdeff := _accge.CharcodeToRune(_gbge)
		if !_cdeff {
			_deaac = append(_deaac, _gbge)
			continue
		}
		if _, _cdeff = alphabet[_face]; !_cdeff {
			_gedcge = append(_gedcge, _gbge)
		}
	}
	_cbef := append(_deaac, _gedcge...)
	if len(_cbef) < len(_ddeg) {
		return nil, nil, _c.Errorf("n\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0065\u006ec\u006f\u0064\u0065\u0020\u0025\u0064\u0020ru\u006e\u0065\u0073\u002c \u0062\u0075\u0074\u0020\u0068\u0061\u0076\u0065\u0020on\u006c\u0079 \u0025\u0064\u0020\u0073\u006c\u006f\u0074\u0073", len(_ddeg), len(_cbef))
	}
	_dggf := make([]rune, 0, len(_ddeg))
	for _ebace := range _ddeg {
		_dggf = append(_dggf, _ebace)
	}
	_f.Slice(_dggf, func(_cfcfg, _fafeg int) bool { return _dggf[_cfcfg] < _dggf[_fafeg] })
	_facb := make(map[_abg.CharCode]_abg.GlyphName, len(_dggf))
	for _, _bcegf := range _dggf {
		_gbbdb := _cbef[0]
		_cbef = _cbef[1:]
		_facb[_gbbdb] = _ddeg[_bcegf]
	}
	_accge = _abg.ApplyDifferences(_accge, _facb)
	_cebd.SetEncoder(_accge)
	return &PdfFont{_eaeg: &_cebd}, _accge, nil
}

// PdfShadingPattern is a Shading patterns that provide a smooth transition between colors across an area to be painted,
// i.e. color(x,y) = f(x,y) at each point.
// It is a type 2 pattern (PatternType = 2).
type PdfShadingPattern struct {
	*PdfPattern
	Shading   *PdfShading
	Matrix    *_df.PdfObjectArray
	ExtGState _df.PdfObject
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_dfee *PdfShadingType7) ToPdfObject() _df.PdfObject {
	_dfee.PdfShading.ToPdfObject()
	_fcgg, _ffegc := _dfee.getShadingDict()
	if _ffegc != nil {
		_bcd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _dfee.BitsPerCoordinate != nil {
		_fcgg.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _dfee.BitsPerCoordinate)
	}
	if _dfee.BitsPerComponent != nil {
		_fcgg.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _dfee.BitsPerComponent)
	}
	if _dfee.BitsPerFlag != nil {
		_fcgg.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _dfee.BitsPerFlag)
	}
	if _dfee.Decode != nil {
		_fcgg.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _dfee.Decode)
	}
	if _dfee.Function != nil {
		if len(_dfee.Function) == 1 {
			_fcgg.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _dfee.Function[0].ToPdfObject())
		} else {
			_caaf := _df.MakeArray()
			for _, _efbac := range _dfee.Function {
				_caaf.Append(_efbac.ToPdfObject())
			}
			_fcgg.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _caaf)
		}
	}
	return _dfee._bgdag
}

// GetCatalogViewerPreferences gets catalog ViewerPreferences object.
func (_ddbeg *PdfReader) GetCatalogViewerPreferences() (_df.PdfObject, bool) {
	if _ddbeg._afbaf == nil {
		return nil, false
	}
	_cacce := _ddbeg._afbaf.Get("\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073")
	return _cacce, _cacce != nil
}

// SetTabOrder sets the tab order for the page.
func (_geeaf *PdfPage) SetTabOrder(order TabOrderType) {
	_geeaf.Tabs = _df.MakeName(string(order))
}

// SetColorSpace sets `r` colorspace object to `colorspace`.
func (_bfcg *PdfPageResources) SetColorSpace(colorspace *PdfPageResourcesColorspaces) {
	_bfcg._eafae = colorspace
}

// PdfAnnotationUnderline represents Underline annotations.
// (Section 12.5.6.10).
type PdfAnnotationUnderline struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _df.PdfObject
}

// PdfFieldChoice represents a choice field which includes scrollable list boxes and combo boxes.
type PdfFieldChoice struct {
	*PdfField
	Opt *_df.PdfObjectArray
	TI  *_df.PdfObjectInteger
	I   *_df.PdfObjectArray
}

// GetShadingByName gets the shading specified by keyName. Returns nil if not existing.
// The bool flag indicated whether it was found or not.
func (_dcabg *PdfPageResources) GetShadingByName(keyName _df.PdfObjectName) (*PdfShading, bool) {
	if _dcabg.Shading == nil {
		return nil, false
	}
	_ddaag, _dfggb := _df.TraceToDirectObject(_dcabg.Shading).(*_df.PdfObjectDictionary)
	if !_dfggb {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0068\u0061d\u0069\u006e\u0067\u0020\u0065\u006e\u0074r\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _dcabg.Shading)
		return nil, false
	}
	if _eecaa := _ddaag.Get(keyName); _eecaa != nil {
		_dbaff, _gfffe := _abfbgf(_eecaa)
		if _gfffe != nil {
			_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020f\u0061\u0069l\u0065\u0064\u0020\u0074\u006f\u0020\u006c\u006fa\u0064\u0020\u0070\u0064\u0066\u0020\u0073\u0068\u0061\u0064\u0069\u006eg\u003a\u0020\u0025\u0076", _gfffe)
			return nil, false
		}
		return _dbaff, true
	}
	return nil, false
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_fbadc pdfFontType3) GetRuneMetrics(r rune) (_da.CharMetrics, bool) {
	_fgefce := _fbadc.Encoder()
	if _fgefce == nil {
		_bcd.Log.Debug("\u004e\u006f\u0020en\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0073\u003d\u0025\u0073", _fbadc)
		return _da.CharMetrics{}, false
	}
	_dbfeb, _dfebc := _fgefce.RuneToCharcode(r)
	if !_dfebc {
		if r != ' ' {
			_bcd.Log.Trace("\u004e\u006f\u0020c\u0068\u0061\u0072\u0063o\u0064\u0065\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u003d\u0025\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", r, _fbadc)
		}
		return _da.CharMetrics{}, false
	}
	_cdebc, _efbc := _fbadc.GetCharMetrics(_dbfeb)
	return _cdebc, _efbc
}

// SetPdfKeywords sets the Keywords attribute of the output PDF.
func SetPdfKeywords(keywords string) { _gcdec.Lock(); defer _gcdec.Unlock(); _dabbc = keywords }

// SetAnnotations sets the annotations list.
func (_ceafg *PdfPage) SetAnnotations(annotations []*PdfAnnotation) { _ceafg._adef = annotations }

// Write writes out the PDF.
func (_becg *PdfWriter) Write(writer _bdd.Writer) error {
	_bcd.Log.Trace("\u0057r\u0069\u0074\u0065\u0028\u0029")
	if _adddeb, _fdebaf := writer.(*_bf.File); _fdebaf {
		_becg.SetFileName(_adddeb.Name())
	}
	//_dcdfa := _becg.checkLicense()
	//if _dcdfa != nil {
	//	return _dcdfa
	//}
	var _dcdfa error
	if _dcdfa = _becg.writeOutlines(); _dcdfa != nil {
		return _dcdfa
	}
	if _dcdfa = _becg.writeAcroFormFields(); _dcdfa != nil {
		return _dcdfa
	}
	if _dcdfa = _becg.writeNamesDictionary(); _dcdfa != nil {
		return _dcdfa
	}
	_becg.checkPendingObjects()
	if _dcdfa = _becg.writeOutputIntents(); _dcdfa != nil {
		return _dcdfa
	}
	_becg.setCatalogVersion()
	_becg.copyObjects()
	if _dcdfa = _becg.optimize(); _dcdfa != nil {
		return _dcdfa
	}
	if _dcdfa = _becg.optimizeDocument(); _dcdfa != nil {
		return _dcdfa
	}
	var _agbda _gg.Hash
	if _becg._aeebe {
		_agbda = _af.New()
		writer = _bdd.MultiWriter(_agbda, writer)
	}
	_becg.setWriter(writer)
	_fccaf := _becg.checkCrossReferenceStream()
	_ccccb, _fccaf := _becg.mapObjectStreams(_fccaf)
	_becg.adjustXRefAffectedVersion(_fccaf)
	_becg.writeDocumentVersion()
	_becg.updateObjectNumbers()
	_becg.writeObjects()
	if _dcdfa = _becg.writeObjectsInStreams(_ccccb); _dcdfa != nil {
		return _dcdfa
	}
	_faafb := _becg._afeab
	var _fedcd int
	for _aebggc := range _becg._cdgd {
		if _aebggc > _fedcd {
			_fedcd = _aebggc
		}
	}
	if _becg._aeebe {
		if _dcdfa = _becg.setHashIDs(_agbda); _dcdfa != nil {
			return _dcdfa
		}
	}
	if _fccaf {
		if _dcdfa = _becg.writeXRefStreams(_fedcd, _faafb); _dcdfa != nil {
			return _dcdfa
		}
	} else {
		_becg.writeTrailer(_fedcd)
	}
	_becg.makeOffSetReference(_faafb)
	if _dcdfa = _becg.flushWriter(); _dcdfa != nil {
		return _dcdfa
	}
	return nil
}

// NewXObjectImageFromImageLazy creates a new XObject Image from an image object
// with default options. If encoder is nil, uses raw encoding (none).
// If lazy is true, then lazy mode is enabled for XObject.
// Lazy mode allows to reduce memory usage with the help of temporary files.
func NewXObjectImageFromImageLazy(img *Image, cs PdfColorspace, encoder _df.StreamEncoder, lazy bool) (*XObjectImage, error) {
	_edgee := NewXObjectImage()
	if lazy {
		_febff, _cfac := UpdateXObjectImageFromImage(_edgee, img, cs, encoder)
		if _cfac != nil {
			return nil, _cfac
		}
		_febff.ToPdfObject()
		_cfac = _febff._fgdgd.MakeLazy()
		if _cfac != nil {
			return nil, _cfac
		}
		_febff.Stream = nil
		return _febff, nil
	}
	return UpdateXObjectImageFromImage(_edgee, img, cs, encoder)
}

// ToPdfObject implements interface PdfModel.
func (_dafb *PdfFilespec) ToPdfObject() _df.PdfObject {
	_cddd := _dafb.getDict()
	_cddd.Clear()
	_cddd.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0046\u0069\u006c\u0065\u0073\u0070\u0065\u0063"))
	_cddd.SetIfNotNil("\u0046\u0053", _dafb.FS)
	_cddd.SetIfNotNil("\u0046", _dafb.F)
	_cddd.SetIfNotNil("\u0055\u0046", _dafb.UF)
	_cddd.SetIfNotNil("\u0044\u004f\u0053", _dafb.DOS)
	_cddd.SetIfNotNil("\u004d\u0061\u0063", _dafb.Mac)
	_cddd.SetIfNotNil("\u0055\u006e\u0069\u0078", _dafb.Unix)
	_cddd.SetIfNotNil("\u0049\u0044", _dafb.ID)
	_cddd.SetIfNotNil("\u0056", _dafb.V)
	_cddd.SetIfNotNil("\u0045\u0046", _dafb.EF)
	_cddd.SetIfNotNil("\u0052\u0046", _dafb.RF)
	_cddd.SetIfNotNil("\u0044\u0065\u0073\u0063", _dafb.Desc)
	_cddd.SetIfNotNil("\u0043\u0049", _dafb.CI)
	_cddd.SetIfNotNil("\u0041\u0046\u0052\u0065\u006c\u0061\u0074\u0069\u006fn\u0073\u0068\u0069\u0070", _dafb.AFRelationship)
	return _dafb._gaafd
}

func (_edbbd *pdfFontType0) bytesToCharcodes(_afbba []byte) ([]_abg.CharCode, bool) {
	if _edbbd._eabf == nil {
		return nil, false
	}
	_aaef, _gbfa := _edbbd._eabf.BytesToCharcodes(_afbba)
	if !_gbfa {
		return nil, false
	}
	_dcdc := make([]_abg.CharCode, len(_aaef))
	for _fgeef, _edgdg := range _aaef {
		_dcdc[_fgeef] = _abg.CharCode(_edgdg)
	}
	return _dcdc, true
}

// NewDSS returns a new DSS dictionary.
func NewDSS() *DSS {
	return &DSS{_dbdf: _df.MakeIndirectObject(_df.MakeDict()), VRI: map[string]*VRI{}}
}

// NewPdfAnnotationPopup returns a new popup annotation.
func NewPdfAnnotationPopup() *PdfAnnotationPopup {
	_ceaf := NewPdfAnnotation()
	_cgc := &PdfAnnotationPopup{}
	_cgc.PdfAnnotation = _ceaf
	_ceaf.SetContext(_cgc)
	return _cgc
}

// Decrypt decrypts the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful,
// false otherwise.
func (_bfggc *PdfReader) Decrypt(password []byte) (bool, error) {
	_fcfc, _agdga := _bfggc._gfdaag.Decrypt(password)
	if _agdga != nil {
		return false, _agdga
	}
	if !_fcfc {
		return false, nil
	}
	_agdga = _bfggc.loadStructure()
	if _agdga != nil {
		_bcd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f \u006co\u0061d\u0020s\u0074\u0072\u0075\u0063\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029", _agdga)
		return false, _agdga
	}
	return true, nil
}

const (
	_cfef  = 0x00001
	_aceca = 0x00002
	_gfbe  = 0x00004
	_feee  = 0x00008
	_fgdde = 0x00020
	_aacc  = 0x00040
	_bbfdb = 0x10000
	_dffea = 0x20000
	_ffgee = 0x40000
)

// NewPdfReaderWithOpts creates a new PdfReader for an input io.ReadSeeker interface
// with a ReaderOpts.
// If ReaderOpts is nil it will be set to default value from NewReaderOpts.
func NewPdfReaderWithOpts(rs _bdd.ReadSeeker, opts *ReaderOpts) (*PdfReader, error) {
	const _bcdff = "\u006d\u006f\u0064\u0065\u006c\u003a\u004e\u0065\u0077\u0050\u0064f\u0052\u0065\u0061\u0064\u0065\u0072\u0057\u0069\u0074\u0068O\u0070\u0074\u0073"
	return _gafgf(rs, opts, true, _bcdff)
}

func (_aefa *PdfAcroForm) fillImageWithAppearance(_adbga FieldImageProvider, _ecde FieldAppearanceGenerator) error {
	if _aefa == nil {
		return nil
	}
	_ecced, _ebgd := _adbga.FieldImageValues()
	if _ebgd != nil {
		return _ebgd
	}
	for _, _ecbbc := range _aefa.AllFields() {
		_bfad := _ecbbc.PartialName()
		_fbed, _fcagb := _ecced[_bfad]
		if !_fcagb {
			if _cdcf, _bede := _ecbbc.FullName(); _bede == nil {
				_fbed, _fcagb = _ecced[_cdcf]
			}
		}
		if !_fcagb {
			_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020f\u006f\u0072\u006d \u0066\u0069\u0065l\u0064\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u0069n \u0074\u0068\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e", _bfad)
			continue
		}
		switch _fbag := _ecbbc.GetContext().(type) {
		case *PdfFieldButton:
			if _fbag.IsPush() {
				_fbag.SetFillImage(_fbed)
			}
		}
		if _ecde == nil {
			continue
		}
		for _, _ecgfb := range _ecbbc.Annotations {
			_ebdcd, _fggcb := _ecde.GenerateAppearanceDict(_aefa, _ecbbc, _ecgfb)
			if _fggcb != nil {
				return _fggcb
			}
			_ecgfb.AP = _ebdcd
			_ecgfb.ToPdfObject()
		}
	}
	return nil
}

// SetAction sets the PDF action for the annotation link.
func (_afd *PdfAnnotationLink) SetAction(action *PdfAction) {
	_afd._aefc = action
	if action == nil {
		_afd.A = nil
	}
}

// Direction represents the predominant reading order for text.
type Direction string

func _ebabc(_gcfcb *_df.PdfObjectDictionary) (*PdfShadingType2, error) {
	_bfdae := PdfShadingType2{}
	_cadbeg := _gcfcb.Get("\u0043\u006f\u006f\u0072\u0064\u0073")
	if _cadbeg == nil {
		_bcd.Log.Debug("R\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u003a\u0020\u0020\u0043\u006f\u006f\u0072d\u0073")
		return nil, ErrRequiredAttributeMissing
	}
	_cfgce, _gebcba := _cadbeg.(*_df.PdfObjectArray)
	if !_gebcba {
		_bcd.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _cadbeg)
		return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _cfgce.Len() != 4 {
		_bcd.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0034\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _cfgce.Len())
		return nil, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065")
	}
	_bfdae.Coords = _cfgce
	if _aebgc := _gcfcb.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _aebgc != nil {
		_aebgc = _df.TraceToDirectObject(_aebgc)
		_eeed, _febef := _aebgc.(*_df.PdfObjectArray)
		if !_febef {
			_bcd.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _aebgc)
			return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_bfdae.Domain = _eeed
	}
	_cadbeg = _gcfcb.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _cadbeg == nil {
		_bcd.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_bfdae.Function = []PdfFunction{}
	if _fbgcf, _bcbec := _cadbeg.(*_df.PdfObjectArray); _bcbec {
		for _, _ecfca := range _fbgcf.Elements() {
			_eaeca, _ffbge := _ddaac(_ecfca)
			if _ffbge != nil {
				_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _ffbge)
				return nil, _ffbge
			}
			_bfdae.Function = append(_bfdae.Function, _eaeca)
		}
	} else {
		_efcab, _bababd := _ddaac(_cadbeg)
		if _bababd != nil {
			_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _bababd)
			return nil, _bababd
		}
		_bfdae.Function = append(_bfdae.Function, _efcab)
	}
	if _efgc := _gcfcb.Get("\u0045\u0078\u0074\u0065\u006e\u0064"); _efgc != nil {
		_efgc = _df.TraceToDirectObject(_efgc)
		_faadgg, _bcaef := _efgc.(*_df.PdfObjectArray)
		if !_bcaef {
			_bcd.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _efgc)
			return nil, _df.ErrTypeError
		}
		if _faadgg.Len() != 2 {
			_bcd.Log.Debug("\u0045\u0078\u0074\u0065n\u0064\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _faadgg.Len())
			return nil, ErrInvalidAttribute
		}
		_bfdae.Extend = _faadgg
	}
	return &_bfdae, nil
}

func (_geae *PdfReader) newPdfAnnotationLinkFromDict(_gcg *_df.PdfObjectDictionary) (*PdfAnnotationLink, error) {
	_accb := PdfAnnotationLink{}
	_accb.A = _gcg.Get("\u0041")
	_accb.Dest = _gcg.Get("\u0044\u0065\u0073\u0074")
	_accb.H = _gcg.Get("\u0048")
	_accb.PA = _gcg.Get("\u0050\u0041")
	_accb.QuadPoints = _gcg.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	_accb.BS = _gcg.Get("\u0042\u0053")
	return &_accb, nil
}

// PageProcessCallback callback function used in page loading
// that could be used to modify the page content.
//
// If an error is returned, the `ToWriter` process would fail.
//
// This callback, if defined, will take precedence over `PageCallback` callback.
type PageProcessCallback func(_becba int, _bcca *PdfPage) error

// ToPdfObject implements interface PdfModel.
func (_caa *PdfActionImportData) ToPdfObject() _df.PdfObject {
	_caa.PdfAction.ToPdfObject()
	_fce := _caa._gcf
	_aea := _fce.PdfObject.(*_df.PdfObjectDictionary)
	_aea.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeImportData)))
	if _caa.F != nil {
		_aea.Set("\u0046", _caa.F.ToPdfObject())
	}
	return _fce
}

func (_daca *PdfReader) newPdfAnnotationPolygonFromDict(_dfecf *_df.PdfObjectDictionary) (*PdfAnnotationPolygon, error) {
	_bgdc := PdfAnnotationPolygon{}
	_gfa, _dabd := _daca.newPdfAnnotationMarkupFromDict(_dfecf)
	if _dabd != nil {
		return nil, _dabd
	}
	_bgdc.PdfAnnotationMarkup = _gfa
	_bgdc.Vertices = _dfecf.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073")
	_bgdc.LE = _dfecf.Get("\u004c\u0045")
	_bgdc.BS = _dfecf.Get("\u0042\u0053")
	_bgdc.IC = _dfecf.Get("\u0049\u0043")
	_bgdc.BE = _dfecf.Get("\u0042\u0045")
	_bgdc.IT = _dfecf.Get("\u0049\u0054")
	_bgdc.Measure = _dfecf.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	return &_bgdc, nil
}

// GetNumComponents returns the number of input color components, i.e. that are input to the tint transform.
func (_gcee *PdfColorspaceDeviceN) GetNumComponents() int { return _gcee.ColorantNames.Len() }

const (
	_ PdfOutputIntentType = iota
	PdfOutputIntentTypeA1
	PdfOutputIntentTypeA2
	PdfOutputIntentTypeA3
	PdfOutputIntentTypeA4
	PdfOutputIntentTypeX
)

// NewPdfAnnotationStamp returns a new stamp annotation.
func NewPdfAnnotationStamp() *PdfAnnotationStamp {
	_eaba := NewPdfAnnotation()
	_egc := &PdfAnnotationStamp{}
	_egc.PdfAnnotation = _eaba
	_egc.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_eaba.SetContext(_egc)
	return _egc
}

func (_bece *DSS) generateHashMap(_gddd []*_df.PdfObjectStream) (map[string]*_df.PdfObjectStream, error) {
	_aeea := map[string]*_df.PdfObjectStream{}
	for _, _bgecd := range _gddd {
		_deaff, _badd := _df.DecodeStream(_bgecd)
		if _badd != nil {
			return nil, _badd
		}
		_begf, _badd := _bgde(_deaff)
		if _badd != nil {
			return nil, _badd
		}
		_aeea[string(_begf)] = _bgecd
	}
	return _aeea, nil
}

// PdfAnnotationSound represents Sound annotations.
// (Section 12.5.6.16).
type PdfAnnotationSound struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Sound _df.PdfObject
	Name  _df.PdfObject
}

// NewOutline returns a new outline instance.
func NewOutline() *Outline { return &Outline{} }

func (_edeea *PdfPattern) getDict() *_df.PdfObjectDictionary {
	if _ddfeg, _ffgaa := _edeea._cbce.(*_df.PdfIndirectObject); _ffgaa {
		_caag, _fbbeg := _ddfeg.PdfObject.(*_df.PdfObjectDictionary)
		if !_fbbeg {
			return nil
		}
		return _caag
	} else if _acea, _effb := _edeea._cbce.(*_df.PdfObjectStream); _effb {
		return _acea.PdfObjectDictionary
	} else {
		_bcd.Log.Debug("\u0054r\u0079\u0069\u006e\u0067\u0020\u0074\u006f a\u0063\u0063\u0065\u0073\u0073\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020d\u0069\u0063t\u0069\u006f\u006ea\u0072\u0079\u0020\u006f\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062j\u0065\u0063t \u0074\u0079\u0070e\u0020\u0028\u0025\u0054\u0029", _edeea._cbce)
		return nil
	}
}

func (_bdcgg *pdfFontType3) getFontDescriptor() *PdfFontDescriptor { return _bdcgg._agggb }

func (_gcebea *PdfWriter) setHashIDs(_gcgfa _gg.Hash) error {
	_becbg := _gcgfa.Sum(nil)
	if _gcebea._aadde == "" {
		_gcebea._aadde = _ab.EncodeToString(_becbg[:8])
	}
	_gcebea.setDocumentIDs(_gcebea._aadde, _ab.EncodeToString(_becbg[8:]))
	return nil
}

// ToPdfObject returns the PDF representation of the function.
func (_ccbfc *PdfFunctionType2) ToPdfObject() _df.PdfObject {
	_feed := _df.MakeDict()
	_feed.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _df.MakeInteger(2))
	_ccegg := &_df.PdfObjectArray{}
	for _, _ddgge := range _ccbfc.Domain {
		_ccegg.Append(_df.MakeFloat(_ddgge))
	}
	_feed.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _ccegg)
	if _ccbfc.Range != nil {
		_bcgde := &_df.PdfObjectArray{}
		for _, _cegf := range _ccbfc.Range {
			_bcgde.Append(_df.MakeFloat(_cegf))
		}
		_feed.Set("\u0052\u0061\u006eg\u0065", _bcgde)
	}
	if _ccbfc.C0 != nil {
		_daga := &_df.PdfObjectArray{}
		for _, _fccee := range _ccbfc.C0 {
			_daga.Append(_df.MakeFloat(_fccee))
		}
		_feed.Set("\u0043\u0030", _daga)
	}
	if _ccbfc.C1 != nil {
		_ddaae := &_df.PdfObjectArray{}
		for _, _bebg := range _ccbfc.C1 {
			_ddaae.Append(_df.MakeFloat(_bebg))
		}
		_feed.Set("\u0043\u0031", _ddaae)
	}
	_feed.Set("\u004e", _df.MakeFloat(_ccbfc.N))
	if _ccbfc._fffb != nil {
		_ccbfc._fffb.PdfObject = _feed
		return _ccbfc._fffb
	}
	return _feed
}

// NewPdfAnnotationScreen returns a new screen annotation.
func NewPdfAnnotationScreen() *PdfAnnotationScreen {
	_bed := NewPdfAnnotation()
	_gab := &PdfAnnotationScreen{}
	_gab.PdfAnnotation = _bed
	_bed.SetContext(_gab)
	return _gab
}

// GetPreviousRevision returns the previous revision of PdfReader for the Pdf document
func (_eedbg *PdfReader) GetPreviousRevision() (*PdfReader, error) {
	if _eedbg._gfdaag.GetRevisionNumber() == 0 {
		return nil, _deb.New("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0065xi\u0073\u0074")
	}
	if _aeddb, _gdgdea := _eedbg._aefcd[_eedbg]; _gdgdea {
		return _aeddb, nil
	}
	_dfdba, _ebgbd := _eedbg._gfdaag.GetPreviousRevisionReadSeeker()
	if _ebgbd != nil {
		return nil, _ebgbd
	}
	_abfea, _ebgbd := _gafgf(_dfdba, _eedbg._cbcee, _eedbg._aeec, "\u006do\u0064\u0065\u006c\u003aG\u0065\u0074\u0050\u0072\u0065v\u0069o\u0075s\u0052\u0065\u0076\u0069\u0073\u0069\u006fn")
	if _ebgbd != nil {
		return nil, _ebgbd
	}
	_eedbg._cbga[_eedbg._gfdaag.GetRevisionNumber()-1] = _abfea
	_eedbg._aefcd[_eedbg] = _abfea
	_abfea._aefcd = _eedbg._aefcd
	return _abfea, nil
}

// SetBorderWidth sets the style's border width.
func (_abad *PdfBorderStyle) SetBorderWidth(width float64) { _abad.W = &width }

// AddChild adds a child object.
func (_gdcae *KDict) AddChild(kv *KValue) { _gdcae._dacfd = append(_gdcae._dacfd, kv) }

func _agbg(_gfgea *_bge.ImageBase) (_cbbee Image) {
	_cbbee.Width = int64(_gfgea.Width)
	_cbbee.Height = int64(_gfgea.Height)
	_cbbee.BitsPerComponent = int64(_gfgea.BitsPerComponent)
	_cbbee.ColorComponents = _gfgea.ColorComponents
	_cbbee.Data = _gfgea.Data
	_cbbee._bebgb = _gfgea.Decode
	_cbbee._gebab = _gfgea.Alpha
	return _cbbee
}

// GetContainingPdfObject returns the container of the PdfAcroForm (indirect object).
func (_ecag *PdfAcroForm) GetContainingPdfObject() _df.PdfObject { return _ecag._cffeg }

// ToPdfObject converts colorspace to a PDF object. [/Indexed base hival lookup]
func (_eeae *PdfColorspaceSpecialIndexed) ToPdfObject() _df.PdfObject {
	_ccce := _df.MakeArray(_df.MakeName("\u0049n\u0064\u0065\u0078\u0065\u0064"))
	_ccce.Append(_eeae.Base.ToPdfObject())
	_ccce.Append(_df.MakeInteger(int64(_eeae.HiVal)))
	_ccce.Append(_eeae.Lookup)
	if _eeae._bade != nil {
		_eeae._bade.PdfObject = _ccce
		return _eeae._bade
	}
	return _ccce
}

// SetPatternByName sets a pattern resource specified by keyName.
func (_dgbed *PdfPageResources) SetPatternByName(keyName _df.PdfObjectName, pattern _df.PdfObject) error {
	if _dgbed.Pattern == nil {
		_dgbed.Pattern = _df.MakeDict()
	}
	_aeaaa, _adffa := _df.GetDict(_dgbed.Pattern)
	if !_adffa {
		return _df.ErrTypeError
	}
	_aeaaa.Set(keyName, pattern)
	return nil
}

// PdfColorspaceDeviceRGB represents an RGB colorspace.
type PdfColorspaceDeviceRGB struct{}

// GetSamples converts the raw byte slice into samples which are stored in a uint32 bit array.
// Each sample is represented by BitsPerComponent consecutive bits in the raw data.
// NOTE: The method resamples the image byte data before returning the result and
// this could lead to high memory usage, especially on large images. It should
// be avoided, when possible. It is recommended to access the Data field of the
// image directly or use the ColorAt method to extract individual pixels.
func (_edgc *Image) GetSamples() []uint32 {
	_dfbd := _aff.ResampleBytes(_edgc.Data, int(_edgc.BitsPerComponent))
	if _edgc.BitsPerComponent < 8 {
		_dfbd = _edgc.samplesTrimPadding(_dfbd)
	}
	_ccgcb := int(_edgc.Width) * int(_edgc.Height) * _edgc.ColorComponents
	if len(_dfbd) < _ccgcb {
		_bcd.Log.Debug("\u0045r\u0072\u006fr\u003a\u0020\u0054o\u006f\u0020\u0066\u0065\u0077\u0020\u0073a\u006d\u0070\u006c\u0065\u0073\u0020(\u0067\u006f\u0074\u0020\u0025\u0064\u002c\u0020\u0065\u0078\u0070e\u0063\u0074\u0069\u006e\u0067\u0020\u0025\u0064\u0029", len(_dfbd), _ccgcb)
		return _dfbd
	} else if len(_dfbd) > _ccgcb {
		_bcd.Log.Debug("\u0045r\u0072\u006fr\u003a\u0020\u0054o\u006f\u0020\u006d\u0061\u006e\u0079\u0020s\u0061\u006d\u0070\u006c\u0065\u0073 \u0028\u0067\u006f\u0074\u0020\u0025\u0064\u002c\u0020\u0065\u0078p\u0065\u0063\u0074\u0069\u006e\u0067\u0020\u0025\u0064", len(_dfbd), _ccgcb)
		_dfbd = _dfbd[:_ccgcb]
	}
	return _dfbd
}

// Encoder returns the font's text encoder.
func (_ffgaf pdfFontType0) Encoder() _abg.TextEncoder { return _ffgaf._gdbg }

// SetPageNumber sets the page number.
func (_abade *KDict) SetPageNumber(pageNumber int64) { _abade._cabee = pageNumber }

// GetContext returns the annotation context which contains the specific type-dependent context.
// The context represents the subannotation.
func (_beg *PdfAnnotation) GetContext() PdfModel {
	if _beg == nil {
		return nil
	}
	return _beg._afaa
}

// PickTrayByPDFSize returns the value of the pickTrayByPDFSize flag.
func (_ffdda *ViewerPreferences) PickTrayByPDFSize() bool {
	if _ffdda._cgbe == nil {
		return false
	}
	return *_ffdda._cgbe
}

func (_gbccd *PdfWriter) setWriter(_fgcef _bdd.Writer) {
	_gbccd._afeab = _gbccd._bcfff
	_gbccd._cfddc = _dg.NewWriter(_fgcef)
}

// CustomKeys returns all custom info keys as list.
func (_gabb *PdfInfo) CustomKeys() []string {
	if _gabb._bcec == nil {
		return nil
	}
	_dbcce := make([]string, len(_gabb._bcec.Keys()))
	for _, _cfecgb := range _gabb._bcec.Keys() {
		_dbcce = append(_dbcce, _cfecgb.String())
	}
	return _dbcce
}

// PdfTilingPattern is a Tiling pattern that consists of repetitions of a pattern cell with defined intervals.
// It is a type 1 pattern. (PatternType = 1).
// A tiling pattern is represented by a stream object, where the stream content is
// a content stream that describes the pattern cell.
type PdfTilingPattern struct {
	*PdfPattern
	PaintType  *_df.PdfObjectInteger
	TilingType *_df.PdfObjectInteger
	BBox       *PdfRectangle
	XStep      *_df.PdfObjectFloat
	YStep      *_df.PdfObjectFloat
	Resources  *PdfPageResources
	Matrix     *_df.PdfObjectArray
}

// NewPdfColorspaceLab returns a new Lab colorspace object.
func NewPdfColorspaceLab() *PdfColorspaceLab {
	_eee := &PdfColorspaceLab{}
	_eee.BlackPoint = []float64{0.0, 0.0, 0.0}
	_eee.Range = []float64{-100, 100, -100, 100}
	return _eee
}

// SetColorspaceByName adds the provided colorspace to the page resources.
func (_deagee *PdfPageResources) SetColorspaceByName(keyName _df.PdfObjectName, cs PdfColorspace) error {
	_dgeef, _acecg := _deagee.GetColorspaces()
	if _acecg != nil {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _acecg)
		return _acecg
	}
	if _dgeef == nil {
		_dgeef = NewPdfPageResourcesColorspaces()
		_deagee.SetColorSpace(_dgeef)
	}
	_dgeef.Set(keyName, cs)
	return nil
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_adfda pdfCIDFontType2) GetRuneMetrics(r rune) (_da.CharMetrics, bool) {
	_ddfae, _dafdf := _adfda._dbcecg[r]
	if !_dafdf {
		_aacfa, _bffed := _df.GetInt(_adfda.DW)
		if !_bffed {
			return _da.CharMetrics{}, false
		}
		_ddfae = int(*_aacfa)
	}
	return _da.CharMetrics{Wx: float64(_ddfae)}, true
}

func (_gbc *PdfReader) newPdfAnnotationPrinterMarkFromDict(_gfgc *_df.PdfObjectDictionary) (*PdfAnnotationPrinterMark, error) {
	_ebe := PdfAnnotationPrinterMark{}
	_ebe.MN = _gfgc.Get("\u004d\u004e")
	return &_ebe, nil
}

func (_gdda *PdfWriter) seekByName(_dgfee _df.PdfObject, _cbcgg []string, _egeaa string) ([]_df.PdfObject, error) {
	_bcd.Log.Trace("\u0053\u0065\u0065\u006b\u0020\u0062\u0079\u0020\u006e\u0061\u006d\u0065.\u002e\u0020\u0025\u0054", _dgfee)
	var _cgafce []_df.PdfObject
	if _gadff, _bffedb := _dgfee.(*_df.PdfIndirectObject); _bffedb {
		return _gdda.seekByName(_gadff.PdfObject, _cbcgg, _egeaa)
	}
	if _deggg, _fgedd := _dgfee.(*_df.PdfObjectStream); _fgedd {
		return _gdda.seekByName(_deggg.PdfObjectDictionary, _cbcgg, _egeaa)
	}
	if _aadea, _acgda := _dgfee.(*_df.PdfObjectDictionary); _acgda {
		_bcd.Log.Trace("\u0044\u0069\u0063\u0074")
		for _, _ddebd := range _aadea.Keys() {
			_ccafg := _aadea.Get(_ddebd)
			if string(_ddebd) == _egeaa {
				_cgafce = append(_cgafce, _ccafg)
			}
			for _, _edebbb := range _cbcgg {
				if string(_ddebd) == _edebbb {
					_bcd.Log.Trace("\u0046\u006f\u006c\u006c\u006f\u0077\u0020\u006b\u0065\u0079\u0020\u0025\u0073", _edebbb)
					_abccd, _aadbfg := _gdda.seekByName(_ccafg, _cbcgg, _egeaa)
					if _aadbfg != nil {
						return _cgafce, _aadbfg
					}
					_cgafce = append(_cgafce, _abccd...)
					break
				}
			}
		}
		return _cgafce, nil
	}
	return _cgafce, nil
}

// NewPdfAnnotationPrinterMark returns a new printermark annotation.
func NewPdfAnnotationPrinterMark() *PdfAnnotationPrinterMark {
	_cbca := NewPdfAnnotation()
	_bgg := &PdfAnnotationPrinterMark{}
	_bgg.PdfAnnotation = _cbca
	_cbca.SetContext(_bgg)
	return _bgg
}

// PdfAction represents an action in PDF (section 12.6 p. 412).
type PdfAction struct {
	_aab PdfModel
	Type _df.PdfObject
	S    _df.PdfObject
	Next _df.PdfObject
	_gcf *_df.PdfIndirectObject
}

// NonFullScreenPageMode returns the value of the nonFullScreenPageMode.
func (_cfffg *ViewerPreferences) NonFullScreenPageMode() NonFullScreenPageMode { return _cfffg._ebbf }

// DecodeArray returns the range of color component values in DeviceGray colorspace.
func (_ebfeg *PdfColorspaceDeviceGray) DecodeArray() []float64 { return []float64{0, 1.0} }

// ToPdfObject implements interface PdfModel.
func (_fdc *PdfAnnotationFreeText) ToPdfObject() _df.PdfObject {
	_fdc.PdfAnnotation.ToPdfObject()
	_geaf := _fdc._bfde
	_gaeg := _geaf.PdfObject.(*_df.PdfObjectDictionary)
	_fdc.PdfAnnotationMarkup.appendToPdfDictionary(_gaeg)
	_gaeg.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0046\u0072\u0065\u0065\u0054\u0065\u0078\u0074"))
	_gaeg.SetIfNotNil("\u0044\u0041", _fdc.DA)
	_gaeg.SetIfNotNil("\u0051", _fdc.Q)
	_gaeg.SetIfNotNil("\u0052\u0043", _fdc.RC)
	_gaeg.SetIfNotNil("\u0044\u0053", _fdc.DS)
	_gaeg.SetIfNotNil("\u0043\u004c", _fdc.CL)
	_gaeg.SetIfNotNil("\u0049\u0054", _fdc.IT)
	_gaeg.SetIfNotNil("\u0042\u0045", _fdc.BE)
	_gaeg.SetIfNotNil("\u0052\u0044", _fdc.RD)
	_gaeg.SetIfNotNil("\u0042\u0053", _fdc.BS)
	_gaeg.SetIfNotNil("\u004c\u0045", _fdc.LE)
	return _geaf
}

// ViewerPreferences represents the viewer preferences of a PDF document.
type ViewerPreferences struct {
	_bbfdd   *bool
	_abebaec *bool
	_dbfebfg *bool
	_eadcd   *bool
	_agceg   *bool
	_bfggg   *bool
	_ebbf    NonFullScreenPageMode
	_cggbe   Direction
	_ffbad   PageBoundary
	_geabe   PageBoundary
	_fbede   PageBoundary
	_edeeb   PageBoundary
	_faefa   PrintScaling
	_aecfg   Duplex
	_cgbe    *bool
	_dafbb   []int
	_edded   int
}

func (_aacbcgg *PdfWriter) writeAcroFormFields() error {
	if _aacbcgg._cecbge == nil {
		return nil
	}
	_bcd.Log.Trace("\u0057r\u0069t\u0069\u006e\u0067\u0020\u0061c\u0072\u006f \u0066\u006f\u0072\u006d\u0073")
	_adgf := _aacbcgg._cecbge.ToPdfObject()
	_bcd.Log.Trace("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u003a\u0020\u0025\u002b\u0076", _adgf)
	_aacbcgg._gdee.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _adgf)
	_dbffg := _aacbcgg.addObjects(_adgf)
	if _dbffg != nil {
		return _dbffg
	}
	return nil
}

// ImageToRGB convert 1-component grayscale data to 3-component RGB.
func (_fedg *PdfColorspaceDeviceGray) ImageToRGB(img Image) (Image, error) {
	if img.ColorComponents != 1 {
		return img, _deb.New("\u0074\u0068e \u0070\u0072\u006fv\u0069\u0064\u0065\u0064 im\u0061ge\u0020\u0069\u0073\u0020\u006e\u006f\u0074 g\u0072\u0061\u0079\u0020\u0073\u0063\u0061l\u0065")
	}
	_edaa, _daced := _bge.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._gebab, img._bebgb)
	if _daced != nil {
		return img, _daced
	}
	_fgfb, _daced := _bge.NRGBAConverter.Convert(_edaa)
	if _daced != nil {
		return img, _daced
	}
	_ebaff := _agbg(_fgfb.Base())
	_bcd.Log.Trace("\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079\u0020\u002d>\u0020\u0052\u0047\u0042")
	_bcd.Log.Trace("s\u0061\u006d\u0070\u006c\u0065\u0073\u003a\u0020\u0025\u0076", img.Data)
	_bcd.Log.Trace("\u0052G\u0042 \u0073\u0061\u006d\u0070\u006c\u0065\u0073\u003a\u0020\u0025\u0076", _ebaff.Data)
	_bcd.Log.Trace("\u0025\u0076\u0020\u002d\u003e\u0020\u0025\u0076", img, _ebaff)
	return _ebaff, nil
}

// VRI represents a Validation-Related Information dictionary.
// The VRI dictionary contains validation data in the form of
// certificates, OCSP and CRL information, for a single signature.
// See ETSI TS 102 778-4 V1.1.1 for more information.
type VRI struct {
	Cert []*_df.PdfObjectStream
	OCSP []*_df.PdfObjectStream
	CRL  []*_df.PdfObjectStream
	TU   *_df.PdfObjectString
	TS   *_df.PdfObjectString
}

// ToInteger convert to an integer format.
func (_baaee *PdfColorDeviceRGB) ToInteger(bits int) [3]uint32 {
	_dfdfg := _faf.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_dfdfg * _baaee.R()), uint32(_dfdfg * _baaee.G()), uint32(_dfdfg * _baaee.B())}
}

// ToPdfObject return the CalGray colorspace as a PDF object (name dictionary).
func (_ecegg *PdfColorspaceCalGray) ToPdfObject() _df.PdfObject {
	_gedd := &_df.PdfObjectArray{}
	_gedd.Append(_df.MakeName("\u0043a\u006c\u0047\u0072\u0061\u0079"))
	_egdg := _df.MakeDict()
	if _ecegg.WhitePoint != nil {
		_egdg.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _df.MakeArray(_df.MakeFloat(_ecegg.WhitePoint[0]), _df.MakeFloat(_ecegg.WhitePoint[1]), _df.MakeFloat(_ecegg.WhitePoint[2])))
	} else {
		_bcd.Log.Error("\u0043\u0061\u006c\u0047\u0072\u0061\u0079\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006fi\u006e\u0074\u0020\u0028\u0052e\u0071\u0075i\u0072\u0065\u0064\u0029")
	}
	if _ecegg.BlackPoint != nil {
		_egdg.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _df.MakeArray(_df.MakeFloat(_ecegg.BlackPoint[0]), _df.MakeFloat(_ecegg.BlackPoint[1]), _df.MakeFloat(_ecegg.BlackPoint[2])))
	}
	_egdg.Set("\u0047\u0061\u006dm\u0061", _df.MakeFloat(_ecegg.Gamma))
	_gedd.Append(_egdg)
	if _ecegg._faadg != nil {
		_ecegg._faadg.PdfObject = _gedd
		return _ecegg._faadg
	}
	return _gedd
}

func (_febe *PdfPage) getParentResources() (*PdfPageResources, error) {
	_bcda := _febe.Parent
	for _bcda != nil {
		_ddcdg, _acgcg := _df.GetDict(_bcda)
		if !_acgcg {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020n\u006f\u0064\u0065")
			return nil, _deb.New("i\u006e\u0076\u0061\u006cid\u0020p\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
		}
		if _acdfe := _ddcdg.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _acdfe != nil {
			_eecdc, _fgged := _df.GetDict(_acdfe)
			if !_fgged {
				return nil, _deb.New("i\u006e\u0076\u0061\u006cid\u0020r\u0065\u0073\u006f\u0075\u0072c\u0065\u0020\u0064\u0069\u0063\u0074")
			}
			_gfade, _gacaa := NewPdfPageResourcesFromDict(_eecdc)
			if _gacaa != nil {
				return nil, _gacaa
			}
			return _gfade, nil
		}
		_bcda = _ddcdg.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return nil, nil
}

// SetPrintPageRange sets the value of the printPageRange.
func (_cafd *ViewerPreferences) SetPrintPageRange(printPageRange []int) {
	_cafd._dafbb = printPageRange
}

// DefaultImageHandler is the default implementation of the ImageHandler using the standard go library.
type DefaultImageHandler struct{}

func _gadaf(_fegbge _df.PdfObject) (*KDict, error) {
	_bbced := _df.ResolveReference(_fegbge)
	if _bbced == nil {
		return nil, _c.Errorf("\u004b \u006fb\u006a\u0065\u0063\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
	}
	_ggabed, _agaec := _df.GetDict(_bbced)
	if !_agaec {
		return nil, _c.Errorf("\u004b\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072\u0079")
	}
	_abcbc := &KDict{}
	if _gcgee := _ggabed.Get("\u0053"); _gcgee != nil {
		_abcbc.S = _gcgee
	}
	if _dfacg := _ggabed.Get("\u0050"); _dfacg != nil {
		_abcbc.P = _dfacg
	}
	if _bccaf := _ggabed.Get("\u0049\u0044"); _bccaf != nil {
		if _dfaed, _bgff := _df.GetString(_bccaf); _bgff {
			_abcbc.ID = _dfaed
		}
	}
	if _eebaac := _ggabed.Get("\u0050\u0067"); _eebaac != nil {
		_abcbc.Pg = _eebaac
	}
	if _ecdbdc := _ggabed.Get("\u004b"); _ecdbdc != nil {
		_abcbc.K = _ecdbdc
		switch _bgaacf := _ecdbdc.(type) {
		case *_df.PdfObjectArray:
			if _cbdbg, _bgegb := _df.GetArray(_ecdbdc); _bgegb {
				for _, _fegfec := range _cbdbg.Elements() {
					switch _bdfea := _fegfec.(type) {
					case *_df.PdfIndirectObject:
						_afbcg, _ccafa := _gadaf(_bdfea)
						if _ccafa != nil {
							_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u004b\u0020\u0063\u0068\u0069\u006c\u0064:\u0020\u0025\u0076", _ccafa)
							continue
						}
						_abcbc._dacfd = append(_abcbc._dacfd, &KValue{_eebde: _afbcg})
					case *_df.PdfObjectInteger:
						if _cafeeg, _agbdg := _df.GetIntVal(_fegfec); _agbdg {
							_abcbc._dacfd = append(_abcbc._dacfd, &KValue{_dfca: &_cafeeg})
						}
					case *_df.PdfObjectDictionary:
						_abcbc._dacfd = append(_abcbc._dacfd, &KValue{_ccgeg: _fegfec})
					}
				}
			}
		case *_df.PdfIndirectObject:
			_gegec, _gbgec := _gadaf(_bgaacf)
			if _gbgec != nil {
				_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u004b\u0020\u0063\u0068\u0069\u006c\u0064:\u0020\u0025\u0076", _gbgec)
			}
			if _gegec != nil {
				_abcbc._dacfd = append(_abcbc._dacfd, &KValue{_eebde: _gegec})
			}
		case *_df.PdfObjectDictionary:
			_abcbc._dacfd = append(_abcbc._dacfd, &KValue{_ccgeg: _bgaacf})
		case *_df.PdfObjectInteger:
			if _fgffff, _ddbeed := _df.GetIntVal(_ecdbdc); _ddbeed {
				_abcbc._dacfd = append(_abcbc._dacfd, &KValue{_dfca: &_fgffff})
			}
		}
	}
	if _cefec := _ggabed.Get("\u0041"); _cefec != nil {
		_abcbc.A = _cefec
	}
	if _fccfc := _ggabed.Get("\u0043"); _fccfc != nil {
		_abcbc.C = _fccfc
	}
	if _fbdgc := _ggabed.Get("\u0052"); _fbdgc != nil {
		if _baebf, _fecf := _df.GetInt(_fbdgc); _fecf {
			_abcbc.R = _baebf
		}
	}
	if _ffdac := _ggabed.Get("\u0054"); _ffdac != nil {
		if _ebgfg, _caeeb := _df.GetString(_ffdac); _caeeb {
			_abcbc.T = _ebgfg
		}
	}
	if _acga := _ggabed.Get("\u004c\u0061\u006e\u0067"); _acga != nil {
		if _cceec, _eafab := _df.GetString(_acga); _eafab {
			_abcbc.Lang = _cceec
		}
	}
	if _abddfc := _ggabed.Get("\u0041\u006c\u0074"); _abddfc != nil {
		if _aegdb, _caeag := _df.GetString(_abddfc); _caeag {
			_abcbc.Alt = _aegdb
		}
	}
	if _ggedfe := _ggabed.Get("\u0045"); _ggedfe != nil {
		if _cdbgc, _gfab := _df.GetString(_ggedfe); _gfab {
			_abcbc.E = _cdbgc
		}
	}
	return _abcbc, nil
}

// DSS represents a Document Security Store dictionary.
// The DSS dictionary contains both global and signature specific validation
// information. The certificates and revocation data in the `Certs`, `OCSPs`,
// and `CRLs` fields can be used to validate any signature in the document.
// Additionally, the VRI entry contains validation data per signature.
// The keys in the VRI entry are calculated as upper(hex(sha1(sig.Contents))).
// The values are VRI dictionaries containing certificates and revocation
// information used for validating a single signature.
// See ETSI TS 102 778-4 V1.1.1 for more information.
type DSS struct {
	_dbdf *_df.PdfIndirectObject
	Certs []*_df.PdfObjectStream
	OCSPs []*_df.PdfObjectStream
	CRLs  []*_df.PdfObjectStream
	VRI   map[string]*VRI
	_cdeb map[string]*_df.PdfObjectStream
	_fgdg map[string]*_df.PdfObjectStream
	_fcba map[string]*_df.PdfObjectStream
}

func _efddd(_afdfa *_df.PdfObjectDictionary, _dbffd *fontCommon) (*pdfCIDFontType2, error) {
	if _dbffd._fgfae != "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032" {
		_bcd.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0046\u006fn\u0074\u0020\u0053u\u0062\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020CI\u0044\u0046\u006fn\u0074\u0054y\u0070\u0065\u0032\u002e\u0020\u0066o\u006e\u0074=\u0025\u0073", _dbffd)
		return nil, _df.ErrRangeError
	}
	_bagff := _baec(_dbffd)
	_cabbdc, _cabcg := _df.GetDict(_afdfa.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
	if !_cabcg {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043I\u0044\u0053\u0079st\u0065\u006d\u0049\u006e\u0066\u006f \u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _dbffd)
		return nil, ErrRequiredAttributeMissing
	}
	_bagff.CIDSystemInfo = _cabbdc
	_bagff.DW = _afdfa.Get("\u0044\u0057")
	_bagff.W = _afdfa.Get("\u0057")
	_bagff.DW2 = _afdfa.Get("\u0044\u0057\u0032")
	_bagff.W2 = _afdfa.Get("\u0057\u0032")
	_bagff.CIDToGIDMap = _afdfa.Get("C\u0049\u0044\u0054\u006f\u0047\u0049\u0044\u004d\u0061\u0070")
	_bagff._feab = 1000.0
	if _cgcgg, _deefg := _df.GetNumberAsFloat(_bagff.DW); _deefg == nil {
		_bagff._feab = _cgcgg
	}
	_ebcg, _aagef := _cadgb(_bagff.W)
	if _aagef != nil {
		return nil, _aagef
	}
	if _ebcg == nil {
		_ebcg = map[_abg.CharCode]float64{}
	}
	_bagff._ddggg = _ebcg
	return _bagff, nil
}

// PdfAnnotationCircle represents Circle annotations.
// (Section 12.5.6.8).
type PdfAnnotationCircle struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	BS _df.PdfObject
	IC _df.PdfObject
	BE _df.PdfObject
	RD _df.PdfObject
}

// PdfColorCalRGB represents a color in the Colorimetric CIE RGB colorspace.
// A, B, C components
// Each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorCalRGB [3]float64

// SetContentStream updates the content stream with specified encoding.
// If encoding is null, will use the xform.Filter object or Raw encoding if not set.
func (_bdfa *XObjectForm) SetContentStream(content []byte, encoder _df.StreamEncoder) error {
	_bbdaa := content
	if encoder == nil {
		if _bdfa.Filter != nil {
			encoder = _bdfa.Filter
		} else {
			encoder = _df.NewRawEncoder()
		}
	}
	_dbbce, _cdgac := encoder.EncodeBytes(_bbdaa)
	if _cdgac != nil {
		return _cdgac
	}
	_bbdaa = _dbbce
	_bdfa.Stream = _bbdaa
	_bdfa.Filter = encoder
	return nil
}

// C returns the value of the cyan component of the color.
func (_cfdg *PdfColorDeviceCMYK) C() float64 { return _cfdg[0] }

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element between 0 and 1.
func (_agfc *PdfColorspaceDeviceGray) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_efeac := vals[0]
	if _efeac < 0.0 || _efeac > 1.0 {
		_bcd.Log.Debug("\u0049\u006eco\u006d\u0070\u0061t\u0069\u0062\u0069\u006city\u003a R\u0061\u006e\u0067\u0065\u0020\u006f\u0075ts\u0069\u0064\u0065\u0020\u005b\u0030\u002c1\u005d")
	}
	if _efeac < 0.0 {
		_efeac = 0.0
	} else if _efeac > 1.0 {
		_efeac = 1.0
	}
	return NewPdfColorDeviceGray(_efeac), nil
}

// AddOCSPs adds OCSPs to DSS.
func (_aceda *DSS) AddOCSPs(ocsps [][]byte) ([]*_df.PdfObjectStream, error) {
	return _aceda.add(&_aceda.OCSPs, _aceda._fgdg, ocsps)
}

// SetCatalogLanguage sets the catalog language.
func (_efcgg *PdfWriter) SetCatalogLanguage(lang _df.PdfObject) error {
	if lang == nil {
		_efcgg._gdee.Remove("\u004c\u0061\u006e\u0067")
		return nil
	}
	_efcgg.addObject(lang)
	_efcgg._gdee.Set("\u004c\u0061\u006e\u0067", lang)
	return nil
}

var (
	TabOrderRow       TabOrderType = "\u0052"
	TabOrderColumn    TabOrderType = "\u0043"
	TabOrderStructure TabOrderType = "\u0053"
)

func (_dbdd *PdfReader) buildNameNodes(_afgdc *_df.PdfIndirectObject, _gaec map[_df.PdfObject]struct{}) error {
	if _afgdc == nil {
		return nil
	}
	if _, _fbba := _gaec[_afgdc]; _fbba {
		_bcd.Log.Debug("\u0043\u0079\u0063l\u0069\u0063\u0020\u0072e\u0063\u0075\u0072\u0073\u0069\u006f\u006e,\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0028\u0025\u0076\u0029", _afgdc.ObjectNumber)
		return nil
	}
	_gaec[_afgdc] = struct{}{}
	_bedaf, _bcbca := _afgdc.PdfObject.(*_df.PdfObjectDictionary)
	if !_bcbca {
		return _deb.New("n\u006f\u0064\u0065\u0020no\u0074 \u0061\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if _dfcc, _caad := _df.GetDict(_bedaf.Get("\u0044\u0065\u0073t\u0073")); _caad {
		_eefef, _aeadd := _df.GetArray(_dfcc.Get("\u004b\u0069\u0064\u0073"))
		if !_aeadd {
			return _deb.New("\u0049n\u0076\u0061\u006c\u0069d\u0020\u004b\u0069\u0064\u0073 \u0061r\u0072a\u0079\u0020\u006f\u0062\u006a\u0065\u0063t")
		}
		_bcd.Log.Trace("\u004b\u0069\u0064\u0073\u003a\u0020\u0025\u0073", _eefef)
		for _gdfe, _edeef := range _eefef.Elements() {
			_gcfg, _gfcbg := _df.GetIndirect(_edeef)
			if !_gfcbg {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u0068\u0069\u006c\u0064\u0020n\u006f\u0074\u0020\u0069\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002d \u0028\u0025\u0073\u0029", _gcfg)
				return _deb.New("\u0063h\u0069\u006c\u0064\u0020n\u006f\u0074\u0020\u0069\u006ed\u0069r\u0065c\u0074\u0020\u006f\u0062\u006a\u0065\u0063t")
			}
			_eefef.Set(_gdfe, _gcfg)
			_eddfa := _dbdd.buildNameNodes(_gcfg, _gaec)
			if _eddfa != nil {
				return _eddfa
			}
		}
	}
	if _gagcf, _dggda := _df.GetDict(_bedaf); _dggda {
		if !_df.IsNullObject(_gagcf.Get("\u004b\u0069\u0064\u0073")) {
			if _agcc, _fbgaab := _df.GetArray(_gagcf.Get("\u004b\u0069\u0064\u0073")); _fbgaab {
				for _afbd, _bfeff := range _agcc.Elements() {
					if _gccdg, _dbfga := _df.GetIndirect(_bfeff); _dbfga {
						_agcc.Set(_afbd, _gccdg)
						_eggca := _dbdd.buildNameNodes(_gccdg, _gaec)
						if _eggca != nil {
							return _eggca
						}
					}
				}
			}
		}
	}
	return nil
}

// MergePageWith appends page content to source Pdf file page content.
func (_fbfe *PdfAppender) MergePageWith(pageNum int, page *PdfPage) error {
	_cfdcb := pageNum - 1
	var _edba *PdfPage
	for _abed, _dcgf := range _fbfe._dgac {
		if _abed == _cfdcb {
			_edba = _dcgf
		}
	}
	if _edba == nil {
		return _c.Errorf("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079\u0020\u0025\u0064\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0073o\u0075\u0072\u0063\u0065\u0020\u0064o\u0063\u0075\u006de\u006e\u0074", pageNum)
	}
	if _edba._gcced != nil && _edba._gcced.GetParser() == _fbfe._abf._gfdaag {
		_edba = _edba.Duplicate()
		_fbfe._dgac[_cfdcb] = _edba
	}
	page = page.Duplicate()
	_dfdde(page)
	_dbfd := _bbgb(_edba)
	_aedb := _bbgb(page)
	_dabg := make(map[_df.PdfObjectName]_df.PdfObjectName)
	for _gceb := range _aedb {
		if _, _abdb := _dbfd[_gceb]; _abdb {
			for _ddcd := 1; true; _ddcd++ {
				_edbd := _df.PdfObjectName(string(_gceb) + _bc.Itoa(_ddcd))
				if _, _bbgg := _dbfd[_edbd]; !_bbgg {
					_dabg[_gceb] = _edbd
					break
				}
			}
		}
	}
	_ddbg, _cdda := page.GetContentStreams()
	if _cdda != nil {
		return _cdda
	}
	_cbg, _cdda := _edba.GetContentStreams()
	if _cdda != nil {
		return _cdda
	}
	for _efea, _eegb := range _ddbg {
		for _baae, _fedc := range _dabg {
			_eegb = _gc.Replace(_eegb, "\u002f"+string(_baae), "\u002f"+string(_fedc), -1)
		}
		_ddbg[_efea] = _eegb
	}
	_cbg = append(_cbg, _ddbg...)
	if _ddag := _edba.SetContentStreams(_cbg, _df.NewFlateEncoder()); _ddag != nil {
		return _ddag
	}
	_edba._adef = append(_edba._adef, page._adef...)
	if _edba.Resources == nil {
		_edba.Resources = NewPdfPageResources()
	}
	if page.Resources != nil {
		_edba.Resources.Font = _fbfe.mergeResources(_edba.Resources.Font, page.Resources.Font, _dabg)
		_edba.Resources.XObject = _fbfe.mergeResources(_edba.Resources.XObject, page.Resources.XObject, _dabg)
		_edba.Resources.Properties = _fbfe.mergeResources(_edba.Resources.Properties, page.Resources.Properties, _dabg)
		if _edba.Resources.ProcSet == nil {
			_edba.Resources.ProcSet = page.Resources.ProcSet
		}
		_edba.Resources.Shading = _fbfe.mergeResources(_edba.Resources.Shading, page.Resources.Shading, _dabg)
		_edba.Resources.ExtGState = _fbfe.mergeResources(_edba.Resources.ExtGState, page.Resources.ExtGState, _dabg)
	}
	_gaeb, _cdda := _edba.GetMediaBox()
	if _cdda != nil {
		return _cdda
	}
	_dbe, _cdda := page.GetMediaBox()
	if _cdda != nil {
		return _cdda
	}
	var _bbad bool
	if _gaeb.Llx > _dbe.Llx {
		_gaeb.Llx = _dbe.Llx
		_bbad = true
	}
	if _gaeb.Lly > _dbe.Lly {
		_gaeb.Lly = _dbe.Lly
		_bbad = true
	}
	if _gaeb.Urx < _dbe.Urx {
		_gaeb.Urx = _dbe.Urx
		_bbad = true
	}
	if _gaeb.Ury < _dbe.Ury {
		_gaeb.Ury = _dbe.Ury
		_bbad = true
	}
	if _bbad {
		_edba.MediaBox = _gaeb
	}
	return nil
}

type fontCommon struct {
	_gddcf  string
	_fgfae  string
	_ggad   string
	_cdbgag _df.PdfObject
	_afcbd  *_dgf.CMap
	_agggb  *PdfFontDescriptor
	_fceg   int64
}

func (_beecb *pdfCIDFontType2) baseFields() *fontCommon { return &_beecb.fontCommon }

// PdfOutputIntentType is the subtype of the given PdfOutputIntent.
type PdfOutputIntentType int

// PdfAnnotation3D represents 3D annotations.
// (Section 13.6.2).
type PdfAnnotation3D struct {
	*PdfAnnotation
	T3DD _df.PdfObject
	T3DV _df.PdfObject
	T3DA _df.PdfObject
	T3DI _df.PdfObject
	T3DB _df.PdfObject
}

// GetContainingPdfObject returns the container of the image object (indirect object).
func (_defda *XObjectImage) GetContainingPdfObject() _df.PdfObject { return _defda._fgdgd }

// NewPdfFilespec returns an initialized generic PDF filespec model.
func NewPdfFilespec() *PdfFilespec {
	_bcdgb := &PdfFilespec{}
	_bcdgb._gaafd = _df.MakeIndirectObject(_df.MakeDict())
	return _bcdgb
}

var _cfaf = map[string]struct{}{"\u0057i\u006eA\u006e\u0073\u0069\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}, "\u004d\u0061c\u0052\u006f\u006da\u006e\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}, "\u004d\u0061\u0063\u0045\u0078\u0070\u0065\u0072\u0074\u0045\u006e\u0063o\u0064\u0069\u006e\u0067": {}, "\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}}

// GetContainingPdfObject implements interface PdfModel.
func (_daddaf *PdfSignatureReference) GetContainingPdfObject() _df.PdfObject { return _daddaf._fabaf }

// PdfActionJavaScript represents a javaScript action.
type PdfActionJavaScript struct {
	*PdfAction
	JS _df.PdfObject
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element.
func (_gged *PdfColorspaceSpecialIndexed) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	N := _gged.Base.GetNumComponents()
	_bcde := int(vals[0]) * N
	if _bcde < 0 || (_bcde+N-1) >= len(_gged._befa) {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _bcde)
		return nil, ErrColorOutOfRange
	}
	_cefb := _gged._befa[_bcde : _bcde+N]
	var _fcbd []float64
	for _, _ffdb := range _cefb {
		_fcbd = append(_fcbd, float64(_ffdb)/255.0)
	}
	_bgcgd, _ddgg := _gged.Base.ColorFromFloats(_fcbd)
	if _ddgg != nil {
		return nil, _ddgg
	}
	return _bgcgd, nil
}

// GetCerts returns the signature certificate chain.
func (_ecbge *PdfSignature) GetCerts() ([]*_ed.Certificate, error) {
	var _agdcgb []func() ([]*_ed.Certificate, error)
	switch _gfcbf, _ := _df.GetNameVal(_ecbge.SubFilter); _gfcbf {
	case "\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064", "\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064":
		_agdcgb = append(_agdcgb, _ecbge.extractChainFromPKCS7, _ecbge.extractChainFromCert)
	case "\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031":
		_agdcgb = append(_agdcgb, _ecbge.extractChainFromCert)
	case "\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031":
		_agdcgb = append(_agdcgb, _ecbge.extractChainFromPKCS7)
	default:
		return nil, _c.Errorf("\u0075n\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020S\u0075b\u0046i\u006c\u0074\u0065\u0072\u003a\u0020\u0025s", _gfcbf)
	}
	for _, _fbeac := range _agdcgb {
		_cbedd, _cgddf := _fbeac()
		if _cgddf != nil {
			return nil, _cgddf
		}
		if len(_cbedd) > 0 {
			return _cbedd, nil
		}
	}
	return nil, ErrSignNoCertificates
}

// AddWatermarkImage adds an image watermark to the page.
func (_ffgf *PdfPage) AddWatermarkImage(ximg *XObjectImage, opt WatermarkImageOptions) error {
	_eccc, _abaff := _ffgf.GetMediaBox()
	if _abaff != nil {
		return _abaff
	}
	_cfbce := _eccc.Urx - _eccc.Llx
	_gadd := _eccc.Ury - _eccc.Lly
	_dcbag := opt.Angle * _faf.Pi / 180
	_gdcdf := float64(*ximg.Width)
	_ededf := (_cfbce - _gdcdf*_faf.Cos(_dcbag)) / 2
	if opt.FitToWidth {
		_gdcdf = _cfbce
		_ededf = 0
	}
	_gcbfd := _gadd
	_cdgad := float64(0)
	if opt.PreserveAspectRatio {
		_gcbfd = _gdcdf * float64(*ximg.Height) / float64(*ximg.Width)
		_cdgad = (_gadd - _gcbfd) / 2
		_cdgad -= float64(*ximg.Width) / 2 * _faf.Sin(_dcbag)
	}
	if _ffgf.Resources == nil {
		_ffgf.Resources = NewPdfPageResources()
	}
	_efcgb := NewXObjectForm()
	_efcgb.BBox = _df.MakeArrayFromFloats([]float64{0, 0, _gdcdf, _gcbfd})
	_efcgb.Resources = NewPdfPageResources()
	_fecec := 0
	_cbfea := _df.PdfObjectName(_c.Sprintf("\u0049\u006d\u0077%\u0064", _fecec))
	for _efcgb.Resources.HasXObjectByName(_cbfea) {
		_fecec++
		_cbfea = _df.PdfObjectName(_c.Sprintf("\u0049\u006d\u0077%\u0064", _fecec))
	}
	_abaff = _efcgb.Resources.SetXObjectImageByName(_cbfea, ximg)
	if _abaff != nil {
		return _abaff
	}
	_fecec = 0
	_ebgf := _df.PdfObjectName(_c.Sprintf("\u0047\u0053\u0025\u0064", _fecec))
	for _efcgb.Resources.HasExtGState(_ebgf) {
		_fecec++
		_ebgf = _df.PdfObjectName(_c.Sprintf("\u0047\u0053\u0025\u0064", _fecec))
	}
	_egcfb := _df.MakeDict()
	_egcfb.Set("\u0042\u004d", _df.MakeName("\u004e\u006f\u0072\u006d\u0061\u006c"))
	_egcfb.Set("\u0043\u0041", _df.MakeFloat(opt.Alpha))
	_egcfb.Set("\u0063\u0061", _df.MakeFloat(opt.Alpha))
	_abaff = _efcgb.Resources.AddExtGState(_ebgf, _egcfb)
	if _abaff != nil {
		return _abaff
	}
	_faaabe := _c.Sprintf("\u0071\u000a"+"\u002f%\u0073\u0020\u0067\u0073\u000a"+"%\u002e\u0030\u0066\u0020\u0030\u00200\u0020\u0025\u002e\u0030\u0066\u0020\u0025\u002e\u0034f\u0020\u0025\u002e4\u0066 \u0063\u006d\u000a"+"\u002f%\u0073\u0020\u0044\u006f\u000a"+"\u0051", _ebgf, _gdcdf, _gcbfd, 0.0, 0.0, _cbfea)
	_efcgb.SetContentStream([]byte(_faaabe), nil)
	_efge := _dbc.IdentityMatrix().Rotate(_dcbag)
	_agfbf := []float64{_efge[0], _efge[1], _efge[3], _efge[4], _efge[6], _efge[7]}
	_efcgb.Matrix = _df.MakeArrayFromFloats(_agfbf)
	_fcceg := _ffgf.Resources.GenerateXObjectName()
	_abaff = _ffgf.Resources.SetXObjectFormByName(_fcceg, _efcgb)
	if _abaff != nil {
		return _abaff
	}
	_bdcd := _c.Sprintf("\u0071\u000a"+"%\u002e\u0030\u0066\u0020\u0030\u00200\u0020\u0025\u002e\u0030\u0066\u0020\u0025\u002e\u0034f\u0020\u0025\u002e4\u0066 \u0063\u006d\u000a"+"\u002f%\u0073\u0020\u0044\u006f\u000a"+"\u0051", 1.0, 1.0, _ededf, _cdgad, _fcceg)
	return _ffgf.AddContentStreamByString(_bdcd)
}

func (_ddede *LTV) getCRLs(_eggef []*_ed.Certificate) ([][]byte, error) {
	_aacbc := make([][]byte, 0, len(_eggef))
	for _, _fgefe := range _eggef {
		for _, _faaeb := range _fgefe.CRLDistributionPoints {
			if _ddede.CertClient.IsCA(_fgefe) {
				continue
			}
			_gbbafc, _ggfg := _ddede.CRLClient.MakeRequest(_faaeb, _fgefe)
			if _ggfg != nil {
				_bcd.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076", _ggfg)
				continue
			}
			_aacbc = append(_aacbc, _gbbafc)
		}
	}
	return _aacbc, nil
}

// NewPdfAnnotationText returns a new text annotation.
func NewPdfAnnotationText() *PdfAnnotationText {
	_fgcg := NewPdfAnnotation()
	_aeafa := &PdfAnnotationText{}
	_aeafa.PdfAnnotation = _fgcg
	_aeafa.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_fgcg.SetContext(_aeafa)
	return _aeafa
}

// SetContext set the sub annotation (context).
func (_bbbec *PdfShading) SetContext(ctx PdfModel) { _bbbec._dggab = ctx }

// GetKDict returns the KDict of the KValue.
func (_cgegg *KValue) GetKDict() *KDict { return _cgegg._eebde }

// NewPdfFontFromPdfObject loads a PdfFont from the dictionary `fontObj`.  If there is a problem an
// error is returned.
func NewPdfFontFromPdfObject(fontObj _df.PdfObject) (*PdfFont, error) {
	return _fafcf(fontObj, true)
}

// ToPdfObject returns the PDF representation of the shading pattern.
func (_acca *PdfShadingPatternType3) ToPdfObject() _df.PdfObject {
	_acca.PdfPattern.ToPdfObject()
	_abfce := _acca.getDict()
	if _acca.Shading != nil {
		_abfce.Set("\u0053h\u0061\u0064\u0069\u006e\u0067", _acca.Shading.ToPdfObject())
	}
	if _acca.Matrix != nil {
		_abfce.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _acca.Matrix)
	}
	if _acca.ExtGState != nil {
		_abfce.Set("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _acca.ExtGState)
	}
	return _acca._cbce
}

func (_eegda *PdfReader) resolveReference(_ebcf *_df.PdfObjectReference) (_df.PdfObject, bool, error) {
	_dadad, _dbec := _eegda._gfdaag.ObjCache[int(_ebcf.ObjectNumber)]
	if !_dbec {
		_bcd.Log.Trace("R\u0065\u0061\u0064\u0065r \u004co\u006f\u006b\u0075\u0070\u0020r\u0065\u0066\u003a\u0020\u0025\u0073", _ebcf)
		_agfd, _bdcaae := _eegda._gfdaag.LookupByReference(*_ebcf)
		if _bdcaae != nil {
			return nil, false, _bdcaae
		}
		_eegda._gfdaag.ObjCache[int(_ebcf.ObjectNumber)] = _agfd
		return _agfd, false, nil
	}
	return _dadad, true, nil
}

type modelManager struct {
	_cebgf map[PdfModel]_df.PdfObject
	_fdge  map[_df.PdfObject]PdfModel
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_cdaed *PdfShadingType5) ToPdfObject() _df.PdfObject {
	_cdaed.PdfShading.ToPdfObject()
	_abdfd, _ededff := _cdaed.getShadingDict()
	if _ededff != nil {
		_bcd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _cdaed.BitsPerCoordinate != nil {
		_abdfd.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _cdaed.BitsPerCoordinate)
	}
	if _cdaed.BitsPerComponent != nil {
		_abdfd.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _cdaed.BitsPerComponent)
	}
	if _cdaed.VerticesPerRow != nil {
		_abdfd.Set("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050e\u0072\u0052\u006f\u0077", _cdaed.VerticesPerRow)
	}
	if _cdaed.Decode != nil {
		_abdfd.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _cdaed.Decode)
	}
	if _cdaed.Function != nil {
		if len(_cdaed.Function) == 1 {
			_abdfd.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _cdaed.Function[0].ToPdfObject())
		} else {
			_egdad := _df.MakeArray()
			for _, _dacaa := range _cdaed.Function {
				_egdad.Append(_dacaa.ToPdfObject())
			}
			_abdfd.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _egdad)
		}
	}
	return _cdaed._bgdag
}

// IsCID returns true if the underlying font is CID.
func (_ccee *PdfFont) IsCID() bool { return _ccee.baseFields().isCIDFont() }

type crossReference struct {
	Type int

	// Type 1
	Offset     int64
	Generation int64

	// Type 2
	ObjectNumber int
	Index        int
}

func (_cbfb *PdfReader) newPdfActionURIFromDict(_fe *_df.PdfObjectDictionary) (*PdfActionURI, error) {
	return &PdfActionURI{URI: _fe.Get("\u0055\u0052\u0049"), IsMap: _fe.Get("\u0049\u0073\u004da\u0070")}, nil
}

func (_caeda *PdfWriter) adjustXRefAffectedVersion(_deabg bool) {
	if _deabg && _caeda._aeffd.Major == 1 && _caeda._aeffd.Minor < 5 {
		_caeda._aeffd.Minor = 5
	}
}

// HasXObjectByName checks if an XObject with a specified keyName is defined.
func (_aacac *PdfPageResources) HasXObjectByName(keyName _df.PdfObjectName) bool {
	_ceddg, _ := _aacac.GetXObjectByName(keyName)
	return _ceddg != nil
}

// NewPdfActionHide returns a new "hide" action.
func NewPdfActionHide() *PdfActionHide {
	_dab := NewPdfAction()
	_bddg := &PdfActionHide{}
	_bddg.PdfAction = _dab
	_dab.SetContext(_bddg)
	return _bddg
}

// ApplyStandard is used to apply changes required on the document to match the rules required by the input standard.
// The writer's content would be changed after all the document parts are already established during the Write method.
// A good example of the StandardApplier could be a PDF/A Profile (i.e.: pdfa.Profile1A). In such a case PdfWriter would
// set up all rules required by that Profile.
func (_beeag *PdfWriter) ApplyStandard(optimizer StandardApplier) { _beeag._fbcafd = optimizer }

// PdfActionGoToR represents a GoToR action.
type PdfActionGoToR struct {
	*PdfAction
	F         *PdfFilespec
	D         _df.PdfObject
	NewWindow _df.PdfObject
}

func (_fgabb *Image) samplesAddPadding(_bfbga []uint32) []uint32 {
	_gbfcg := _bge.BytesPerLine(int(_fgabb.Width), int(_fgabb.BitsPerComponent), _fgabb.ColorComponents) * (8 / int(_fgabb.BitsPerComponent))
	_fgcf := _gbfcg * int(_fgabb.Height)
	if len(_bfbga) == _fgcf {
		return _bfbga
	}
	_baacd := make([]uint32, _fgcf)
	_beab := int(_fgabb.Width) * _fgabb.ColorComponents
	for _dcfe := 0; _dcfe < int(_fgabb.Height); _dcfe++ {
		_adbf := _dcfe * int(_fgabb.Width)
		_cbegb := _dcfe * _gbfcg
		for _dccce := 0; _dccce < _beab; _dccce++ {
			_baacd[_cbegb+_dccce] = _bfbga[_adbf+_dccce]
		}
	}
	return _baacd
}

// GetPdfName returns the PDF name used to indicate the border style.
// (Table 166 p. 395).
func (_afde *BorderStyle) GetPdfName() string {
	switch *_afde {
	case BorderStyleSolid:
		return "\u0053"
	case BorderStyleDashed:
		return "\u0044"
	case BorderStyleBeveled:
		return "\u0042"
	case BorderStyleInset:
		return "\u0049"
	case BorderStyleUnderline:
		return "\u0055"
	}
	return ""
}

// Encoder returns the font's text encoder.
func (_gcff pdfCIDFontType0) Encoder() _abg.TextEncoder { return _gcff._bafeg }

// NewPdfAnnotationCaret returns a new caret annotation.
func NewPdfAnnotationCaret() *PdfAnnotationCaret {
	_bbefe := NewPdfAnnotation()
	_feb := &PdfAnnotationCaret{}
	_feb.PdfAnnotation = _bbefe
	_feb.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_bbefe.SetContext(_feb)
	return _feb
}

// PdfColorspaceDeviceNAttributes contains additional information about the components of colour space that
// conforming readers may use. Conforming readers need not use the alternateSpace and tintTransform parameters,
// and may instead use a custom blending algorithms, along with other information provided in the attributes
// dictionary if present.
type PdfColorspaceDeviceNAttributes struct {
	Subtype     *_df.PdfObjectName
	Colorants   _df.PdfObject
	Process     _df.PdfObject
	MixingHints _df.PdfObject
	_addb       *_df.PdfIndirectObject
}

// GetCIDToGIDMapObject get the underlying CIDToGIDMap object if the font type is CIDFontType2.
func (_eceggg *PdfFont) GetCIDToGIDMapObject() _df.PdfObject {
	_gagc, _dadc := _eceggg._eaeg.(*pdfCIDFontType2)
	if _dadc {
		return _gagc.CIDToGIDMap
	}
	return nil
}

func _efdeb(_bcddc *_df.PdfObjectDictionary) (*PdfShadingType1, error) {
	_gdaad := PdfShadingType1{}
	if _adadb := _bcddc.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _adadb != nil {
		_adadb = _df.TraceToDirectObject(_adadb)
		_fcafg, _edeg := _adadb.(*_df.PdfObjectArray)
		if !_edeg {
			_bcd.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _adadb)
			return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_gdaad.Domain = _fcafg
	}
	if _ffgag := _bcddc.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _ffgag != nil {
		_ffgag = _df.TraceToDirectObject(_ffgag)
		_fddag, _fbdff := _ffgag.(*_df.PdfObjectArray)
		if !_fbdff {
			_bcd.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _ffgag)
			return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_gdaad.Matrix = _fddag
	}
	_eeccd := _bcddc.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _eeccd == nil {
		_bcd.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_gdaad.Function = []PdfFunction{}
	if _abcdc, _dgdebg := _eeccd.(*_df.PdfObjectArray); _dgdebg {
		for _, _eggfe := range _abcdc.Elements() {
			_febf, _dedcf := _ddaac(_eggfe)
			if _dedcf != nil {
				_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _dedcf)
				return nil, _dedcf
			}
			_gdaad.Function = append(_gdaad.Function, _febf)
		}
	} else {
		_aafdc, _gaeaa := _ddaac(_eeccd)
		if _gaeaa != nil {
			_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _gaeaa)
			return nil, _gaeaa
		}
		_gdaad.Function = append(_gdaad.Function, _aafdc)
	}
	return &_gdaad, nil
}

// CharcodesToUnicodeWithStats is identical to CharcodesToUnicode except it returns more statistical
// information about hits and misses from the reverse mapping process.
// NOTE: The number of runes returned may be greater than the number of charcodes.
// TODO(peterwilliams97): Deprecate in v4 and use only CharcodesToStrings()
func (_edebc *PdfFont) CharcodesToUnicodeWithStats(charcodes []_abg.CharCode) (_adfbe []rune, _aaab, _cace int) {
	_fgde, _aaab, _cace := _edebc.CharcodesToStrings(charcodes, "")
	return []rune(_gc.Join(_fgde, "")), _aaab, _cace
}

// ToPdfObject implements interface PdfModel.
func (_ae *PdfActionURI) ToPdfObject() _df.PdfObject {
	_ae.PdfAction.ToPdfObject()
	_cea := _ae._gcf
	_dbb := _cea.PdfObject.(*_df.PdfObjectDictionary)
	_dbb.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeURI)))
	_dbb.SetIfNotNil("\u0055\u0052\u0049", _ae.URI)
	_dbb.SetIfNotNil("\u0049\u0073\u004da\u0070", _ae.IsMap)
	return _cea
}

// NewPdfColorspaceDeviceGray returns a new grayscale colorspace.
func NewPdfColorspaceDeviceGray() *PdfColorspaceDeviceGray { return &PdfColorspaceDeviceGray{} }

func (_deafa *PdfWriter) setCatalogVersion() {
	_deafa._gdee.Set("\u0056e\u0072\u0073\u0069\u006f\u006e", _df.MakeName(_c.Sprintf("\u0025\u0064\u002e%\u0064", _deafa._aeffd.Major, _deafa._aeffd.Minor)))
}

// ToPdfObject implements interface PdfModel.
func (_cfg *PdfActionLaunch) ToPdfObject() _df.PdfObject {
	_cfg.PdfAction.ToPdfObject()
	_daba := _cfg._gcf
	_cfb := _daba.PdfObject.(*_df.PdfObjectDictionary)
	_cfb.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeLaunch)))
	if _cfg.F != nil {
		_cfb.Set("\u0046", _cfg.F.ToPdfObject())
	}
	_cfb.SetIfNotNil("\u0057\u0069\u006e", _cfg.Win)
	_cfb.SetIfNotNil("\u004d\u0061\u0063", _cfg.Mac)
	_cfb.SetIfNotNil("\u0055\u006e\u0069\u0078", _cfg.Unix)
	_cfb.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _cfg.NewWindow)
	return _daba
}

// NewPdfActionJavaScript returns a new "javaScript" action.
func NewPdfActionJavaScript() *PdfActionJavaScript {
	_dc := NewPdfAction()
	_gcea := &PdfActionJavaScript{}
	_gcea.PdfAction = _dc
	_dc.SetContext(_gcea)
	return _gcea
}

func _cfbc() string {
	_beff := "\u0051\u0057\u0045\u0052\u0054\u0059\u0055\u0049\u004f\u0050\u0041S\u0044\u0046\u0047\u0048\u004a\u004b\u004c\u005a\u0058\u0043V\u0042\u004e\u004d"
	var _adbg _ef.Buffer
	for _ebeb := 0; _ebeb < 6; _ebeb++ {
		_adbg.WriteRune(rune(_beff[_ebf.Intn(len(_beff))]))
	}
	return _adbg.String()
}

// NewPdfAnnotationLink returns a new link annotation.
func NewPdfAnnotationLink() *PdfAnnotationLink {
	_gfdc := NewPdfAnnotation()
	_fee := &PdfAnnotationLink{}
	_fee.PdfAnnotation = _gfdc
	_gfdc.SetContext(_fee)
	return _fee
}

// ToPdfObject returns the PdfFontDescriptor as a PDF dictionary inside an indirect object.
func (_aeef *PdfFontDescriptor) ToPdfObject() _df.PdfObject {
	_fgddc := _df.MakeDict()
	if _aeef._abaa == nil {
		_aeef._abaa = &_df.PdfIndirectObject{}
	}
	_aeef._abaa.PdfObject = _fgddc
	_fgddc.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072"))
	if _aeef.FontName != nil {
		_fgddc.Set("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065", _aeef.FontName)
	}
	if _aeef.FontFamily != nil {
		_fgddc.Set("\u0046\u006f\u006e\u0074\u0046\u0061\u006d\u0069\u006c\u0079", _aeef.FontFamily)
	}
	if _aeef.FontStretch != nil {
		_fgddc.Set("F\u006f\u006e\u0074\u0053\u0074\u0072\u0065\u0074\u0063\u0068", _aeef.FontStretch)
	}
	if _aeef.FontWeight != nil {
		_fgddc.Set("\u0046\u006f\u006e\u0074\u0057\u0065\u0069\u0067\u0068\u0074", _aeef.FontWeight)
	}
	if _aeef.Flags != nil {
		_fgddc.Set("\u0046\u006c\u0061g\u0073", _aeef.Flags)
	}
	if _aeef.FontBBox != nil {
		_fgddc.Set("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078", _aeef.FontBBox)
	}
	if _aeef.ItalicAngle != nil {
		_fgddc.Set("I\u0074\u0061\u006c\u0069\u0063\u0041\u006e\u0067\u006c\u0065", _aeef.ItalicAngle)
	}
	if _aeef.Ascent != nil {
		_fgddc.Set("\u0041\u0073\u0063\u0065\u006e\u0074", _aeef.Ascent)
	}
	if _aeef.Descent != nil {
		_fgddc.Set("\u0044e\u0073\u0063\u0065\u006e\u0074", _aeef.Descent)
	}
	if _aeef.Leading != nil {
		_fgddc.Set("\u004ce\u0061\u0064\u0069\u006e\u0067", _aeef.Leading)
	}
	if _aeef.CapHeight != nil {
		_fgddc.Set("\u0043a\u0070\u0048\u0065\u0069\u0067\u0068t", _aeef.CapHeight)
	}
	if _aeef.XHeight != nil {
		_fgddc.Set("\u0058H\u0065\u0069\u0067\u0068\u0074", _aeef.XHeight)
	}
	if _aeef.StemV != nil {
		_fgddc.Set("\u0053\u0074\u0065m\u0056", _aeef.StemV)
	}
	if _aeef.StemH != nil {
		_fgddc.Set("\u0053\u0074\u0065m\u0048", _aeef.StemH)
	}
	if _aeef.AvgWidth != nil {
		_fgddc.Set("\u0041\u0076\u0067\u0057\u0069\u0064\u0074\u0068", _aeef.AvgWidth)
	}
	if _aeef.MaxWidth != nil {
		_fgddc.Set("\u004d\u0061\u0078\u0057\u0069\u0064\u0074\u0068", _aeef.MaxWidth)
	}
	if _aeef.MissingWidth != nil {
		_fgddc.Set("\u004d\u0069\u0073s\u0069\u006e\u0067\u0057\u0069\u0064\u0074\u0068", _aeef.MissingWidth)
	}
	if _aeef.FontFile != nil {
		_fgddc.Set("\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065", _aeef.FontFile)
	}
	if _aeef.FontFile2 != nil {
		_fgddc.Set("\u0046o\u006e\u0074\u0046\u0069\u006c\u00652", _aeef.FontFile2)
	}
	if _aeef.FontFile3 != nil {
		_fgddc.Set("\u0046o\u006e\u0074\u0046\u0069\u006c\u00653", _aeef.FontFile3)
	}
	if _aeef.CharSet != nil {
		_fgddc.Set("\u0043h\u0061\u0072\u0053\u0065\u0074", _aeef.CharSet)
	}
	if _aeef.Style != nil {
		_fgddc.Set("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065", _aeef.FontName)
	}
	if _aeef.Lang != nil {
		_fgddc.Set("\u004c\u0061\u006e\u0067", _aeef.Lang)
	}
	if _aeef.FD != nil {
		_fgddc.Set("\u0046\u0044", _aeef.FD)
	}
	if _aeef.CIDSet != nil {
		_fgddc.Set("\u0043\u0049\u0044\u0053\u0065\u0074", _aeef.CIDSet)
	}
	return _aeef._abaa
}

// IsPush returns true if the button field represents a push button, false otherwise.
func (_fagb *PdfFieldButton) IsPush() bool { return _fagb.GetType() == ButtonTypePush }

// ColorFromFloats returns a new PdfColor based on input color components.
func (_dagda *PdfColorspaceDeviceN) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != _dagda.GetNumComponents() {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dfgda, _dbcdaf := _dagda.TintTransform.Evaluate(vals)
	if _dbcdaf != nil {
		return nil, _dbcdaf
	}
	_dacf, _dbcdaf := _dagda.AlternateSpace.ColorFromFloats(_dfgda)
	if _dbcdaf != nil {
		return nil, _dbcdaf
	}
	return _dacf, nil
}

// NewPdfAnnotationPolygon returns a new polygon annotation.
func NewPdfAnnotationPolygon() *PdfAnnotationPolygon {
	_cee := NewPdfAnnotation()
	_bdg := &PdfAnnotationPolygon{}
	_bdg.PdfAnnotation = _cee
	_bdg.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cee.SetContext(_bdg)
	return _bdg
}

// IsColored specifies if the pattern is colored.
func (_eacac *PdfTilingPattern) IsColored() bool {
	if _eacac.PaintType != nil && *_eacac.PaintType == 1 {
		return true
	}
	return false
}

func _ccbcb(_dbgecc *_df.PdfObjectDictionary) (*PdfShadingType5, error) {
	_gaeag := PdfShadingType5{}
	_befbee := _dbgecc.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _befbee == nil {
		_bcd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_bcecg, _eeeef := _befbee.(*_df.PdfObjectInteger)
	if !_eeeef {
		_bcd.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _befbee)
		return nil, _df.ErrTypeError
	}
	_gaeag.BitsPerCoordinate = _bcecg
	_befbee = _dbgecc.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _befbee == nil {
		_bcd.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_bcecg, _eeeef = _befbee.(*_df.PdfObjectInteger)
	if !_eeeef {
		_bcd.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _befbee)
		return nil, _df.ErrTypeError
	}
	_gaeag.BitsPerComponent = _bcecg
	_befbee = _dbgecc.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050e\u0072\u0052\u006f\u0077")
	if _befbee == nil {
		_bcd.Log.Debug("\u0052\u0065\u0071u\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0056\u0065\u0072\u0074\u0069c\u0065\u0073\u0050\u0065\u0072\u0052\u006f\u0077")
		return nil, ErrRequiredAttributeMissing
	}
	_bcecg, _eeeef = _befbee.(*_df.PdfObjectInteger)
	if !_eeeef {
		_bcd.Log.Debug("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050\u0065\u0072\u0052\u006f\u0077\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006et\u0065\u0067\u0065\u0072\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _befbee)
		return nil, _df.ErrTypeError
	}
	_gaeag.VerticesPerRow = _bcecg
	_befbee = _dbgecc.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _befbee == nil {
		_bcd.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_faffd, _eeeef := _befbee.(*_df.PdfObjectArray)
	if !_eeeef {
		_bcd.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _befbee)
		return nil, _df.ErrTypeError
	}
	_gaeag.Decode = _faffd
	if _cffcc := _dbgecc.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _cffcc != nil {
		_gaeag.Function = []PdfFunction{}
		if _agbeg, _ggfgd := _cffcc.(*_df.PdfObjectArray); _ggfgd {
			for _, _afbfc := range _agbeg.Elements() {
				_bcded, _ebfdc := _ddaac(_afbfc)
				if _ebfdc != nil {
					_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _ebfdc)
					return nil, _ebfdc
				}
				_gaeag.Function = append(_gaeag.Function, _bcded)
			}
		} else {
			_ceecd, _fefc := _ddaac(_cffcc)
			if _fefc != nil {
				_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _fefc)
				return nil, _fefc
			}
			_gaeag.Function = append(_gaeag.Function, _ceecd)
		}
	}
	return &_gaeag, nil
}

// SetXObjectImageByName adds the provided XObjectImage to the page resources.
// The added XObjectImage is identified by the specified name.
func (_dedbd *PdfPageResources) SetXObjectImageByName(keyName _df.PdfObjectName, ximg *XObjectImage) error {
	_egfgg := ximg.ToPdfObject().(*_df.PdfObjectStream)
	_cgbf := _dedbd.SetXObjectByName(keyName, _egfgg)
	return _cgbf
}

// ColorFromPdfObjects gets the color from a series of pdf objects (3 for rgb).
func (_fddg *PdfColorspaceDeviceRGB) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bcfa, _ege := _df.GetNumbersAsFloat(objects)
	if _ege != nil {
		return nil, _ege
	}
	return _fddg.ColorFromFloats(_bcfa)
}

// GetAscent returns the Ascent of the font `descriptor`.
func (_gdbe *PdfFontDescriptor) GetAscent() (float64, error) {
	return _df.GetNumberAsFloat(_gdbe.Ascent)
}

// PdfInfoTrapped specifies pdf trapped information.
type PdfInfoTrapped string

// SetDecode sets the decode image float slice.
func (_dfed *Image) SetDecode(decode []float64) { _dfed._bebgb = decode }

// ToPdfObject implements interface PdfModel.
func (_edagg *PdfAnnotationHighlight) ToPdfObject() _df.PdfObject {
	_edagg.PdfAnnotation.ToPdfObject()
	_edc := _edagg._bfde
	_dbcda := _edc.PdfObject.(*_df.PdfObjectDictionary)
	_edagg.PdfAnnotationMarkup.appendToPdfDictionary(_dbcda)
	_dbcda.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0048i\u0067\u0068\u006c\u0069\u0067\u0068t"))
	_dbcda.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _edagg.QuadPoints)
	return _edc
}

// PdfOutline represents a PDF outline dictionary (Table 152 - p. 376).
type PdfOutline struct {
	PdfOutlineTreeNode
	Parent *PdfOutlineTreeNode
	Count  *int64
	_edacg *_df.PdfIndirectObject
}

func (_ddbfff *PdfReader) buildOutlineTree(_gbffb _df.PdfObject, _bfdad *PdfOutlineTreeNode, _abda *PdfOutlineTreeNode, _aafa map[_df.PdfObject]struct{}) (*PdfOutlineTreeNode, *PdfOutlineTreeNode, error) {
	if _aafa == nil {
		_aafa = map[_df.PdfObject]struct{}{}
	}
	_aafa[_gbffb] = struct{}{}
	_cebeb, _facg := _gbffb.(*_df.PdfIndirectObject)
	if !_facg {
		return nil, nil, _c.Errorf("\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0063\u006f\u006et\u0061\u0069\u006e\u0065r\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0054", _gbffb)
	}
	_cegc, _bdaa := _cebeb.PdfObject.(*_df.PdfObjectDictionary)
	if !_bdaa {
		return nil, nil, _deb.New("\u006e\u006f\u0074 a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	_bcd.Log.Trace("\u0062\u0075\u0069\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0074\u0072\u0065\u0065\u003a\u0020d\u0069\u0063\u0074\u003a\u0020\u0025\u0076\u0020\u0028\u0025\u0076\u0029\u0020p\u003a\u0020\u0025\u0070", _cegc, _cebeb, _cebeb)
	if _ecba := _cegc.Get("\u0054\u0069\u0074l\u0065"); _ecba != nil {
		_dggb, _ddcge := _ddbfff.newPdfOutlineItemFromIndirectObject(_cebeb)
		if _ddcge != nil {
			return nil, nil, _ddcge
		}
		_dggb.Parent = _bfdad
		_dggb.Prev = _abda
		_eecga := _df.ResolveReference(_cegc.Get("\u0046\u0069\u0072s\u0074"))
		if _, _gcgce := _aafa[_eecga]; _eecga != nil && _eecga != _cebeb && !_gcgce {
			if !_df.IsNullObject(_eecga) {
				_bagg, _cfgcf, _bbfcb := _ddbfff.buildOutlineTree(_eecga, &_dggb.PdfOutlineTreeNode, nil, _aafa)
				if _bbfcb != nil {
					_bcd.Log.Debug("D\u0045\u0042U\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0069\u0074\u0065\u006d\u0020\u0074\u0072\u0065\u0065\u003a \u0025\u0076\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020n\u006f\u0064\u0065\u0020\u0063\u0068\u0069\u006c\u0064\u0072\u0065n\u002e", _bbfcb)
				} else {
					_dggb.First = _bagg
					_dggb.Last = _cfgcf
				}
			}
		}
		_cffbdgc := _df.ResolveReference(_cegc.Get("\u004e\u0065\u0078\u0074"))
		if _, _fgccg := _aafa[_cffbdgc]; _cffbdgc != nil && _cffbdgc != _cebeb && !_fgccg {
			if !_df.IsNullObject(_cffbdgc) {
				_bbdeca, _dddad, _gedeg := _ddbfff.buildOutlineTree(_cffbdgc, _bfdad, &_dggb.PdfOutlineTreeNode, _aafa)
				if _gedeg != nil {
					_bcd.Log.Debug("D\u0045\u0042U\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065\u0020\u0066\u006f\u0072\u0020\u004ee\u0078\u0074\u0020\u006e\u006f\u0064\u0065\u003a\u0020\u0025\u0076\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u006e\u006f\u0064e\u002e", _gedeg)
				} else {
					_dggb.Next = _bbdeca
					return &_dggb.PdfOutlineTreeNode, _dddad, nil
				}
			}
		}
		return &_dggb.PdfOutlineTreeNode, &_dggb.PdfOutlineTreeNode, nil
	}
	_edabg, _eddca := _efbda(_cebeb)
	if _eddca != nil {
		return nil, nil, _eddca
	}
	_edabg.Parent = _bfdad
	if _feffd := _cegc.Get("\u0046\u0069\u0072s\u0074"); _feffd != nil {
		_feffd = _df.ResolveReference(_feffd)
		if _, _cbdf := _aafa[_feffd]; _feffd != nil && _feffd != _cebeb && !_cbdf {
			_dgddd := _df.TraceToDirectObject(_feffd)
			if _, _fbgb := _dgddd.(*_df.PdfObjectNull); !_fbgb && _dgddd != nil {
				_gbegg, _cfecc, _fbefe := _ddbfff.buildOutlineTree(_feffd, &_edabg.PdfOutlineTreeNode, nil, _aafa)
				if _fbefe != nil {
					_bcd.Log.Debug("\u0044\u0045\u0042\u0055\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020b\u0075\u0069\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0074\u0072\u0065\u0065\u003a\u0020\u0025\u0076\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u006e\u006f\u0064\u0065 \u0063\u0068i\u006c\u0064r\u0065n\u002e", _fbefe)
				} else {
					_edabg.First = _gbegg
					_edabg.Last = _cfecc
				}
			}
		}
	}
	return &_edabg.PdfOutlineTreeNode, &_edabg.PdfOutlineTreeNode, nil
}

func (_fcfd *PdfReader) newPdfActionRenditionFromDict(_edb *_df.PdfObjectDictionary) (*PdfActionRendition, error) {
	return &PdfActionRendition{R: _edb.Get("\u0052"), AN: _edb.Get("\u0041\u004e"), OP: _edb.Get("\u004f\u0050"), JS: _edb.Get("\u004a\u0053")}, nil
}

func (_ddbd *fontFile) loadFromSegments(_ebcc, _bebeb []byte) error {
	_bcd.Log.Trace("\u006c\u006f\u0061dF\u0072\u006f\u006d\u0053\u0065\u0067\u006d\u0065\u006e\u0074\u0073\u003a\u0020\u0025\u0064\u0020\u0025\u0064", len(_ebcc), len(_bebeb))
	_bbeae := _ddbd.parseASCIIPart(_ebcc)
	if _bbeae != nil {
		return _bbeae
	}
	_bcd.Log.Trace("f\u006f\u006e\u0074\u0066\u0069\u006c\u0065\u003d\u0025\u0073", _ddbd)
	if len(_bebeb) == 0 {
		return nil
	}
	_bcd.Log.Trace("f\u006f\u006e\u0074\u0066\u0069\u006c\u0065\u003d\u0025\u0073", _ddbd)
	return nil
}

// ToPdfObject returns an indirect object containing the signature field dictionary.
func (_adba *PdfFieldSignature) ToPdfObject() _df.PdfObject {
	if _adba.PdfAnnotationWidget != nil {
		_adba.PdfAnnotationWidget.ToPdfObject()
	}
	_adba.PdfField.ToPdfObject()
	_efaba := _adba._cdbc
	_cbdbc := _efaba.PdfObject.(*_df.PdfObjectDictionary)
	_cbdbc.SetIfNotNil("\u0046\u0054", _df.MakeName("\u0053\u0069\u0067"))
	_cbdbc.SetIfNotNil("\u004c\u006f\u0063\u006b", _adba.Lock)
	_cbdbc.SetIfNotNil("\u0053\u0056", _adba.SV)
	if _adba.V != nil {
		_cbdbc.SetIfNotNil("\u0056", _adba.V.ToPdfObject())
	}
	return _efaba
}

func (_fac *PdfReader) newPdfAnnotationFreeTextFromDict(_bbf *_df.PdfObjectDictionary) (*PdfAnnotationFreeText, error) {
	_gfea := PdfAnnotationFreeText{}
	_afac, _ddaf := _fac.newPdfAnnotationMarkupFromDict(_bbf)
	if _ddaf != nil {
		return nil, _ddaf
	}
	_gfea.PdfAnnotationMarkup = _afac
	_gfea.DA = _bbf.Get("\u0044\u0041")
	_gfea.Q = _bbf.Get("\u0051")
	_gfea.RC = _bbf.Get("\u0052\u0043")
	_gfea.DS = _bbf.Get("\u0044\u0053")
	_gfea.CL = _bbf.Get("\u0043\u004c")
	_gfea.IT = _bbf.Get("\u0049\u0054")
	_gfea.BE = _bbf.Get("\u0042\u0045")
	_gfea.RD = _bbf.Get("\u0052\u0044")
	_gfea.BS = _bbf.Get("\u0042\u0053")
	_gfea.LE = _bbf.Get("\u004c\u0045")
	return &_gfea, nil
}

// PrintPageRange returns the value of the printPageRange.
func (_bbbaa *ViewerPreferences) PrintPageRange() []int { return _bbbaa._dafbb }

// SignatureHandlerDocMDP extends SignatureHandler with the ValidateWithOpts method for checking the DocMDP policy.
type SignatureHandlerDocMDP interface {
	SignatureHandler

	// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser
	// ValidateWithOpts shall contain Validate call
	ValidateWithOpts(_afgdd *PdfSignature, _fdaf Hasher, _bfgad SignatureHandlerDocMDPParams) (SignatureValidationResult, error)
}

// ColorFromFloats returns a new PdfColorDevice based on the input slice of
// color components. The slice should contain four elements representing the
// cyan, magenta, yellow and key components of the color. The values of the
// elements should be between 0 and 1.
func (_agebe *PdfColorspaceDeviceCMYK) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 4 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_adfb := vals[0]
	if _adfb < 0.0 || _adfb > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _adfb)
		return nil, ErrColorOutOfRange
	}
	_fbfc := vals[1]
	if _fbfc < 0.0 || _fbfc > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _fbfc)
		return nil, ErrColorOutOfRange
	}
	_fcdcd := vals[2]
	if _fcdcd < 0.0 || _fcdcd > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _fcdcd)
		return nil, ErrColorOutOfRange
	}
	_adcd := vals[3]
	if _adcd < 0.0 || _adcd > 1.0 {
		_bcd.Log.Debug("\u0063\u006f\u006cor\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0043\u0053\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020", _adcd)
		return nil, ErrColorOutOfRange
	}
	_bdcb := NewPdfColorDeviceCMYK(_adfb, _fbfc, _fcdcd, _adcd)
	return _bdcb, nil
}

// GetCharMetrics returns the char metrics for character code `code`.
// How it works:
//  1. It calls the GetCharMetrics function for the underlying font, either a simple font or
//     a Type0 font. The underlying font GetCharMetrics() functions do direct charcode ➞  metrics
//     mappings.
//  2. If the underlying font's GetCharMetrics() doesn't have a CharMetrics for `code` then a
//     a CharMetrics with the FontDescriptor's /MissingWidth is returned.
//  3. If there is no /MissingWidth then a failure is returned.
//
// TODO(peterwilliams97) There is nothing callers can do if no CharMetrics are found so we might as
// well give them 0 width. There is no need for the bool return.
//
// TODO(gunnsth): Reconsider whether needed or if can map via GlyphName.
func (_eeeff *PdfFont) GetCharMetrics(code _abg.CharCode) (CharMetrics, bool) {
	var _eeee _da.CharMetrics
	switch _cgcec := _eeeff._eaeg.(type) {
	case *pdfFontSimple:
		if _cffe, _ffbb := _cgcec.GetCharMetrics(code); _ffbb {
			return _cffe, _ffbb
		}
	case *pdfFontType0:
		if _cafbb, _dgfda := _cgcec.GetCharMetrics(code); _dgfda {
			return _cafbb, _dgfda
		}
	case *pdfCIDFontType0:
		if _cage, _ceafe := _cgcec.GetCharMetrics(code); _ceafe {
			return _cage, _ceafe
		}
	case *pdfCIDFontType2:
		if _ecfb, _agbad := _cgcec.GetCharMetrics(code); _agbad {
			return _ecfb, _agbad
		}
	case *pdfFontType3:
		if _ccbd, _eadg := _cgcec.GetCharMetrics(code); _eadg {
			return _ccbd, _eadg
		}
	default:
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020G\u0065\u0074\u0043h\u0061\u0072\u004de\u0074\u0072i\u0063\u0073\u0020\u006e\u006f\u0074 \u0069mp\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003d\u0025\u0054\u002e", _eeeff._eaeg)
		return _eeee, false
	}
	if _dfdce, _bbec := _eeeff.GetFontDescriptor(); _bbec == nil && _dfdce != nil {
		return _da.CharMetrics{Wx: _dfdce._faeb}, true
	}
	_bcd.Log.Debug("\u0047\u0065\u0074\u0043\u0068\u0061\u0072\u004d\u0065\u0074\u0072\u0069\u0063\u0073\u003a\u0020\u004e\u006f\u0020\u006d\u0065\u0074\u0072\u0069c\u0073\u0020\u0066\u006f\u0072 \u0066\u006fn\u0074\u003d\u0025\u0073", _eeeff)
	return _eeee, false
}

// LTV represents an LTV (Long-Term Validation) client. It is used to LTV
// enable signatures by adding validation and revocation data (certificate,
// OCSP and CRL information) to the DSS dictionary of a PDF document.
//
// LTV is added through the DSS by:
//   - Adding certificates, OCSP and CRL information in the global scope of the
//     DSS. The global data is used for validating any of the signatures present
//     in the document.
//   - Adding certificates, OCSP and CRL information for a single signature,
//     through an entry in the VRI dictionary of the DSS. The added data is used
//     for validating that particular signature only. This is the recommended
//     method for adding validation data for a signature. However, this is not
//     is not possible in the same revision the signature is applied. Validation
//     data for a signature is added based on the Contents entry of the signature,
//     which is known only after the revision is written. Even if the Contents
//     are known (e.g. when signing externally), updating the DSS at that point
//     would invalidate the calculated signature. As a result, if adding LTV
//     in the same revision is a requirement, use the first method.
//     See LTV.EnableChain.
//
// The client applies both methods, when possible.
//
// If `LTV.SkipExisting` is set to true (the default), validations are
// not added for signatures which are already present in the VRI entry of the
// document's DSS dictionary.
type LTV struct {

	// CertClient is the client used to retrieve certificates.
	CertClient *_fd.CertClient

	// OCSPClient is the client used to retrieve OCSP validation information.
	OCSPClient *_fd.OCSPClient

	// CRLClient is the client used to retrieve CRL validation information.
	CRLClient *_fd.CRLClient

	// SkipExisting specifies whether existing signature validations
	// should be skipped.
	SkipExisting bool
	_cdad        *PdfAppender
	_dfcg        *DSS
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element.
func (_gagd *PdfColorspaceSpecialSeparation) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_aaaa := vals[0]
	_fcfg := []float64{_aaaa}
	_gcbdg, _gece := _gagd.TintTransform.Evaluate(_fcfg)
	if _gece != nil {
		_bcd.Log.Debug("\u0045\u0072r\u006f\u0072\u002c\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0065\u0076\u0061\u006c\u0075\u0061\u0074\u0065: \u0025\u0076", _gece)
		_bcd.Log.Trace("\u0054\u0069\u006e\u0074 t\u0072\u0061\u006e\u0073\u0066\u006f\u0072\u006d\u003a\u0020\u0025\u002b\u0076", _gagd.TintTransform)
		return nil, _gece
	}
	_bcd.Log.Trace("\u0050\u0072\u006f\u0063\u0065\u0073\u0073\u0069\u006e\u0067\u0020\u0043\u006f\u006c\u006fr\u0046\u0072\u006f\u006d\u0046\u006c\u006f\u0061\u0074\u0073\u0028\u0025\u002bv\u0029\u0020\u006f\u006e\u0020\u0041\u006c\u0074\u0065\u0072\u006e\u0061te\u0053\u0070\u0061\u0063\u0065\u003a\u0020\u0025\u0023\u0076", _gcbdg, _gagd.AlternateSpace)
	_gfefg, _gece := _gagd.AlternateSpace.ColorFromFloats(_gcbdg)
	if _gece != nil {
		_bcd.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u002c\u0020\u0066a\u0069\u006c\u0065d \u0074\u006f\u0020\u0065\u0076\u0061l\u0075\u0061\u0074\u0065\u0020\u0069\u006e\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u003a \u0025\u0076", _gece)
		return nil, _gece
	}
	return _gfefg, nil
}

func _fcgd(_bafdd _df.PdfObject) *Names {
	_abbea := _febd()
	_dbgec := _df.TraceToDirectObject(_bafdd).(*_df.PdfObjectDictionary)
	if _gcgba := _dbgec.Get("\u0044\u0065\u0073t\u0073"); _gcgba != nil {
		_abbea.Dests = _df.TraceToDirectObject(_gcgba).(*_df.PdfObjectDictionary)
	}
	if _agefd := _dbgec.Get("\u0041\u0050"); _agefd != nil {
		_abbea.AP = _df.TraceToDirectObject(_agefd).(*_df.PdfObjectDictionary)
	}
	if _fdcec := _dbgec.Get("\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"); _fdcec != nil {
		_abbea.JavaScript = _df.TraceToDirectObject(_fdcec).(*_df.PdfObjectDictionary)
	}
	if _gdbag := _dbgec.Get("\u0050\u0061\u0067e\u0073"); _gdbag != nil {
		_abbea.Pages = _df.TraceToDirectObject(_gdbag).(*_df.PdfObjectDictionary)
	}
	if _ceec := _dbgec.Get("\u0054e\u006d\u0070\u006c\u0061\u0074\u0065s"); _ceec != nil {
		_abbea.Templates = _df.TraceToDirectObject(_ceec).(*_df.PdfObjectDictionary)
	}
	if _eeaec := _dbgec.Get("\u0049\u0044\u0053"); _eeaec != nil {
		_abbea.IDS = _df.TraceToDirectObject(_eeaec).(*_df.PdfObjectDictionary)
	}
	if _ggdcd := _dbgec.Get("\u0055\u0052\u004c\u0053"); _ggdcd != nil {
		_abbea.URLS = _df.TraceToDirectObject(_ggdcd).(*_df.PdfObjectDictionary)
	}
	if _daec := _dbgec.Get("\u0045\u006d\u0062\u0065\u0064\u0064\u0065\u0064\u0046\u0069\u006c\u0065\u0073"); _daec != nil {
		_abbea.EmbeddedFiles = _df.TraceToDirectObject(_daec).(*_df.PdfObjectDictionary)
	}
	if _cadgg := _dbgec.Get("\u0041\u006c\u0074\u0065rn\u0061\u0074\u0065\u0050\u0072\u0065\u0073\u0065\u006e\u0074\u0061\u0074\u0069\u006fn\u0073"); _cadgg != nil {
		_abbea.AlternatePresentations = _df.TraceToDirectObject(_cadgg).(*_df.PdfObjectDictionary)
	}
	if _debf := _dbgec.Get("\u0052\u0065\u006e\u0064\u0069\u0074\u0069\u006f\u006e\u0073"); _debf != nil {
		_abbea.Renditions = _df.TraceToDirectObject(_debf).(*_df.PdfObjectDictionary)
	}
	return _abbea
}

// ToPdfObject implements interface PdfModel.
func (_cbcaf *PdfAnnotationLink) ToPdfObject() _df.PdfObject {
	_cbcaf.PdfAnnotation.ToPdfObject()
	_gada := _cbcaf._bfde
	_bbda := _gada.PdfObject.(*_df.PdfObjectDictionary)
	_bbda.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u004c\u0069\u006e\u006b"))
	if _cbcaf._aefc != nil && _cbcaf._aefc._aab != nil {
		_bbda.Set("\u0041", _cbcaf._aefc._aab.ToPdfObject())
	} else if _cbcaf.A != nil {
		_bbda.Set("\u0041", _cbcaf.A)
	}
	_bbda.SetIfNotNil("\u0044\u0065\u0073\u0074", _cbcaf.Dest)
	_bbda.SetIfNotNil("\u0048", _cbcaf.H)
	_bbda.SetIfNotNil("\u0050\u0041", _cbcaf.PA)
	_bbda.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _cbcaf.QuadPoints)
	_bbda.SetIfNotNil("\u0042\u0053", _cbcaf.BS)
	return _gada
}

// WriteString outputs the object as it is to be written to file.
func (_ddegg *pdfSignDictionary) WriteString() string {
	_ddegg._gcfcd = 0
	_ddegg._ecbd = 0
	_ddegg._ddfde = 0
	_ddegg._dffg = 0
	_efafe := _ef.NewBuffer(nil)
	_efafe.WriteString("\u003c\u003c")
	for _, _bgfea := range _ddegg.Keys() {
		_ffbce := _ddegg.Get(_bgfea)
		switch _bgfea {
		case "\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e":
			_efafe.WriteString(_bgfea.WriteString())
			_efafe.WriteString("\u0020")
			_ddegg._ddfde = _efafe.Len()
			_efafe.WriteString(_ffbce.WriteString())
			_efafe.WriteString("\u0020")
			_ddegg._dffg = _efafe.Len() - 1
		case "\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073":
			_efafe.WriteString(_bgfea.WriteString())
			_efafe.WriteString("\u0020")
			_ddegg._gcfcd = _efafe.Len()
			_efafe.WriteString(_ffbce.WriteString())
			_efafe.WriteString("\u0020")
			_ddegg._ecbd = _efafe.Len() - 1
		default:
			_efafe.WriteString(_bgfea.WriteString())
			_efafe.WriteString("\u0020")
			_efafe.WriteString(_ffbce.WriteString())
		}
	}
	_efafe.WriteString("\u003e\u003e")
	return _efafe.String()
}

// ToPdfObject returns colorspace in a PDF object format [name dictionary]
func (_dgbd *PdfColorspaceLab) ToPdfObject() _df.PdfObject {
	_ddbfg := _df.MakeArray()
	_ddbfg.Append(_df.MakeName("\u004c\u0061\u0062"))
	_ddca := _df.MakeDict()
	if _dgbd.WhitePoint != nil {
		_bdab := _df.MakeArray(_df.MakeFloat(_dgbd.WhitePoint[0]), _df.MakeFloat(_dgbd.WhitePoint[1]), _df.MakeFloat(_dgbd.WhitePoint[2]))
		_ddca.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _bdab)
	} else {
		_bcd.Log.Error("\u004c\u0061\u0062: \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0057h\u0069t\u0065P\u006fi\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029")
	}
	if _dgbd.BlackPoint != nil {
		_aace := _df.MakeArray(_df.MakeFloat(_dgbd.BlackPoint[0]), _df.MakeFloat(_dgbd.BlackPoint[1]), _df.MakeFloat(_dgbd.BlackPoint[2]))
		_ddca.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _aace)
	}
	if _dgbd.Range != nil {
		_edagd := _df.MakeArray(_df.MakeFloat(_dgbd.Range[0]), _df.MakeFloat(_dgbd.Range[1]), _df.MakeFloat(_dgbd.Range[2]), _df.MakeFloat(_dgbd.Range[3]))
		_ddca.Set("\u0052\u0061\u006eg\u0065", _edagd)
	}
	_ddbfg.Append(_ddca)
	if _dgbd._dced != nil {
		_dgbd._dced.PdfObject = _ddbfg
		return _dgbd._dced
	}
	return _ddbfg
}

// NewPdfAnnotationRichMedia returns a new rich media annotation.
func NewPdfAnnotationRichMedia() *PdfAnnotationRichMedia {
	_eabb := NewPdfAnnotation()
	_ddb := &PdfAnnotationRichMedia{}
	_ddb.PdfAnnotation = _eabb
	_eabb.SetContext(_ddb)
	return _ddb
}

// NewPdfDateFromTime will create a PdfDate based on the given time
func NewPdfDateFromTime(timeObj _fa.Time) (PdfDate, error) {
	_cdcd := timeObj.Format("\u002d\u0030\u0037\u003a\u0030\u0030")
	_fafaf, _ := _bc.ParseInt(_cdcd[1:3], 10, 32)
	_bdbc, _ := _bc.ParseInt(_cdcd[4:6], 10, 32)
	return PdfDate{_gfddd: int64(timeObj.Year()), _dgfba: int64(timeObj.Month()), _bgggf: int64(timeObj.Day()), _deagge: int64(timeObj.Hour()), _bbcbg: int64(timeObj.Minute()), _dgabf: int64(timeObj.Second()), _cefda: _cdcd[0], _gabf: _fafaf, _fgeefd: _bdbc}, nil
}

// A returns the value of the A component of the color.
func (_fdbfc *PdfColorCalRGB) A() float64 { return _fdbfc[0] }

// NewStructTreeRootFromPdfObject creates a new structure tree root from a PDF object.
func NewStructTreeRootFromPdfObject(obj _df.PdfObject) (*StructTreeRoot, error) {
	_gecc := _df.ResolveReference(obj)
	_fbaf, _ccdec := _df.GetDict(_gecc)
	if !_ccdec {
		return nil, _c.Errorf("\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067 \u0073\u0074\u0072uc\u0074\u0075\u0072\u0065\u0020\u0074r\u0065\u0065\u0020\u0072\u006f\u006f\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072\u0079")
	}
	_bfcgc := &StructTreeRoot{}
	_bfcgc._cgea = _df.MakeIndirectObject(_df.MakeDict())
	if _bedcc := _fbaf.Get("\u004b"); _bedcc != nil {
		_ggcbd := _df.ResolveReference(_bedcc)
		_dfacd := _df.ResolveReferencesDeep(_ggcbd, nil)
		if _dfacd != nil {
			_bcd.Log.Debug("\u0045\u0072\u0072\u006fr\u0020\u0072\u0065\u0073\u006f\u006c\u0076\u0069\u006e\u0067 \u004b \u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0025\u0076", _dfacd)
		}
		_bfcgc.K = []*KDict{}
		if _aabee, _fabeg := _df.GetArray(_ggcbd); _fabeg {
			for _gddda := 0; _gddda < _aabee.Len(); _gddda++ {
				_dggea := _aabee.Get(_gddda)
				_fefcc, _bcebc := _gadaf(_dggea)
				if _bcebc != nil {
					return nil, _bcebc
				}
				_bfcgc.K = append(_bfcgc.K, _fefcc)
			}
		} else {
			_gcdaf, _ddcb := _gadaf(_ggcbd)
			if _ddcb != nil {
				return nil, _ddcb
			}
			_bfcgc.K = append(_bfcgc.K, _gcdaf)
		}
	}
	if _daddge := _fbaf.Get("\u0049\u0044\u0054\u0072\u0065\u0065"); _daddge != nil {
		_bfcgc.IDTree = _dggcf(_daddge)
	}
	if _aeaeg := _fbaf.Get("\u0050\u0061\u0072\u0065\u006e\u0074\u0054\u0072\u0065\u0065"); _aeaeg != nil {
		_eacgf := _df.ResolveReference(_aeaeg)
		if _fbdaf, _geggf := _df.GetDict(_eacgf); _geggf {
			_bfcgc.ParentTree = _fbdaf
		}
	}
	if _bggfe := _fbaf.Get("\u0050\u0061\u0072\u0065\u006e\u0074\u0054\u0072\u0065\u0065\u004e\u0065x\u0074\u004b\u0065\u0079"); _bggfe != nil {
		_, _egadd := _df.GetInt(_bggfe)
		if _egadd {
			_gfgec, _cfag := _df.GetNumberAsInt64(_bggfe)
			if _cfag != nil {
				return nil, _cfag
			}
			_bfcgc.ParentTreeNextKey = _gfgec
		}
	}
	if _gadcf := _fbaf.Get("\u0052o\u006c\u0065\u004d\u0061\u0070"); _gadcf != nil {
		switch _ffbda := _gadcf.(type) {
		case *_df.PdfIndirectObject:
			if _dcee, _dedee := _df.GetDict(_ffbda.PdfObject); _dedee {
				_bfcgc.RoleMap = _dcee
			}
		case *_df.PdfObjectDictionary:
			_bfcgc.RoleMap = _ffbda
		case *_df.PdfObjectString:
			_bfcgc.RoleMap = _ffbda
		}
	}
	if _dbbdb := _fbaf.Get("\u0043\u006c\u0061\u0073\u0073\u004d\u0061\u0070"); _dbbdb != nil {
		if _fdafg, _bacf := _df.GetDict(_dbbdb); _bacf {
			_bfcgc.ClassMap = _fdafg
		}
	}
	return _bfcgc, nil
}

// PdfActionGoTo3DView represents a GoTo3DView action.
type PdfActionGoTo3DView struct {
	*PdfAction
	TA _df.PdfObject
	V  _df.PdfObject
}

// IsCheckbox returns true if the button field represents a checkbox, false otherwise.
func (_gaab *PdfFieldButton) IsCheckbox() bool { return _gaab.GetType() == ButtonTypeCheckbox }

func _efedf() string { _gcdec.Lock(); defer _gcdec.Unlock(); return _geabeg }

// SetForms sets the Acroform for a PDF file.
func (_eedc *PdfWriter) SetForms(form *PdfAcroForm) error { _eedc._cecbge = form; return nil }

// Evaluate runs the function. Input is [x1 x2 x3].
func (_dbga *PdfFunctionType4) Evaluate(xVec []float64) ([]float64, error) {
	if _dbga._bdage == nil {
		_dbga._bdage = _eg.NewPSExecutor(_dbga.Program)
	}
	var _fbedb []_eg.PSObject
	for _, _gbged := range xVec {
		_fbedb = append(_fbedb, _eg.MakeReal(_gbged))
	}
	_faecg, _cbfee := _dbga._bdage.Execute(_fbedb)
	if _cbfee != nil {
		return nil, _cbfee
	}
	_ggggg, _cbfee := _eg.PSObjectArrayToFloat64Array(_faecg)
	if _cbfee != nil {
		return nil, _cbfee
	}
	return _ggggg, nil
}

func _bgde(_degaa []byte) ([]byte, error) {
	_cbffc := _ga.New()
	if _, _ggead := _bdd.Copy(_cbffc, _ef.NewReader(_degaa)); _ggead != nil {
		return nil, _ggead
	}
	return _cbffc.Sum(nil), nil
}

// PdfShading represents a shading dictionary. There are 7 types of shading,
// indicatedby the shading type variable:
// 1: Function-based shading.
// 2: Axial shading.
// 3: Radial shading.
// 4: Free-form Gouraud-shaded triangle mesh.
// 5: Lattice-form Gouraud-shaded triangle mesh.
// 6: Coons patch mesh.
// 7: Tensor-product patch mesh.
// types 4-7 are contained in a stream object, where the dictionary is given by the stream dictionary.
type PdfShading struct {
	ShadingType *_df.PdfObjectInteger
	ColorSpace  PdfColorspace
	Background  *_df.PdfObjectArray
	BBox        *PdfRectangle
	AntiAlias   *_df.PdfObjectBool
	_dggab      PdfModel
	_bgdag      _df.PdfObject
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_ggceg *PdfShadingType2) ToPdfObject() _df.PdfObject {
	_ggceg.PdfShading.ToPdfObject()
	_bgdca, _baeea := _ggceg.getShadingDict()
	if _baeea != nil {
		_bcd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _bgdca == nil {
		_bcd.Log.Error("\u0053\u0068\u0061\u0064in\u0067\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		return nil
	}
	if _ggceg.Coords != nil {
		_bgdca.Set("\u0043\u006f\u006f\u0072\u0064\u0073", _ggceg.Coords)
	}
	if _ggceg.Domain != nil {
		_bgdca.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _ggceg.Domain)
	}
	if _ggceg.Function != nil {
		if len(_ggceg.Function) == 1 {
			_bgdca.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _ggceg.Function[0].ToPdfObject())
		} else {
			_agbddb := _df.MakeArray()
			for _, _ecab := range _ggceg.Function {
				_agbddb.Append(_ecab.ToPdfObject())
			}
			_bgdca.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _agbddb)
		}
	}
	if _ggceg.Extend != nil {
		_bgdca.Set("\u0045\u0078\u0074\u0065\u006e\u0064", _ggceg.Extend)
	}
	return _ggceg._bgdag
}

// NewXObjectImage returns a new XObjectImage.
func NewXObjectImage() *XObjectImage {
	_cccgf := &XObjectImage{}
	_fbabdd := &_df.PdfObjectStream{}
	_fbabdd.PdfObjectDictionary = _df.MakeDict()
	_cccgf._fgdgd = _fbabdd
	return _cccgf
}

// GetPageNumber returns the page number that has been assigned to the K object.
func (_cgcff *KDict) GetPageNumber() int64 { return _cgcff._cabee }

func _dggcf(_bbdad _df.PdfObject) *IDTree {
	_bbdad = _df.ResolveReference(_bbdad)
	_ecffd := _df.MakeArray()
	_cbfcd := _df.MakeArray()
	_gffdea := []*IDTree{}
	if _dedfd, _fddfb := _df.GetDict(_bbdad); _fddfb {
		if _ffdde := _dedfd.Get("\u004e\u0061\u006de\u0073"); _ffdde != nil {
			_ffdde = _df.ResolveReference(_ffdde)
			if _eegef, _abfee := _df.GetArray(_ffdde); _abfee {
				for _, _afdgb := range _eegef.Elements() {
					_ecffd.Append(_afdgb)
				}
			}
		}
		if _begee := _dedfd.Get("\u004c\u0069\u006d\u0069\u0074\u0073"); _begee != nil {
			_begee = _df.ResolveReference(_begee)
			if _gbfcd, _bbcec := _df.GetArray(_begee); _bbcec {
				for _ebae := 0; _ebae < 2; _ebae++ {
					_cbfcd.Append(_gbfcd.Get(_ebae))
				}
			}
		}
		if _gfgbbb := _dedfd.Get("\u004b\u0069\u0064\u0073"); _gfgbbb != nil {
			_gfgbbb = _df.ResolveReference(_gfgbbb)
			if _acgdf, _fbegcb := _df.GetArray(_gfgbbb); _fbegcb {
				for _, _caccb := range _acgdf.Elements() {
					_fgggae := _dggcf(_caccb)
					_gffdea = append(_gffdea, _fgggae)
				}
			}
		}
	}
	_dedbe := &IDTree{Names: _ecffd, Limits: _cbfcd}
	if len(_gffdea) > 0 {
		_dedbe.Kids = _gffdea
	}
	return _dedbe
}

// NewPdfActionGoTo3DView returns a new "goTo3DView" action.
func NewPdfActionGoTo3DView() *PdfActionGoTo3DView {
	_ca := NewPdfAction()
	_ce := &PdfActionGoTo3DView{}
	_ce.PdfAction = _ca
	_ca.SetContext(_ce)
	return _ce
}

func (_cagfe *PdfWriter) writeDocumentVersion() {
	if _cagfe._gebfg {
		_cagfe.writeString("\u000a")
	} else {
		_cagfe.writeString(_c.Sprintf("\u0025\u0025\u0050D\u0046\u002d\u0025\u0064\u002e\u0025\u0064\u000a", _cagfe._aeffd.Major, _cagfe._aeffd.Minor))
		_cagfe.writeString("\u0025\u00e2\u00e3\u00cf\u00d3\u000a")
	}
}

// NewPdfPageResourcesFromDict creates and returns a new PdfPageResources object
// from the input dictionary.
func NewPdfPageResourcesFromDict(dict *_df.PdfObjectDictionary) (*PdfPageResources, error) {
	_eagab := NewPdfPageResources()
	if _gfgdd := dict.Get("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e"); _gfgdd != nil {
		_eagab.ExtGState = _gfgdd
	}
	if _egdab := dict.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065"); _egdab != nil && !_df.IsNullObject(_egdab) {
		_eagab.ColorSpace = _egdab
	}
	if _aagbd := dict.Get("\u0050a\u0074\u0074\u0065\u0072\u006e"); _aagbd != nil {
		_eagab.Pattern = _aagbd
	}
	if _decda := dict.Get("\u0053h\u0061\u0064\u0069\u006e\u0067"); _decda != nil {
		_eagab.Shading = _decda
	}
	if _ffabd := dict.Get("\u0058O\u0062\u006a\u0065\u0063\u0074"); _ffabd != nil {
		_eagab.XObject = _ffabd
	}
	if _befaf := _df.ResolveReference(dict.Get("\u0046\u006f\u006e\u0074")); _befaf != nil {
		_eagab.Font = _befaf
	}
	if _adefb := dict.Get("\u0050r\u006f\u0063\u0053\u0065\u0074"); _adefb != nil {
		_eagab.ProcSet = _adefb
	}
	if _cgfbd := dict.Get("\u0050\u0072\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073"); _cgfbd != nil {
		_eagab.Properties = _cgfbd
	}
	return _eagab, nil
}

// ImageToRGB converts Lab colorspace image to RGB and returns the result.
func (_egbca *PdfColorspaceLab) ImageToRGB(img Image) (Image, error) {
	_dbbgb := func(_ddec float64) float64 {
		if _ddec >= 6.0/29 {
			return _ddec * _ddec * _ddec
		}
		return 108.0 / 841 * (_ddec - 4.0/29.0)
	}
	_fdda := img._bebgb
	if len(_fdda) != 6 {
		_bcd.Log.Trace("\u0049\u006d\u0061\u0067\u0065\u0020\u002d\u0020\u004c\u0061\u0062\u0020\u0044e\u0063\u006f\u0064\u0065\u0020\u0072\u0061\u006e\u0067e\u0020\u0021\u003d\u0020\u0036\u002e\u002e\u002e\u0020\u0075\u0073\u0065\u0020\u005b0\u0020\u0031\u0030\u0030\u0020\u0061\u006d\u0069\u006e\u0020\u0061\u006d\u0061\u0078\u0020\u0062\u006d\u0069\u006e\u0020\u0062\u006d\u0061\u0078\u005d\u0020\u0064\u0065\u0066\u0061u\u006c\u0074\u0020\u0064\u0065\u0063\u006f\u0064\u0065 \u0061\u0072r\u0061\u0079")
		_fdda = _egbca.DecodeArray()
	}
	_gdfa := _aff.NewReader(img.getBase())
	_debc := _bge.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, img._gebab, img._bebgb)
	_dcfcd := _aff.NewWriter(_debc)
	_bffb := _faf.Pow(2, float64(img.BitsPerComponent)) - 1
	_decd := make([]uint32, 3)
	var (
		_bad                                              error
		Ls, As, Bs, L, M, N, X, Y, Z, _bdba, _bfea, _ccad float64
	)
	for {
		_bad = _gdfa.ReadSamples(_decd)
		if _bad == _bdd.EOF {
			break
		} else if _bad != nil {
			return img, _bad
		}
		Ls = float64(_decd[0]) / _bffb
		As = float64(_decd[1]) / _bffb
		Bs = float64(_decd[2]) / _bffb
		Ls = _bge.LinearInterpolate(Ls, 0.0, 1.0, _fdda[0], _fdda[1])
		As = _bge.LinearInterpolate(As, 0.0, 1.0, _fdda[2], _fdda[3])
		Bs = _bge.LinearInterpolate(Bs, 0.0, 1.0, _fdda[4], _fdda[5])
		L = (Ls+16)/116 + As/500
		M = (Ls + 16) / 116
		N = (Ls+16)/116 - Bs/200
		X = _egbca.WhitePoint[0] * _dbbgb(L)
		Y = _egbca.WhitePoint[1] * _dbbgb(M)
		Z = _egbca.WhitePoint[2] * _dbbgb(N)
		_bdba = 3.240479*X + -1.537150*Y + -0.498535*Z
		_bfea = -0.969256*X + 1.875992*Y + 0.041556*Z
		_ccad = 0.055648*X + -0.204043*Y + 1.057311*Z
		_bdba = _faf.Min(_faf.Max(_bdba, 0), 1.0)
		_bfea = _faf.Min(_faf.Max(_bfea, 0), 1.0)
		_ccad = _faf.Min(_faf.Max(_ccad, 0), 1.0)
		_decd[0] = uint32(_bdba * _bffb)
		_decd[1] = uint32(_bfea * _bffb)
		_decd[2] = uint32(_ccad * _bffb)
		if _bad = _dcfcd.WriteSamples(_decd); _bad != nil {
			return img, _bad
		}
	}
	return _agbg(&_debc), nil
}

// SetLocation sets the `Location` field of the signature.
func (_dbbag *PdfSignature) SetLocation(location string) {
	_dbbag.Location = _df.MakeEncodedString(location, true)
}

// SetFitWindow sets the value of the fitWindow flag.
func (_ffdbe *ViewerPreferences) SetFitWindow(fitWindow bool) { _ffdbe._eadcd = &fitWindow }

func (_adaf *PdfWriter) makeOffSetReference(_cfdbaa int64) {
	_cgfac := _c.Sprintf("\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u000a\u0025\u0064\u000a", _cfdbaa)
	_adaf.writeString(_cgfac)
	_adaf.writeString("\u0025\u0025\u0045\u004f\u0046\u000a")
}

// SetPickTrayByPDFSize sets the value of the pickTrayByPDFSize flag.
func (_agagc *ViewerPreferences) SetPickTrayByPDFSize(pickTrayByPDFSize bool) {
	_agagc._cgbe = &pickTrayByPDFSize
}

// NewXObjectForm creates a brand new XObject Form. Creates a new underlying PDF object stream primitive.
func NewXObjectForm() *XObjectForm {
	_gebdd := &XObjectForm{}
	_fdbcef := &_df.PdfObjectStream{}
	_fdbcef.PdfObjectDictionary = _df.MakeDict()
	_gebdd._bbfeg = _fdbcef
	return _gebdd
}

// NewPdfActionThread returns a new "thread" action.
func NewPdfActionThread() *PdfActionThread {
	_fgc := NewPdfAction()
	_gad := &PdfActionThread{}
	_gad.PdfAction = _fgc
	_fgc.SetContext(_gad)
	return _gad
}

// GetCustomInfo returns a custom info value for the specified name.
func (_ccfg *PdfInfo) GetCustomInfo(name string) *_df.PdfObjectString {
	var _fgffd *_df.PdfObjectString
	if _ccfg._bcec == nil {
		return _fgffd
	}
	if _defc, _ceg := _ccfg._bcec.Get(*_df.MakeName(name)).(*_df.PdfObjectString); _ceg {
		_fgffd = _defc
	}
	return _fgffd
}

type pdfFontType3 struct {
	fontCommon
	_ecfc *_df.PdfIndirectObject

	// These fields are specific to Type 3 fonts.
	CharProcs  _df.PdfObject
	Encoding   _df.PdfObject
	FontBBox   _df.PdfObject
	FontMatrix _df.PdfObject
	FirstChar  _df.PdfObject
	LastChar   _df.PdfObject
	Widths     _df.PdfObject
	Resources  _df.PdfObject
	_cgfgg     map[_abg.CharCode]float64
	_ceed      _abg.TextEncoder
}

// ColorToRGB converts a ICCBased color to an RGB color.
func (_gfgg *PdfColorspaceICCBased) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _gfgg.Alternate == nil {
		_bcd.Log.Debug("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		if _gfgg.N == 1 {
			_bcd.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061y\u0020\u0028\u004e\u003d\u0031\u0029")
			_ffdfg := NewPdfColorspaceDeviceGray()
			return _ffdfg.ColorToRGB(color)
		} else if _gfgg.N == 3 {
			_bcd.Log.Debug("\u0049\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006eg\u0020\u0044\u0065\u0076\u0069\u0063e\u0052\u0047B\u0020\u0028N\u003d3\u0029")
			return color, nil
		} else if _gfgg.N == 4 {
			_bcd.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059K\u0020\u0028\u004e\u003d\u0034\u0029")
			_ceef := NewPdfColorspaceDeviceCMYK()
			return _ceef.ColorToRGB(color)
		} else {
			return nil, _deb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	_bcd.Log.Trace("\u0049\u0043\u0043 \u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0069\u0076\u0065\u003a\u0020\u0025\u0023\u0076", _gfgg)
	return _gfgg.Alternate.ColorToRGB(color)
}

func NewViewerPreferencesFromPdfObject(obj _df.PdfObject) (*ViewerPreferences, error) {
	_adcga := _df.ResolveReference(obj)
	_gaae, _dgcag := _df.GetDict(_adcga)
	if !_dgcag {
		return nil, _c.Errorf("e\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0076i\u0065\u0077\u0065\u0072\u0020\u0070\u0072ef\u0065\u0072\u0065\u006ec\u0065\u0073\u0020\u0069\u0073\u0020\u006e\u006f\u0074 a\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_dgdebe := NewViewerPreferences()
	if _cafag := _gaae.Get("H\u0069\u0064\u0065\u0054\u006f\u006f\u006c\u0062\u0061\u0072"); _cafag != nil {
		if _eebdgc, _badb := _df.GetBool(_cafag); _badb {
			_dgdebe._bbfdd = (*bool)(_eebdgc)
		}
	}
	if _dccgf := _gaae.Get("H\u0069\u0064\u0065\u004d\u0065\u006e\u0075\u0062\u0061\u0072"); _dccgf != nil {
		if _ddbab, _fgbfg := _df.GetBool(_dccgf); _fgbfg {
			_dgdebe._abebaec = (*bool)(_ddbab)
		}
	}
	if _faaf := _gaae.Get("\u0048\u0069\u0064e\u0057\u0069\u006e\u0064\u006f\u0077\u0055\u0049"); _faaf != nil {
		if _dcgbe, _ceccae := _df.GetBool(_faaf); _ceccae {
			_dgdebe._dbfebfg = (*bool)(_dcgbe)
		}
	}
	if _becaf := _gaae.Get("\u0046i\u0074\u0057\u0069\u006e\u0064\u006fw"); _becaf != nil {
		if _dececf, _bddcb := _df.GetBool(_becaf); _bddcb {
			_dgdebe._eadcd = (*bool)(_dececf)
		}
	}
	if _bfaefa := _gaae.Get("\u0043\u0065\u006et\u0065\u0072\u0057\u0069\u006e\u0064\u006f\u0077"); _bfaefa != nil {
		if _efcee, _eaafa := _df.GetBool(_bfaefa); _eaafa {
			_dgdebe._agceg = (*bool)(_efcee)
		}
	}
	if _edfbbb := _gaae.Get("\u0044i\u0073p\u006c\u0061\u0079\u0044\u006f\u0063\u0054\u0069\u0074\u006c\u0065"); _edfbbb != nil {
		if _gcca, _bgeag := _df.GetBool(_edfbbb); _bgeag {
			_dgdebe._bfggg = (*bool)(_gcca)
		}
	}
	if _gbggf := _gaae.Get("N\u006f\u006e\u0046\u0075ll\u0053c\u0072\u0065\u0065\u006e\u0050a\u0067\u0065\u004d\u006f\u0064\u0065"); _gbggf != nil {
		if _cfbfcd, _dbfab := _df.GetName(_gbggf); _dbfab {
			_dgdebe._ebbf = NonFullScreenPageMode(*_cfbfcd)
		}
	}
	if _ccgbb := _gaae.Get("\u0044i\u0072\u0065\u0063\u0074\u0069\u006fn"); _ccgbb != nil {
		if _gbefc, _abagb := _df.GetName(_ccgbb); _abagb {
			_dgdebe._cggbe = Direction(*_gbefc)
		}
	}
	if _adae := _gaae.Get("\u0056\u0069\u0065\u0077\u0041\u0072\u0065\u0061"); _adae != nil {
		if _cbebc, _aabb := _df.GetName(_adae); _aabb {
			_dgdebe._ffbad = PageBoundary(*_cbebc)
		}
	}
	if _gbcdc := _gaae.Get("\u0056\u0069\u0065\u0077\u0043\u006c\u0069\u0070"); _gbcdc != nil {
		if _aeabc, _fbcaf := _df.GetName(_gbcdc); _fbcaf {
			_dgdebe._geabe = PageBoundary(*_aeabc)
		}
	}
	if _ggagg := _gaae.Get("\u0050r\u0069\u006e\u0074\u0041\u0072\u0065a"); _ggagg != nil {
		if _bcfaf, _aeecg := _df.GetName(_ggagg); _aeecg {
			_dgdebe._fbede = PageBoundary(*_bcfaf)
		}
	}
	if _gdffd := _gaae.Get("\u0050r\u0069\u006e\u0074\u0043\u006c\u0069p"); _gdffd != nil {
		if _cdfd, _cdade := _df.GetName(_gdffd); _cdade {
			_dgdebe._edeeb = PageBoundary(*_cdfd)
		}
	}
	if _adee := _gaae.Get("\u0050\u0072\u0069n\u0074\u0053\u0063\u0061\u006c\u0069\u006e\u0067"); _adee != nil {
		if _deeb, _cacf := _df.GetName(_adee); _cacf {
			_dgdebe._faefa = PrintScaling(*_deeb)
		}
	}
	if _decef := _gaae.Get("\u0044\u0075\u0070\u006c\u0065\u0078"); _decef != nil {
		if _dfbda, _adgbb := _df.GetName(_decef); _adgbb {
			_dgdebe._aecfg = Duplex(*_dfbda)
		}
	}
	if _fbgbd := _gaae.Get("\u0050\u0069\u0063\u006b\u0054\u0072\u0061\u0079\u0042\u0079\u0050\u0044F\u0053\u0069\u007a\u0065"); _fbgbd != nil {
		if _aacfd, _addde := _df.GetBool(_fbgbd); _addde {
			_dgdebe._cgbe = (*bool)(_aacfd)
		}
	}
	if _fcfea := _gaae.Get("\u0050\u0072\u0069\u006e\u0074\u0050\u0061\u0067\u0065R\u0061\u006e\u0067\u0065"); _fcfea != nil {
		if _eeccc, _adge := _df.GetArray(_fcfea); _adge {
			_dgdebe._dafbb = make([]int, _eeccc.Len())
			for _gefece := range _dgdebe._dafbb {
				if _decddf := _eeccc.Get(_gefece); _decddf != nil {
					if _gfadg, _cbge := _df.GetInt(_decddf); _cbge {
						_dgdebe._dafbb[_gefece] = int(*_gfadg)
					}
				}
			}
		}
	}
	if _beea := _gaae.Get("\u004eu\u006d\u0043\u006f\u0070\u0069\u0065s"); _beea != nil {
		if _egbfec, _befdg := _df.GetInt(_beea); _befdg {
			_dgdebe._edded = int(*_egbfec)
		}
	}
	return _dgdebe, nil
}

// SetSamples convert samples to byte-data and sets for the image.
// NOTE: The method resamples the data and this could lead to high memory usage,
// especially on large images. It should be used only when it is not possible
// to work with the image byte data directly.
func (_abff *Image) SetSamples(samples []uint32) {
	if _abff.BitsPerComponent < 8 {
		samples = _abff.samplesAddPadding(samples)
	}
	_eaafd := _aff.ResampleUint32(samples, int(_abff.BitsPerComponent), 8)
	_ffdfe := make([]byte, len(_eaafd))
	for _fadag, _gecddf := range _eaafd {
		_ffdfe[_fadag] = byte(_gecddf)
	}
	_abff.Data = _ffdfe
}

// PdfColorspaceSpecialPattern is a Pattern colorspace.
// Can be defined either as /Pattern or with an underlying colorspace [/Pattern cs].
type PdfColorspaceSpecialPattern struct {
	UnderlyingCS PdfColorspace
	_gbee        *_df.PdfIndirectObject
}

// PdfColorCalGray represents a CalGray colorspace.
type PdfColorCalGray float64

// EnableAll LTV enables all signatures in the PDF document.
// The signing certificate chain is extracted from each signature dictionary.
// Optionally, additional certificates can be specified through the
// `extraCerts` parameter. The LTV client attempts to build the certificate
// chain up to a trusted root by downloading any missing certificates.
func (_febgc *LTV) EnableAll(extraCerts []*_ed.Certificate) error {
	_ccdcc := _febgc._cdad._abf.AcroForm
	for _, _egbfg := range _ccdcc.AllFields() {
		_bbcbc, _ := _egbfg.GetContext().(*PdfFieldSignature)
		if _bbcbc == nil {
			continue
		}
		_agbaf := _bbcbc.V
		if _fadcf := _febgc.validateSig(_agbaf); _fadcf != nil {
			_bcd.Log.Debug("\u0057\u0041\u0052N\u003a\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020f\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076", _fadcf)
		}
		if _afbeg := _febgc.Enable(_agbaf, extraCerts); _afbeg != nil {
			return _afbeg
		}
	}
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_fgf *PdfAction) ToPdfObject() _df.PdfObject {
	_eda := _fgf._gcf
	_cgg := _eda.PdfObject.(*_df.PdfObjectDictionary)
	_cgg.Clear()
	_cgg.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0041\u0063\u0074\u0069\u006f\u006e"))
	_cgg.SetIfNotNil("\u0053", _fgf.S)
	_cgg.SetIfNotNil("\u004e\u0065\u0078\u0074", _fgf.Next)
	return _eda
}

func (_caccd *PdfShading) getShadingDict() (*_df.PdfObjectDictionary, error) {
	_fdfd := _caccd._bgdag
	if _gcccf, _fcagc := _fdfd.(*_df.PdfIndirectObject); _fcagc {
		_cbac, _bcbae := _gcccf.PdfObject.(*_df.PdfObjectDictionary)
		if !_bcbae {
			return nil, _df.ErrTypeError
		}
		return _cbac, nil
	} else if _gfffbe, _fdca := _fdfd.(*_df.PdfObjectStream); _fdca {
		return _gfffbe.PdfObjectDictionary, nil
	} else if _cbgd, _gagda := _fdfd.(*_df.PdfObjectDictionary); _gagda {
		return _cbgd, nil
	} else {
		_bcd.Log.Debug("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0061\u0063\u0063\u0065s\u0073\u0020\u0073\u0068\u0061\u0064\u0069n\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079")
		return nil, _df.ErrTypeError
	}
}

// AddContentStreamByString adds content stream by string. Puts the content
// string into a stream object and points the content stream towards it.
func (_ffeee *PdfPage) AddContentStreamByString(contentStr string) error {
	_eedf, _gbgb := _df.MakeStream([]byte(contentStr), _df.NewFlateEncoder())
	if _gbgb != nil {
		return _gbgb
	}
	if _ffeee.Contents == nil {
		_ffeee.Contents = _eedf
	} else {
		_gaebf := _df.TraceToDirectObject(_ffeee.Contents)
		_dbcbd, _cebc := _gaebf.(*_df.PdfObjectArray)
		if !_cebc {
			_dbcbd = _df.MakeArray(_gaebf)
		}
		_dbcbd.Append(_eedf)
		_ffeee.Contents = _dbcbd
	}
	return nil
}

// GetColorspaceByName returns the colorspace with the specified name from the page resources.
func (_eebfg *PdfPageResources) GetColorspaceByName(keyName _df.PdfObjectName) (PdfColorspace, bool) {
	_gcggb, _acace := _eebfg.GetColorspaces()
	if _acace != nil {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _acace)
		return nil, false
	}
	if _gcggb == nil {
		return nil, false
	}
	_dfdab, _gfefb := _gcggb.Colorspaces[string(keyName)]
	if !_gfefb {
		return nil, false
	}
	return _dfdab, true
}

func _bfgba(_begac *XObjectImage) error {
	if _begac.SMask == nil {
		return nil
	}
	_bgdfc, _bgaag := _begac.SMask.(*_df.PdfObjectStream)
	if !_bgaag {
		_bcd.Log.Debug("\u0053\u004da\u0073\u006b\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0053\u0074re\u0061\u006d")
		return _df.ErrTypeError
	}
	_effcc := _bgdfc.PdfObjectDictionary
	_fggfb := _effcc.Get("\u004d\u0061\u0074t\u0065")
	if _fggfb == nil {
		return nil
	}
	_egeaf, _cgbdgb := _egebb(_fggfb.(*_df.PdfObjectArray))
	if _cgbdgb != nil {
		return _cgbdgb
	}
	_geecd := _df.MakeArrayFromFloats([]float64{_egeaf})
	_effcc.SetIfNotNil("\u004d\u0061\u0074t\u0065", _geecd)
	return nil
}

func _aeda(_deec *_df.PdfObjectDictionary, _ccaaa *fontCommon, _ebfcb _abg.TextEncoder) (*pdfFontSimple, error) {
	_aaeg := _dcgg(_ccaaa)
	_aaeg._geecc = _ebfcb
	if _ebfcb == nil {
		_ffgg := _deec.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r")
		if _ffgg == nil {
			_ffgg = _df.MakeInteger(0)
		}
		_aaeg.FirstChar = _ffgg
		_fccb, _acde := _df.GetIntVal(_ffgg)
		if !_acde {
			_bcd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0046i\u0072s\u0074C\u0068\u0061\u0072\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _ffgg)
			return nil, _df.ErrTypeError
		}
		_begc := _abg.CharCode(_fccb)
		_ffgg = _deec.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072")
		if _ffgg == nil {
			_ffgg = _df.MakeInteger(255)
		}
		_aaeg.LastChar = _ffgg
		_fccb, _acde = _df.GetIntVal(_ffgg)
		if !_acde {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004c\u0061\u0073\u0074\u0043h\u0061\u0072\u0020\u0074\u0079\u0070\u0065 \u0028\u0025\u0054\u0029", _ffgg)
			return nil, _df.ErrTypeError
		}
		_acdfa := _abg.CharCode(_fccb)
		_aaeg._ffefd = make(map[_abg.CharCode]float64)
		_ffgg = _deec.Get("\u0057\u0069\u0064\u0074\u0068\u0073")
		if _ffgg != nil {
			_aaeg.Widths = _ffgg
			_cafbg, _eddb := _df.GetArray(_ffgg)
			if !_eddb {
				_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020W\u0069\u0064t\u0068\u0073\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079 \u0028\u0025\u0054\u0029", _ffgg)
				return nil, _df.ErrTypeError
			}
			_efbg, _ggcb := _cafbg.ToFloat64Array()
			if _ggcb != nil {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0077\u0069d\u0074\u0068\u0073\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
				return nil, _ggcb
			}
			if len(_efbg) != int(_acdfa-_begc+1) {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0074\u0068s\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0025\u0064 \u0028\u0025\u0064\u0029", _acdfa-_begc+1, len(_efbg))
				return nil, _df.ErrRangeError
			}
			for _gfdaa, _gbdf := range _efbg {
				_aaeg._ffefd[_begc+_abg.CharCode(_gfdaa)] = _gbdf
			}
		}
	}
	_aaeg.Encoding = _df.TraceToDirectObject(_deec.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
	return _aaeg, nil
}

// PdfActionTrans represents a trans action.
type PdfActionTrans struct {
	*PdfAction
	Trans _df.PdfObject
}

// NewPdfWriter initializes a new PdfWriter.
func NewPdfWriter() PdfWriter {
	_abffg := PdfWriter{}
	_abffg._aadfbg = map[_df.PdfObject]struct{}{}
	_abffg._ceeac = []_df.PdfObject{}
	_abffg._acgefe = map[_df.PdfObject][]*_df.PdfObjectDictionary{}
	_abffg._dfadb = map[_df.PdfObject]struct{}{}
	_abffg._aeffd.Major = 1
	_abffg._aeffd.Minor = 3
	_dbggb := _df.MakeDict()
	_dcgbf := []struct {
		_dgdbc _df.PdfObjectName
		_bbae  string
	}{{"\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072", _dafcf()}, {"\u0043r\u0065\u0061\u0074\u006f\u0072", _gfdeg()}, {"\u0041\u0075\u0074\u0068\u006f\u0072", _efedf()}, {"\u0053u\u0062\u006a\u0065\u0063\u0074", _fagab()}, {"\u0054\u0069\u0074l\u0065", _bbdeg()}, {"\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073", _gfeef()}}
	for _, _fgbfd := range _dcgbf {
		if _fgbfd._bbae != "" {
			_dbggb.Set(_fgbfd._dgdbc, _df.MakeString(_fgbfd._bbae))
		}
	}
	if _dgabd := _ddfaee(); !_dgabd.IsZero() {
		if _agbf, _egbae := NewPdfDateFromTime(_dgabd); _egbae == nil {
			_dbggb.Set("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _agbf.ToPdfObject())
		}
	}
	if _edca := _ggebfd(); !_edca.IsZero() {
		if _efafa, _aagff := NewPdfDateFromTime(_edca); _aagff == nil {
			_dbggb.Set("\u004do\u0064\u0044\u0061\u0074\u0065", _efafa.ToPdfObject())
		}
	}
	_eeecdc := _df.PdfIndirectObject{}
	_eeecdc.PdfObject = _dbggb
	_abffg._caefe = &_eeecdc
	_abffg.addObject(&_eeecdc)
	_fccdc := _df.PdfIndirectObject{}
	_cbbdd := _df.MakeDict()
	_cbbdd.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0043a\u0074\u0061\u006c\u006f\u0067"))
	_fccdc.PdfObject = _cbbdd
	_abffg._aaag = &_fccdc
	_abffg.addObject(_abffg._aaag)
	_cbedc, _gabaef := _cbdee("\u0077")
	if _gabaef != nil {
		_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gabaef)
	}
	_abffg._gcfcfa = _cbedc
	_aaaae := _df.PdfIndirectObject{}
	_bbbb := _df.MakeDict()
	_bbbb.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0050\u0061\u0067e\u0073"))
	_bbagf := _df.PdfObjectArray{}
	_bbbb.Set("\u004b\u0069\u0064\u0073", &_bbagf)
	_bbbb.Set("\u0043\u006f\u0075n\u0074", _df.MakeInteger(0))
	_aaaae.PdfObject = _bbbb
	_abffg._ggdac = &_aaaae
	_abffg._fddef = map[_df.PdfObject]struct{}{}
	_abffg._aaadf = []*_df.PdfIndirectObject{}
	_abffg.addObject(_abffg._ggdac)
	_cbbdd.Set("\u0050\u0061\u0067e\u0073", &_aaaae)
	_abffg._gdee = _cbbdd
	_bcd.Log.Trace("\u0043\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0025\u0073", _fccdc)
	return _abffg
}

// WatermarkImageOptions contains options for configuring the image watermark process.
type WatermarkImageOptions struct {
	Alpha               float64
	FitToWidth          bool
	PreserveAspectRatio bool
	Angle               float64
}

// ToPdfObject implements interface PdfModel.
func (_dabdf *PdfAnnotationTrapNet) ToPdfObject() _df.PdfObject {
	_dabdf.PdfAnnotation.ToPdfObject()
	_bdgcc := _dabdf._bfde
	_ebb := _bdgcc.PdfObject.(*_df.PdfObjectDictionary)
	_ebb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0054r\u0061\u0070\u004e\u0065\u0074"))
	return _bdgcc
}

// StringToCharcodeBytes maps the provided string runes to charcode bytes and
// it returns the resulting slice of bytes, along with the number of runes
// which could not be converted. If the number of misses is 0, all string runes
// were successfully converted.
func (_fdddb *PdfFont) StringToCharcodeBytes(str string) ([]byte, int) {
	return _fdddb.RunesToCharcodeBytes([]rune(str))
}

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_dagef *PdfWriter) SetOptimizer(optimizer Optimizer) { _dagef._bgagb = optimizer }

// SetDocInfo set document info.
// This will overwrite any globally declared document info.
func (_feggf *PdfWriter) SetDocInfo(info *PdfInfo) { _feggf.setDocInfo(info.ToPdfObject()) }

var ErrColorOutOfRange = _deb.New("\u0063o\u006co\u0072\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065")

// HasExtGState checks whether a font is defined by the specified keyName.
func (_bffdb *PdfPageResources) HasExtGState(keyName _df.PdfObjectName) bool {
	_, _gegacc := _bffdb.GetFontByName(keyName)
	return _gegacc
}

// PrintScaling returns the value of the printScaling.
func (_dgcaf *ViewerPreferences) PrintScaling() PrintScaling { return _dgcaf._faefa }

func (_eeffg *PdfWriter) writeTrailer(_ggefb int) {
	_eeffg.writeString("\u0078\u0072\u0065\u0066\u000d\u000a")
	for _fbdcb := 0; _fbdcb <= _ggefb; {
		for ; _fbdcb <= _ggefb; _fbdcb++ {
			_bdbed, _egab := _eeffg._cdgd[_fbdcb]
			if _egab && (!_eeffg._gebfg || _eeffg._gebfg && (_bdbed.Type == 1 && _bdbed.Offset >= _eeffg._acfdce || _bdbed.Type == 0)) {
				break
			}
		}
		var _geace int
		for _geace = _fbdcb + 1; _geace <= _ggefb; _geace++ {
			_cgcbd, _abgdf := _eeffg._cdgd[_geace]
			if _abgdf && (!_eeffg._gebfg || _eeffg._gebfg && (_cgcbd.Type == 1 && _cgcbd.Offset > _eeffg._acfdce)) {
				continue
			}
			break
		}
		_egee := _c.Sprintf("\u0025d\u0020\u0025\u0064\u000d\u000a", _fbdcb, _geace-_fbdcb)
		_eeffg.writeString(_egee)
		for _fdgfbe := _fbdcb; _fdgfbe < _geace; _fdgfbe++ {
			_gfcad := _eeffg._cdgd[_fdgfbe]
			switch _gfcad.Type {
			case 0:
				_egee = _c.Sprintf("\u0025\u002e\u0031\u0030\u0064\u0020\u0025\u002e\u0035d\u0020\u0066\u000d\u000a", 0, 65535)
				_eeffg.writeString(_egee)
			case 1:
				_egee = _c.Sprintf("\u0025\u002e\u0031\u0030\u0064\u0020\u0025\u002e\u0035d\u0020\u006e\u000d\u000a", _gfcad.Offset, 0)
				_eeffg.writeString(_egee)
			}
		}
		_fbdcb = _geace + 1
	}
	_bfebg := _df.MakeDict()
	_bfebg.Set("\u0049\u006e\u0066\u006f", _eeffg._caefe)
	_bfebg.Set("\u0052\u006f\u006f\u0074", _eeffg._aaag)
	_bfebg.Set("\u0053\u0069\u007a\u0065", _df.MakeInteger(int64(_ggefb+1)))
	if _eeffg._gebfg && _eeffg._ebfcba > 0 {
		_bfebg.Set("\u0050\u0072\u0065\u0076", _df.MakeInteger(_eeffg._ebfcba))
	}
	if _eeffg._fcdg != nil {
		_bfebg.Set("\u0045n\u0063\u0072\u0079\u0070\u0074", _eeffg._deega)
	}
	if _eeffg._fgdf == nil && _eeffg._aadde != "" && _eeffg._addee != "" {
		_eeffg._fgdf = _df.MakeArray(_df.MakeHexString(_eeffg._aadde), _df.MakeHexString(_eeffg._addee))
	}
	if _eeffg._fgdf != nil {
		_bfebg.Set("\u0049\u0044", _eeffg._fgdf)
		_bcd.Log.Trace("\u0049d\u0073\u003a\u0020\u0025\u0073", _eeffg._fgdf)
	}
	_eeffg.writeString("\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u000a")
	_eeffg.writeString(_bfebg.WriteString())
	_eeffg.writeString("\u000a")
}

// NewXObjectImageFromImage creates a new XObject Image from an image object
// with default options. If encoder is nil, uses raw encoding (none).
func NewXObjectImageFromImage(img *Image, cs PdfColorspace, encoder _df.StreamEncoder) (*XObjectImage, error) {
	_ecddb := NewXObjectImage()
	return UpdateXObjectImageFromImage(_ecddb, img, cs, encoder)
}

// GetAsShadingPattern returns a shading pattern. Check with IsShading() prior to using this.
func (_aaabe *PdfPattern) GetAsShadingPattern() *PdfShadingPattern {
	return _aaabe._ecfde.(*PdfShadingPattern)
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_bfgefg pdfFontType0) GetCharMetrics(code _abg.CharCode) (_da.CharMetrics, bool) {
	if _bfgefg.DescendantFont == nil {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u002e\u0020\u0066\u006f\u006et=\u0025\u0073", _bfgefg)
		return _da.CharMetrics{}, false
	}
	return _bfgefg.DescendantFont.GetCharMetrics(code)
}

// BaseFont returns the font's "BaseFont" field.
func (_deacb *PdfFont) BaseFont() string { return _deacb.baseFields()._gddcf }

// DetermineColorspaceNameFromPdfObject determines PDF colorspace from a PdfObject.  Returns the colorspace name and
// an error on failure. If the colorspace was not found, will return an empty string.
func DetermineColorspaceNameFromPdfObject(obj _df.PdfObject) (_df.PdfObjectName, error) {
	var _add *_df.PdfObjectName
	var _dfbbd *_df.PdfObjectArray
	if _aacg, _eca := obj.(*_df.PdfIndirectObject); _eca {
		if _cfff, _eddde := _aacg.PdfObject.(*_df.PdfObjectArray); _eddde {
			_dfbbd = _cfff
		} else if _gbce, _gdaaff := _aacg.PdfObject.(*_df.PdfObjectName); _gdaaff {
			_add = _gbce
		}
	} else if _cfbeb, _fdcg := obj.(*_df.PdfObjectArray); _fdcg {
		_dfbbd = _cfbeb
	} else if _ddbf, _fcdc := obj.(*_df.PdfObjectName); _fcdc {
		_add = _ddbf
	}
	if _add != nil {
		switch *_add {
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079", "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B", "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
			return *_add, nil
		case "\u0050a\u0074\u0074\u0065\u0072\u006e":
			return *_add, nil
		}
	}
	if _dfbbd != nil && _dfbbd.Len() > 0 {
		if _abae, _gddc := _dfbbd.Get(0).(*_df.PdfObjectName); _gddc {
			switch *_abae {
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079", "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B", "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
				if _dfbbd.Len() == 1 {
					return *_abae, nil
				}
			case "\u0043a\u006c\u0047\u0072\u0061\u0079", "\u0043\u0061\u006c\u0052\u0047\u0042", "\u004c\u0061\u0062":
				return *_abae, nil
			case "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064", "\u0050a\u0074\u0074\u0065\u0072\u006e", "\u0049n\u0064\u0065\u0078\u0065\u0064":
				return *_abae, nil
			case "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e", "\u0044e\u0076\u0069\u0063\u0065\u004e":
				return *_abae, nil
			}
		}
	}
	return "", nil
}

func _abecf(_cdgea *_df.PdfObjectDictionary, _afgf *fontCommon) (*pdfFontType3, error) {
	_gdfg := _ffca(_afgf)
	_bbdf := _cdgea.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r")
	if _bbdf == nil {
		_bbdf = _df.MakeInteger(0)
	}
	_gdfg.FirstChar = _bbdf
	_eggb, _cgdgg := _df.GetIntVal(_bbdf)
	if !_cgdgg {
		_bcd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0046i\u0072s\u0074C\u0068\u0061\u0072\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _bbdf)
		return nil, _df.ErrTypeError
	}
	_cageg := _abg.CharCode(_eggb)
	_bbdf = _cdgea.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072")
	if _bbdf == nil {
		_bbdf = _df.MakeInteger(255)
	}
	_gdfg.LastChar = _bbdf
	_eggb, _cgdgg = _df.GetIntVal(_bbdf)
	if !_cgdgg {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004c\u0061\u0073\u0074\u0043h\u0061\u0072\u0020\u0074\u0079\u0070\u0065 \u0028\u0025\u0054\u0029", _bbdf)
		return nil, _df.ErrTypeError
	}
	_dfadg := _abg.CharCode(_eggb)
	_bbdf = _cdgea.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s")
	if _bbdf != nil {
		_gdfg.Resources = _bbdf
	}
	_bbdf = _cdgea.Get("\u0043h\u0061\u0072\u0050\u0072\u006f\u0063s")
	if _bbdf == nil {
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0068\u0061\u0072\u0050\u0072\u006f\u0063\u0073\u0020(%\u0076\u0029", _bbdf)
		return nil, _df.ErrNotSupported
	}
	_gdfg.CharProcs = _bbdf
	_bbdf = _cdgea.Get("\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078")
	if _bbdf == nil {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0046\u006f\u006et\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0028\u0025\u0076\u0029", _bbdf)
		return nil, _df.ErrNotSupported
	}
	_gdfg.FontMatrix = _bbdf
	_gdfg._cgfgg = make(map[_abg.CharCode]float64)
	_bbdf = _cdgea.Get("\u0057\u0069\u0064\u0074\u0068\u0073")
	if _bbdf != nil {
		_gdfg.Widths = _bbdf
		_cege, _dcba := _df.GetArray(_bbdf)
		if !_dcba {
			_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020W\u0069\u0064t\u0068\u0073\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079 \u0028\u0025\u0054\u0029", _bbdf)
			return nil, _df.ErrTypeError
		}
		_gcebbg, _daade := _cege.ToFloat64Array()
		if _daade != nil {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0077\u0069d\u0074\u0068\u0073\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
			return nil, _daade
		}
		if len(_gcebbg) != int(_dfadg-_cageg+1) {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0074\u0068s\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0025\u0064 \u0028\u0025\u0064\u0029", _dfadg-_cageg+1, len(_gcebbg))
			return nil, _df.ErrRangeError
		}
		_cfbd, _dcba := _df.GetArray(_gdfg.FontMatrix)
		if !_dcba {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0025\u0054\u0029", _cfbd)
			return nil, _daade
		}
		_ddfbc, _daade := _cfbd.ToFloat64Array()
		if _daade != nil {
			_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020c\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0046o\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
			return nil, _daade
		}
		_bagec := _dbc.NewMatrix(_ddfbc[0], _ddfbc[1], _ddfbc[2], _ddfbc[3], _ddfbc[4], _ddfbc[5])
		for _bfbe, _fafb := range _gcebbg {
			_fadga, _ := _bagec.Transform(_fafb, _fafb)
			_gdfg._cgfgg[_cageg+_abg.CharCode(_bfbe)] = _fadga
		}
	}
	_gdfg.Encoding = _df.TraceToDirectObject(_cdgea.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
	_ccffg := _cdgea.Get("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e")
	if _ccffg != nil {
		_gdfg._cdbgag = _df.TraceToDirectObject(_ccffg)
		_ebdc, _cadcd := _eggf(_gdfg._cdbgag, &_gdfg.fontCommon)
		if _cadcd != nil {
			return nil, _cadcd
		}
		_gdfg._afcbd = _ebdc
	}
	if _eafcf := _gdfg._afcbd; _eafcf != nil {
		_gdfg._ceed = _abg.NewCMapEncoder("", nil, _eafcf)
	} else {
		_gdfg._ceed = _abg.NewPdfDocEncoder()
	}
	return _gdfg, nil
}

func (_bagda *pdfCIDFontType0) getFontDescriptor() *PdfFontDescriptor { return _bagda._agggb }

// GetCharMetrics returns the char metrics for character code `code`.
func (_bfeg pdfCIDFontType0) GetCharMetrics(code _abg.CharCode) (_da.CharMetrics, bool) {
	_fgae := _bfeg._ggbda
	if _bgccc, _faeec := _bfeg._cbee[code]; _faeec {
		_fgae = _bgccc
	}
	return _da.CharMetrics{Wx: _fgae}, true
}

// SetName sets the `Name` field of the signature.
func (_ebafb *PdfSignature) SetName(name string) { _ebafb.Name = _df.MakeEncodedString(name, true) }

// GetAllContentStreams gets all the content streams for a page as one string.
func (_eagcbf *PdfPage) GetAllContentStreams() (string, error) {
	_aead, _adaa := _eagcbf.GetContentStreams()
	if _adaa != nil {
		return "", _adaa
	}
	return _gc.Join(_aead, "\u0020"), nil
}

// AcroFormRepairOptions contains options for rebuilding the AcroForm.
type AcroFormRepairOptions struct{}

// XObjectType represents the type of an XObject.
type XObjectType int

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain three PdfObjectFloat elements representing
// the A, B and C components of the color.
func (_dadeb *PdfColorspaceCalRGB) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_eedb, _gfbc := _df.GetNumbersAsFloat(objects)
	if _gfbc != nil {
		return nil, _gfbc
	}
	return _dadeb.ColorFromFloats(_eedb)
}

// VariableText contains the common attributes of a variable text.
// The VariableText is typically not used directly, but is can encapsulate by PdfField
// See section 12.7.3.3 "Variable Text" and Table 222 (pp. 434-436 PDF32000_2008).
type VariableText struct {
	DA *_df.PdfObjectString
	Q  *_df.PdfObjectInteger
	DS *_df.PdfObjectString
	RV _df.PdfObject
}

// DecodeArray returns the range of color component values in the ICCBased colorspace.
func (_cafe *PdfColorspaceICCBased) DecodeArray() []float64 { return _cafe.Range }

// NewPermissions returns a new permissions object.
func NewPermissions(docMdp *PdfSignature) *Permissions {
	_cgbgdg := Permissions{}
	_cgbgdg.DocMDP = docMdp
	_afada := _df.MakeDict()
	_afada.Set("\u0044\u006f\u0063\u004d\u0044\u0050", docMdp.ToPdfObject())
	_cgbgdg._abddf = _afada
	return &_cgbgdg
}

func _bbgb(_ecgf *PdfPage) map[_df.PdfObjectName]_df.PdfObject {
	_ebg := make(map[_df.PdfObjectName]_df.PdfObject)
	if _ecgf.Resources == nil {
		return _ebg
	}
	if _ecgf.Resources.Font != nil {
		if _fbad, _eae := _df.GetDict(_ecgf.Resources.Font); _eae {
			for _, _eeca := range _fbad.Keys() {
				_ebg[_eeca] = _fbad.Get(_eeca)
			}
		}
	}
	if _ecgf.Resources.ExtGState != nil {
		if _caee, _eaadc := _df.GetDict(_ecgf.Resources.ExtGState); _eaadc {
			for _, _bcad := range _caee.Keys() {
				_ebg[_bcad] = _caee.Get(_bcad)
			}
		}
	}
	if _ecgf.Resources.XObject != nil {
		if _dgag, _dfga := _df.GetDict(_ecgf.Resources.XObject); _dfga {
			for _, _bbcg := range _dgag.Keys() {
				_ebg[_bbcg] = _dgag.Get(_bbcg)
			}
		}
	}
	if _ecgf.Resources.Pattern != nil {
		if _gcdg, _ffab := _df.GetDict(_ecgf.Resources.Pattern); _ffab {
			for _, _dgcgd := range _gcdg.Keys() {
				_ebg[_dgcgd] = _gcdg.Get(_dgcgd)
			}
		}
	}
	if _ecgf.Resources.Shading != nil {
		if _fcdb, _gcbb := _df.GetDict(_ecgf.Resources.Shading); _gcbb {
			for _, _ceeb := range _fcdb.Keys() {
				_ebg[_ceeb] = _fcdb.Get(_ceeb)
			}
		}
	}
	if _ecgf.Resources.ProcSet != nil {
		if _adec, _aggge := _df.GetDict(_ecgf.Resources.ProcSet); _aggge {
			for _, _feaf := range _adec.Keys() {
				_ebg[_feaf] = _adec.Get(_feaf)
			}
		}
	}
	if _ecgf.Resources.Properties != nil {
		if _bda, _eac := _df.GetDict(_ecgf.Resources.Properties); _eac {
			for _, _bfgef := range _bda.Keys() {
				_ebg[_bfgef] = _bda.Get(_bfgef)
			}
		}
	}
	return _ebg
}

// SetDuplex sets the value of the duplex.
func (_gbggag *ViewerPreferences) SetDuplex(duplex Duplex) { _gbggag._aecfg = duplex }

// IsValid checks if the given pdf output intent type is valid.
func (_fdebd PdfOutputIntentType) IsValid() bool {
	return _fdebd >= PdfOutputIntentTypeA1 && _fdebd <= PdfOutputIntentTypeX
}

// GetRuneMetrics returns the char metrics for a rune.
// TODO(peterwilliams97) There is nothing callers can do if no CharMetrics are found so we might as
// well give them 0 width. There is no need for the bool return.
func (_bdgba *PdfFont) GetRuneMetrics(r rune) (CharMetrics, bool) {
	_accd := _bdgba.actualFont()
	if _accd == nil {
		_bcd.Log.Debug("ER\u0052\u004fR\u003a\u0020\u0047\u0065\u0074\u0047\u006c\u0079\u0070h\u0043\u0068\u0061\u0072\u004d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u004e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020f\u006fr\u0020\u0066\u006f\u006e\u0074\u0020\u0074\u0079p\u0065=\u0025\u0023T", _bdgba._eaeg)
		return _da.CharMetrics{}, false
	}
	if _bcbbe, _cbgf := _accd.GetRuneMetrics(r); _cbgf {
		return _bcbbe, true
	}
	if _gaabg, _cdcbd := _bdgba.GetFontDescriptor(); _cdcbd == nil && _gaabg != nil {
		return _da.CharMetrics{Wx: _gaabg._faeb}, true
	}
	_bcd.Log.Debug("\u0047\u0065\u0074\u0047\u006c\u0079\u0070h\u0043\u0068\u0061r\u004d\u0065\u0074\u0072i\u0063\u0073\u003a\u0020\u004e\u006f\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _bdgba)
	return _da.CharMetrics{}, false
}

// ToPdfObject converts date to a PDF string object.
func (_cffgc *PdfDate) ToPdfObject() _df.PdfObject {
	_afgfd := _c.Sprintf("\u0044\u003a\u0025\u002e\u0034\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e2\u0064\u0025\u0063\u0025\u002e2\u0064\u0027%\u002e\u0032\u0064\u0027", _cffgc._gfddd, _cffgc._dgfba, _cffgc._bgggf, _cffgc._deagge, _cffgc._bbcbg, _cffgc._dgabf, _cffgc._cefda, _cffgc._gabf, _cffgc._fgeefd)
	return _df.MakeString(_afgfd)
}

// GetXObjectFormByName returns the XObjectForm with the specified name from the
// page resources, if it exists.
func (_gfaed *PdfPageResources) GetXObjectFormByName(keyName _df.PdfObjectName) (*XObjectForm, error) {
	_bgdgf, _aafe := _gfaed.GetXObjectByName(keyName)
	if _bgdgf == nil {
		return nil, nil
	}
	if _aafe != XObjectTypeForm {
		return nil, _deb.New("\u006e\u006f\u0074\u0020\u0061\u0020\u0066\u006f\u0072\u006d")
	}
	_bcce, _cbfcae := NewXObjectFormFromStream(_bgdgf)
	if _cbfcae != nil {
		return nil, _cbfcae
	}
	return _bcce, nil
}

// PdfAnnotationWidget represents Widget annotations.
// Note: Widget annotations are used to display form fields.
// (Section 12.5.6.19).
type PdfAnnotationWidget struct {
	*PdfAnnotation
	H      _df.PdfObject
	MK     _df.PdfObject
	A      _df.PdfObject
	AA     _df.PdfObject
	BS     _df.PdfObject
	Parent _df.PdfObject
	_aeaf  *PdfField
	_dcb   bool
}

// ToPdfObject returns the PDF representation of the function.
func (_aceb *PdfFunctionType3) ToPdfObject() _df.PdfObject {
	_baecc := _df.MakeDict()
	_baecc.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _df.MakeInteger(3))
	_fccda := &_df.PdfObjectArray{}
	for _, _befdf := range _aceb.Domain {
		_fccda.Append(_df.MakeFloat(_befdf))
	}
	_baecc.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _fccda)
	if _aceb.Range != nil {
		_fcfdf := &_df.PdfObjectArray{}
		for _, _edefd := range _aceb.Range {
			_fcfdf.Append(_df.MakeFloat(_edefd))
		}
		_baecc.Set("\u0052\u0061\u006eg\u0065", _fcfdf)
	}
	if _aceb.Functions != nil {
		_bfacd := &_df.PdfObjectArray{}
		for _, _ddcff := range _aceb.Functions {
			_bfacd.Append(_ddcff.ToPdfObject())
		}
		_baecc.Set("\u0046u\u006e\u0063\u0074\u0069\u006f\u006es", _bfacd)
	}
	if _aceb.Bounds != nil {
		_eadgf := &_df.PdfObjectArray{}
		for _, _gcegg := range _aceb.Bounds {
			_eadgf.Append(_df.MakeFloat(_gcegg))
		}
		_baecc.Set("\u0042\u006f\u0075\u006e\u0064\u0073", _eadgf)
	}
	if _aceb.Encode != nil {
		_efdcb := &_df.PdfObjectArray{}
		for _, _dbfde := range _aceb.Encode {
			_efdcb.Append(_df.MakeFloat(_dbfde))
		}
		_baecc.Set("\u0045\u006e\u0063\u006f\u0064\u0065", _efdcb)
	}
	if _aceb._ffeg != nil {
		_aceb._ffeg.PdfObject = _baecc
		return _aceb._ffeg
	}
	return _baecc
}

func (_bde *PdfReader) newPdfActionGoTo3DViewFromDict(_dgb *_df.PdfObjectDictionary) (*PdfActionGoTo3DView, error) {
	return &PdfActionGoTo3DView{TA: _dgb.Get("\u0054\u0041"), V: _dgb.Get("\u0056")}, nil
}

func (_fdbd *PdfColorspaceSpecialPattern) String() string {
	return "\u0050a\u0074\u0074\u0065\u0072\u006e"
}

// PdfRectangle is a definition of a rectangle.
type PdfRectangle struct {
	Llx float64
	Lly float64
	Urx float64
	Ury float64
}

func (_gdcgg *PdfWriter) optimize() error {
	if _gdcgg._bgagb == nil {
		return nil
	}
	var _gbdgf error
	_gdcgg._ceeac, _gbdgf = _gdcgg._bgagb.Optimize(_gdcgg._ceeac)
	if _gbdgf != nil {
		return _gbdgf
	}
	_eebbb := make(map[_df.PdfObject]struct{}, len(_gdcgg._ceeac))
	for _, _fcbff := range _gdcgg._ceeac {
		_eebbb[_fcbff] = struct{}{}
	}
	_gdcgg._aadfbg = _eebbb
	return nil
}

// ToJBIG2Image converts current image to the core.JBIG2Image.
func (_egfag *Image) ToJBIG2Image() (*_df.JBIG2Image, error) {
	_cggd, _bbfc := _egfag.ToGoImage()
	if _bbfc != nil {
		return nil, _bbfc
	}
	return _df.GoImageToJBIG2(_cggd, _df.JB2ImageAutoThreshold)
}

// PdfShadingType4 is a Free-form Gouraud-shaded triangle mesh.
type PdfShadingType4 struct {
	*PdfShading
	BitsPerCoordinate *_df.PdfObjectInteger
	BitsPerComponent  *_df.PdfObjectInteger
	BitsPerFlag       *_df.PdfObjectInteger
	Decode            *_df.PdfObjectArray
	Function          []PdfFunction
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for a CalRGB device.
func (_ecgd *PdfColorspaceCalRGB) GetNumComponents() int { return 3 }

func _agdeg(_ddfd _df.PdfObject) (*PdfColorspaceSpecialIndexed, error) {
	_egcfa := NewPdfColorspaceSpecialIndexed()
	if _fgdd, _cdgb := _ddfd.(*_df.PdfIndirectObject); _cdgb {
		_egcfa._bade = _fgdd
	}
	_ddfd = _df.TraceToDirectObject(_ddfd)
	_dcga, _accf := _ddfd.(*_df.PdfObjectArray)
	if !_accf {
		return nil, _c.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _dcga.Len() != 4 {
		return nil, _c.Errorf("\u0069\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0069\u006e\u0076a\u006ci\u0064\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068")
	}
	_ddfd = _dcga.Get(0)
	_faca, _accf := _ddfd.(*_df.PdfObjectName)
	if !_accf {
		return nil, _c.Errorf("\u0069n\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
	}
	if *_faca != "\u0049n\u0064\u0065\u0078\u0065\u0064" {
		return nil, _c.Errorf("\u0069\u006e\u0064\u0065xe\u0064\u0020\u0043\u0053\u003a\u0020\u0077\u0072\u006f\u006e\u0067\u0020\u006e\u0061m\u0065")
	}
	_ddfd = _dcga.Get(1)
	_gebd, _gdbbe := DetermineColorspaceNameFromPdfObject(_ddfd)
	if _gdbbe != nil {
		return nil, _gdbbe
	}
	if _gebd == "\u0049n\u0064\u0065\u0078\u0065\u0064" || _gebd == "\u0050a\u0074\u0074\u0065\u0072\u006e" {
		_bcd.Log.Debug("E\u0072\u0072o\u0072\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0049\u006e\u0064e\u0078\u0065\u0064\u002f\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0043S\u0020\u0061\u0073\u0020\u0062\u0061\u0073\u0065\u0020\u0028\u0025v\u0029", _gebd)
		return nil, _badg
	}
	_cfegc, _gdbbe := NewPdfColorspaceFromPdfObject(_ddfd)
	if _gdbbe != nil {
		return nil, _gdbbe
	}
	_egcfa.Base = _cfegc
	_ddfd = _dcga.Get(2)
	_cgcf, _gdbbe := _df.GetNumberAsInt64(_ddfd)
	if _gdbbe != nil {
		return nil, _gdbbe
	}
	if _cgcf > 255 {
		return nil, _c.Errorf("\u0069n\u0064\u0065\u0078\u0065d\u0020\u0043\u0053\u003a\u0020I\u006ev\u0061l\u0069\u0064\u0020\u0068\u0069\u0076\u0061l")
	}
	_egcfa.HiVal = int(_cgcf)
	_ddfd = _dcga.Get(3)
	_egcfa.Lookup = _ddfd
	_ddfd = _df.TraceToDirectObject(_ddfd)
	var _fgfg []byte
	if _dacef, _bffafc := _ddfd.(*_df.PdfObjectString); _bffafc {
		_fgfg = _dacef.Bytes()
		_bcd.Log.Trace("\u0049\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0073\u0074r\u0069\u006e\u0067\u0020\u0063\u006f\u006co\u0072\u0020\u0064\u0061\u0074\u0061\u003a\u0020\u0025\u0020\u0064", _fgfg)
	} else if _deacc, _cbbgg := _ddfd.(*_df.PdfObjectStream); _cbbgg {
		_bcd.Log.Trace("\u0049n\u0064e\u0078\u0065\u0064\u0020\u0073t\u0072\u0065a\u006d\u003a\u0020\u0025\u0073", _ddfd.String())
		_bcd.Log.Trace("\u0045\u006e\u0063\u006fde\u0064\u0020\u0028\u0025\u0064\u0029\u0020\u003a\u0020\u0025\u0023\u0020\u0078", len(_deacc.Stream), _deacc.Stream)
		_eddgf, _aecc := _df.DecodeStream(_deacc)
		if _aecc != nil {
			return nil, _aecc
		}
		_bcd.Log.Trace("\u0044e\u0063o\u0064\u0065\u0064\u0020\u0028%\u0064\u0029 \u003a\u0020\u0025\u0020\u0058", len(_eddgf), _eddgf)
		_fgfg = _eddgf
	} else {
		_bcd.Log.Debug("\u0054\u0079\u0070\u0065\u003a\u0020\u0025\u0054", _ddfd)
		return nil, _c.Errorf("\u0069\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0049\u006e\u0076a\u006ci\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if len(_fgfg) < _egcfa.Base.GetNumComponents()*(_egcfa.HiVal+1) {
		_bcd.Log.Debug("\u0050\u0044\u0046\u0020\u0049\u006e\u0063o\u006d\u0070\u0061t\u0069\u0062\u0069\u006ci\u0074\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074\u006f\u006f\u0020\u0073\u0068\u006f\u0072\u0074")
		_bcd.Log.Debug("\u0046\u0061i\u006c\u002c\u0020\u006c\u0065\u006e\u0028\u0064\u0061\u0074\u0061\u0029\u003a\u0020\u0025\u0064\u002c\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073\u003a\u0020\u0025\u0064\u002c\u0020\u0068\u0069\u0056\u0061\u006c\u003a\u0020\u0025\u0064", len(_fgfg), _egcfa.Base.GetNumComponents(), _egcfa.HiVal)
	} else {
		_fgfg = _fgfg[:_egcfa.Base.GetNumComponents()*(_egcfa.HiVal+1)]
	}
	_egcfa._befa = _fgfg
	return _egcfa, nil
}

// Add appends a top level outline item to the outline.
func (_gagagf *Outline) Add(item *OutlineItem) { _gagagf.Entries = append(_gagagf.Entries, item) }

// NewPdfActionSetOCGState returns a new "named" action.
func NewPdfActionSetOCGState() *PdfActionSetOCGState {
	_fbd := NewPdfAction()
	_cge := &PdfActionSetOCGState{}
	_cge.PdfAction = _fbd
	_fbd.SetContext(_cge)
	return _cge
}

// PdfAnnotationFreeText represents FreeText annotations.
// (Section 12.5.6.6).
type PdfAnnotationFreeText struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	DA _df.PdfObject
	Q  _df.PdfObject
	RC _df.PdfObject
	DS _df.PdfObject
	CL _df.PdfObject
	IT _df.PdfObject
	BE _df.PdfObject
	RD _df.PdfObject
	BS _df.PdfObject
	LE _df.PdfObject
}

// SetDocInfo sets the document /Info metadata.
// This will overwrite any globally declared document info.
func (_efab *PdfAppender) SetDocInfo(info *PdfInfo) { _efab._fbdb = info }

type fontFile struct {
	_accbb string
	_gdde  string
	_dgacb _abg.SimpleEncoder
}

func (_deeg *PdfReader) newPdfAnnotationFileAttachmentFromDict(_ecfg *_df.PdfObjectDictionary) (*PdfAnnotationFileAttachment, error) {
	_fgfc := PdfAnnotationFileAttachment{}
	_gbf, _gdgb := _deeg.newPdfAnnotationMarkupFromDict(_ecfg)
	if _gdgb != nil {
		return nil, _gdgb
	}
	_fgfc.PdfAnnotationMarkup = _gbf
	_fgfc.FS = _ecfg.Get("\u0046\u0053")
	_fgfc.Name = _ecfg.Get("\u004e\u0061\u006d\u0065")
	return &_fgfc, nil
}

// AddWatermarkText adds a text watermark to the page.
func (_bdefg *PdfPage) AddWatermarkText(text string, opt WatermarkTextOptions) error {
	if text == "" {
		return _deb.New("n\u006f\u0020\u0074\u0065\u0078\u0074\u0020\u0073\u0065\u0074")
	}
	if opt.FontPath == "" {
		return _deb.New("\u006e\u006f \u0066\u006f\u006et\u0020\u0070\u0061\u0074\u0068\u0020\u0073\u0065\u0074")
	}
	if opt.Alpha == 0 {
		opt.Alpha = 0.5
	}
	if opt.FontSize == 0 {
		opt.FontSize = 20.0
	}
	if opt.FontColor == nil {
		opt.FontColor = _b.Black
	}
	_fcdaf, _abdbg := _bdefg.generateImage(text, opt.FontSize, opt.FontPath, opt.FontColor)
	if _abdbg != nil {
		return _abdbg
	}
	_afgfg, _, _abdbg := _cg.Decode(_ef.NewReader(_fcdaf))
	if _abdbg != nil {
		return _abdbg
	}
	_abebae, _abdbg := ImageHandling.NewImageFromGoImage(_afgfg)
	if _abdbg != nil {
		return _abdbg
	}
	_bafae, _abdbg := NewXObjectImageFromImage(_abebae, nil, _df.NewFlateEncoder())
	if _abdbg != nil {
		return _abdbg
	}
	_dbfec := WatermarkImageOptions{Alpha: opt.Alpha, FitToWidth: false, PreserveAspectRatio: true, Angle: opt.Angle}
	return _bdefg.AddWatermarkImage(_bafae, _dbfec)
}

// GetContainingPdfObject returns the container of the outline tree node (indirect object).
func (_affad *PdfOutlineTreeNode) GetContainingPdfObject() _df.PdfObject {
	return _affad.GetContext().GetContainingPdfObject()
}

// NewOutlineDest returns a new outline destination which can be used
// with outline items.
func NewOutlineDest(page int64, x, y float64) OutlineDest {
	return OutlineDest{Page: page, Mode: "\u0058\u0059\u005a", X: x, Y: y}
}

type pdfFont interface {
	_da.Font

	// ToPdfObject returns a PDF representation of the font and implements interface Model.
	ToPdfObject() _df.PdfObject
	getFontDescriptor() *PdfFontDescriptor
	baseFields() *fontCommon
}

// NewPdfAnnotationSquiggly returns a new text squiggly annotation.
func NewPdfAnnotationSquiggly() *PdfAnnotationSquiggly {
	_eefb := NewPdfAnnotation()
	_eega := &PdfAnnotationSquiggly{}
	_eega.PdfAnnotation = _eefb
	_eega.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_eefb.SetContext(_eega)
	return _eega
}

// SetNonFullScreenPageMode sets the value of the nonFullScreenPageMode.
func (_dddgc *ViewerPreferences) SetNonFullScreenPageMode(nonFullScreenPageMode NonFullScreenPageMode) {
	_dddgc._ebbf = nonFullScreenPageMode
}

// ColorToRGB converts a CalGray color to an RGB color.
func (_ddef *PdfColorspaceCalGray) ColorToRGB(color PdfColor) (PdfColor, error) {
	_bage, _acgef := color.(*PdfColorCalGray)
	if !_acgef {
		_bcd.Log.Debug("\u0049n\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006eo\u0074\u0020\u0063\u0061\u006c\u0020\u0067\u0072\u0061\u0079")
		return nil, _deb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	ANorm := _bage.Val()
	X := _ddef.WhitePoint[0] * _faf.Pow(ANorm, _ddef.Gamma)
	Y := _ddef.WhitePoint[1] * _faf.Pow(ANorm, _ddef.Gamma)
	Z := _ddef.WhitePoint[2] * _faf.Pow(ANorm, _ddef.Gamma)
	_bbggb := 3.240479*X + -1.537150*Y + -0.498535*Z
	_acda := -0.969256*X + 1.875992*Y + 0.041556*Z
	_geafbd := 0.055648*X + -0.204043*Y + 1.057311*Z
	_bbggb = _faf.Min(_faf.Max(_bbggb, 0), 1.0)
	_acda = _faf.Min(_faf.Max(_acda, 0), 1.0)
	_geafbd = _faf.Min(_faf.Max(_geafbd, 0), 1.0)
	return NewPdfColorDeviceRGB(_bbggb, _acda, _geafbd), nil
}

func (_afadf *Image) getSuitableEncoder() (_df.StreamEncoder, error) {
	var (
		_ddbdd, _abcg = int(_afadf.Width), int(_afadf.Height)
		_aefe         = make(map[string]bool)
		_decc         = true
		_fgeccf       = false
		_cfgbd        = func() *_df.DCTEncoder { return _df.NewDCTEncoder() }
		_affdg        = func() *_df.DCTEncoder { _aabg := _df.NewDCTEncoder(); _aabg.BitsPerComponent = 16; return _aabg }
	)
	for _bedf := 0; _bedf < _abcg; _bedf++ {
		for _bfaed := 0; _bfaed < _ddbdd; _bfaed++ {
			_cccaf, _ccgb := _afadf.ColorAt(_bfaed, _bedf)
			if _ccgb != nil {
				return nil, _ccgb
			}
			_fcdbe, _dgga, _fdege, _caab := _cccaf.RGBA()
			if _decc && (_fcdbe != _dgga || _fcdbe != _fdege || _dgga != _fdege) {
				_decc = false
			}
			if !_fgeccf {
				switch _cccaf.(type) {
				case _b.NRGBA:
					_fgeccf = _caab > 0
				}
			}
			_aefe[_c.Sprintf("\u0025\u0064\u002c\u0025\u0064\u002c\u0025\u0064", _fcdbe, _dgga, _fdege)] = true
			if len(_aefe) > 2 && _fgeccf {
				return _affdg(), nil
			}
		}
	}
	if _fgeccf || len(_afadf._gebab) > 0 {
		return _df.NewFlateEncoder(), nil
	}
	if len(_aefe) <= 2 {
		_fgag := _afadf.ConvertToBinary()
		if _fgag != nil {
			return nil, _fgag
		}
		return _df.NewJBIG2Encoder(), nil
	}
	if _decc {
		return _cfgbd(), nil
	}
	if _afadf.ColorComponents == 1 {
		if _afadf.BitsPerComponent == 1 {
			return _df.NewJBIG2Encoder(), nil
		} else if _afadf.BitsPerComponent == 8 {
			_ddeaf := _df.NewDCTEncoder()
			_ddeaf.ColorComponents = 1
			return _ddeaf, nil
		}
	} else if _afadf.ColorComponents == 3 {
		if _afadf.BitsPerComponent == 8 {
			return _cfgbd(), nil
		} else if _afadf.BitsPerComponent == 16 {
			return _affdg(), nil
		}
	} else if _afadf.ColorComponents == 4 {
		_eeecc := _affdg()
		_eeecc.ColorComponents = 4
		return _eeecc, nil
	}
	return _affdg(), nil
}

// ToPdfObject implements interface PdfModel.
func (_gaaa *PdfAnnotationMovie) ToPdfObject() _df.PdfObject {
	_gaaa.PdfAnnotation.ToPdfObject()
	_fgef := _gaaa._bfde
	_bcee := _fgef.PdfObject.(*_df.PdfObjectDictionary)
	_bcee.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u004d\u006f\u0076i\u0065"))
	_bcee.SetIfNotNil("\u0054", _gaaa.T)
	_bcee.SetIfNotNil("\u004d\u006f\u0076i\u0065", _gaaa.Movie)
	_bcee.SetIfNotNil("\u0041", _gaaa.A)
	return _fgef
}

// SignatureValidationResult defines the response from the signature validation handler.
type SignatureValidationResult struct {

	// List of errors when validating the signature.
	Errors      []string
	IsSigned    bool
	IsVerified  bool
	IsTrusted   bool
	Fields      []*PdfField
	Name        string
	Date        PdfDate
	Reason      string
	Location    string
	ContactInfo string
	DiffResults *_ffc.DiffResults
	IsCrlFound  bool
	IsOcspFound bool

	// GeneralizedTime is the time at which the time-stamp token has been created by the TSA (RFC 3161).
	GeneralizedTime _fa.Time
}

func (_cbbd *PdfReader) newPdfActionGotoRFromDict(_ece *_df.PdfObjectDictionary) (*PdfActionGoToR, error) {
	_fadd, _gge := _cadf(_ece.Get("\u0046"))
	if _gge != nil {
		return nil, _gge
	}
	return &PdfActionGoToR{D: _ece.Get("\u0044"), NewWindow: _ece.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), F: _fadd}, nil
}

// GetPageDict converts the Page to a PDF object dictionary.
func (_cceb *PdfPage) GetPageDict() *_df.PdfObjectDictionary {
	_cbccc := _cceb._gfcee
	_cbccc.Clear()
	_cbccc.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0050\u0061\u0067\u0065"))
	_cbccc.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _cceb.Parent)
	if _cceb.LastModified != nil {
		_cbccc.Set("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064", _cceb.LastModified.ToPdfObject())
	}
	if _cceb.Resources != nil {
		_cbccc.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _cceb.Resources.ToPdfObject())
	}
	if _cceb.CropBox != nil {
		_cbccc.Set("\u0043r\u006f\u0070\u0042\u006f\u0078", _cceb.CropBox.ToPdfObject())
	}
	if _cceb.MediaBox != nil {
		_cbccc.Set("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", _cceb.MediaBox.ToPdfObject())
	}
	if _cceb.BleedBox != nil {
		_cbccc.Set("\u0042\u006c\u0065\u0065\u0064\u0042\u006f\u0078", _cceb.BleedBox.ToPdfObject())
	}
	if _cceb.TrimBox != nil {
		_cbccc.Set("\u0054r\u0069\u006d\u0042\u006f\u0078", _cceb.TrimBox.ToPdfObject())
	}
	if _cceb.ArtBox != nil {
		_cbccc.Set("\u0041\u0072\u0074\u0042\u006f\u0078", _cceb.ArtBox.ToPdfObject())
	}
	_cbccc.SetIfNotNil("\u0042\u006f\u0078C\u006f\u006c\u006f\u0072\u0049\u006e\u0066\u006f", _cceb.BoxColorInfo)
	_cbccc.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _cceb.Contents)
	if _cceb.Rotate != nil {
		_cbccc.Set("\u0052\u006f\u0074\u0061\u0074\u0065", _df.MakeInteger(*_cceb.Rotate))
	}
	_cbccc.SetIfNotNil("\u0047\u0072\u006fu\u0070", _cceb.Group)
	_cbccc.SetIfNotNil("\u0054\u0068\u0075m\u0062", _cceb.Thumb)
	_cbccc.SetIfNotNil("\u0042", _cceb.B)
	_cbccc.SetIfNotNil("\u0044\u0075\u0072", _cceb.Dur)
	_cbccc.SetIfNotNil("\u0054\u0072\u0061n\u0073", _cceb.Trans)
	_cbccc.SetIfNotNil("\u0041\u0041", _cceb.AA)
	_cbccc.SetIfNotNil("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _cceb.Metadata)
	_cbccc.SetIfNotNil("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o", _cceb.PieceInfo)
	_cbccc.SetIfNotNil("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _cceb.StructParents)
	_cbccc.SetIfNotNil("\u0049\u0044", _cceb.ID)
	_cbccc.SetIfNotNil("\u0050\u005a", _cceb.PZ)
	_cbccc.SetIfNotNil("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006fn\u0049\u006e\u0066\u006f", _cceb.SeparationInfo)
	_cbccc.SetIfNotNil("\u0054\u0061\u0062\u0073", _cceb.Tabs)
	_cbccc.SetIfNotNil("T\u0065m\u0070\u006c\u0061\u0074\u0065\u0049\u006e\u0073t\u0061\u006e\u0074\u0069at\u0065\u0064", _cceb.TemplateInstantiated)
	_cbccc.SetIfNotNil("\u0050r\u0065\u0073\u0053\u0074\u0065\u0070s", _cceb.PresSteps)
	_cbccc.SetIfNotNil("\u0055\u0073\u0065\u0072\u0055\u006e\u0069\u0074", _cceb.UserUnit)
	_cbccc.SetIfNotNil("\u0056\u0050", _cceb.VP)
	if _cceb._adef != nil {
		_beag := _df.MakeArray()
		for _, _ccbcg := range _cceb._adef {
			if _adbgf := _ccbcg.GetContext(); _adbgf != nil {
				_beag.Append(_adbgf.ToPdfObject())
			} else {
				_beag.Append(_ccbcg.ToPdfObject())
			}
		}
		if _beag.Len() > 0 {
			_cbccc.Set("\u0041\u006e\u006e\u006f\u0074\u0073", _beag)
		}
	} else if _cceb.Annots != nil {
		_cbccc.SetIfNotNil("\u0041\u006e\u006e\u006f\u0074\u0073", _cceb.Annots)
	}
	return _cbccc
}

// GetMediaBox gets the inheritable media box value, either from the page
// or a higher up page/pages struct.
func (_ebeac *PdfPage) GetMediaBox() (*PdfRectangle, error) {
	if _ebeac.MediaBox != nil {
		return _ebeac.MediaBox, nil
	}
	_fegbf := _ebeac.Parent
	for _fegbf != nil {
		_bfceb, _bgfcg := _df.GetDict(_fegbf)
		if !_bgfcg {
			return nil, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079")
		}
		if _bfeab := _bfceb.Get("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078"); _bfeab != nil {
			_faece, _cacbg := _df.GetArray(_bfeab)
			if !_cacbg {
				return nil, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0064\u0069a\u0020\u0062\u006f\u0078")
			}
			_fdccg, _ddeea := NewPdfRectangle(*_faece)
			if _ddeea != nil {
				return nil, _ddeea
			}
			return _fdccg, nil
		}
		_fegbf = _bfceb.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return nil, _deb.New("m\u0065\u0064\u0069\u0061 b\u006fx\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064")
}

// SetReason sets the `Reason` field of the signature.
func (_fgecf *PdfSignature) SetReason(reason string) {
	_fgecf.Reason = _df.MakeEncodedString(reason, true)
}

// GetPerms returns the Permissions dictionary
func (_fdgaf *PdfReader) GetPerms() *Permissions { return _fdgaf._eaeee }

// SetVersion sets the PDF version of the output file.
func (_aabcb *PdfWriter) SetVersion(majorVersion, minorVersion int) {
	_aabcb._aeffd.Major = majorVersion
	_aabcb._aeffd.Minor = minorVersion
}

// HasShadingByName checks whether a shading is defined by the specified keyName.
func (_efgdad *PdfPageResources) HasShadingByName(keyName _df.PdfObjectName) bool {
	_, _cbfbf := _efgdad.GetShadingByName(keyName)
	return _cbfbf
}

// ToPdfObject implements interface PdfModel.
func (_cbe *PdfActionRendition) ToPdfObject() _df.PdfObject {
	_cbe.PdfAction.ToPdfObject()
	_bae := _cbe._gcf
	_cccc := _bae.PdfObject.(*_df.PdfObjectDictionary)
	_cccc.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeRendition)))
	_cccc.SetIfNotNil("\u0052", _cbe.R)
	_cccc.SetIfNotNil("\u0041\u004e", _cbe.AN)
	_cccc.SetIfNotNil("\u004f\u0050", _cbe.OP)
	_cccc.SetIfNotNil("\u004a\u0053", _cbe.JS)
	return _bae
}

// SetXObjectImageByNameLazy adds the provided XObjectImage to the page resources.
// The added XObjectImage is identified by the specified name.
func (_fbgc *PdfPageResources) SetXObjectImageByNameLazy(keyName _df.PdfObjectName, ximg *XObjectImage, lazy bool) error {
	_ccdfd := ximg.ToPdfObject().(*_df.PdfObjectStream)
	if lazy {
		_ccdfd.MakeLazy()
	}
	_ebeed := _fbgc.SetXObjectByName(keyName, _ccdfd)
	return _ebeed
}

// SetPdfSubject sets the Subject attribute of the output PDF.
func SetPdfSubject(subject string) { _gcdec.Lock(); defer _gcdec.Unlock(); _baffd = subject }

// PdfModel is a higher level PDF construct which can be collapsed into a PdfObject.
// Each PdfModel has an underlying PdfObject and vice versa (one-to-one).
// Under normal circumstances there should only be one copy of each.
// Copies can be made, but care must be taken to do it properly.
type PdfModel interface {
	ToPdfObject() _df.PdfObject
	GetContainingPdfObject() _df.PdfObject
}

func (_gegfa *PdfWriter) writeNamesDictionary() error {
	if _gegfa._adadc == nil {
		return nil
	}
	_dfebe := _gegfa._adadc.ToPdfObject()
	_gegfa._gdee.Set("\u004e\u0061\u006de\u0073", _dfebe)
	_cacegg := _gegfa.addObjects(_dfebe)
	if _cacegg != nil {
		return _cacegg
	}
	return nil
}

func (_dfac *PdfColorspaceCalGray) String() string { return "\u0043a\u006c\u0047\u0072\u0061\u0079" }

func (_cfab *PdfReader) newPdfActionSetOCGStateFromDict(_fge *_df.PdfObjectDictionary) (*PdfActionSetOCGState, error) {
	return &PdfActionSetOCGState{State: _fge.Get("\u0053\u0074\u0061t\u0065"), PreserveRB: _fge.Get("\u0050\u0072\u0065\u0073\u0065\u0072\u0076\u0065\u0052\u0042")}, nil
}

// ToPdfObject implements interface PdfModel.
func (_accc *PdfAnnotationSquare) ToPdfObject() _df.PdfObject {
	_accc.PdfAnnotation.ToPdfObject()
	_ccea := _accc._bfde
	_dfc := _ccea.PdfObject.(*_df.PdfObjectDictionary)
	if _accc.PdfAnnotationMarkup != nil {
		_accc.PdfAnnotationMarkup.appendToPdfDictionary(_dfc)
	}
	_dfc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0053\u0071\u0075\u0061\u0072\u0065"))
	_dfc.SetIfNotNil("\u0042\u0053", _accc.BS)
	_dfc.SetIfNotNil("\u0049\u0043", _accc.IC)
	_dfc.SetIfNotNil("\u0042\u0045", _accc.BE)
	_dfc.SetIfNotNil("\u0052\u0044", _accc.RD)
	return _ccea
}

func _gfeef() string { _gcdec.Lock(); defer _gcdec.Unlock(); return _dabbc }

// FlattenFieldsWithOpts flattens the AcroForm fields of the reader using the
// provided field appearance generator and the specified options. If no options
// are specified, all form fields are flattened.
// If a filter function is provided using the opts parameter, only the filtered
// fields are flattened. Otherwise, all form fields are flattened.
// At the end of the process, the AcroForm contains all the fields which were
// not flattened. If all fields are flattened, the reader's AcroForm field
// is set to nil.
func (_acec *PdfReader) FlattenFieldsWithOpts(appgen FieldAppearanceGenerator, opts *FieldFlattenOpts) error {
	return _acec.flattenFieldsWithOpts(false, appgen, opts)
}

// IsHideToolbar returns the value of the hideToolbar flag.
func (_bafdf *ViewerPreferences) IsHideToolbar() bool {
	if _bafdf._bbfdd == nil {
		return false
	}
	return *_bafdf._bbfdd
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for a Lab device.
func (_ggc *PdfColorspaceLab) GetNumComponents() int { return 3 }

// UpdateObject marks `obj` as updated and to be included in the following revision.
func (_ebcb *PdfAppender) UpdateObject(obj _df.PdfObject) {
	_ebcb.replaceObject(obj, obj)
	if _, _bgcg := _ebcb._gceg[obj]; !_bgcg {
		_ebcb._eaad = append(_ebcb._eaad, obj)
		_ebcb._gceg[obj] = struct{}{}
	}
}

// PdfAnnotation represents an annotation in PDF (section 12.5 p. 389).
type PdfAnnotation struct {
	_afaa        PdfModel
	Rect         _df.PdfObject
	Contents     _df.PdfObject
	P            _df.PdfObject
	NM           _df.PdfObject
	M            _df.PdfObject
	F            _df.PdfObject
	AP           _df.PdfObject
	AS           _df.PdfObject
	Border       _df.PdfObject
	C            _df.PdfObject
	StructParent _df.PdfObject
	OC           _df.PdfObject
	_bfde        *_df.PdfIndirectObject
}

func (_bbeeg *PdfReader) newPdfActionJavaScriptFromDict(_fae *_df.PdfObjectDictionary) (*PdfActionJavaScript, error) {
	return &PdfActionJavaScript{JS: _fae.Get("\u004a\u0053")}, nil
}

// SetPdfCreator sets the Creator attribute of the output PDF.
func SetPdfCreator(creator string) { _gcdec.Lock(); defer _gcdec.Unlock(); _cgaca = creator }

func (_agff *PdfReader) newPdfAnnotation3DFromDict(_eea *_df.PdfObjectDictionary) (*PdfAnnotation3D, error) {
	_cced := PdfAnnotation3D{}
	_cced.T3DD = _eea.Get("\u0033\u0044\u0044")
	_cced.T3DV = _eea.Get("\u0033\u0044\u0056")
	_cced.T3DA = _eea.Get("\u0033\u0044\u0041")
	_cced.T3DI = _eea.Get("\u0033\u0044\u0049")
	_cced.T3DB = _eea.Get("\u0033\u0044\u0042")
	return &_cced, nil
}

func _egbe(_befg *fontCommon) *pdfFontType0 { return &pdfFontType0{fontCommon: *_befg} }

// PageFromIndirectObject returns the PdfPage and page number for a given indirect object.
func (_dgaee *PdfReader) PageFromIndirectObject(ind *_df.PdfIndirectObject) (*PdfPage, int, error) {
	if len(_dgaee.PageList) != len(_dgaee._dcfee) {
		return nil, 0, _deb.New("\u0070\u0061\u0067\u0065\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	for _eedg, _dgdebc := range _dgaee._dcfee {
		if _dgdebc == ind {
			return _dgaee.PageList[_eedg], _eedg + 1, nil
		}
	}
	return nil, 0, _deb.New("\u0070\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// ToPdfObject returns the button field dictionary within an indirect object.
func (_fcgcd *PdfFieldButton) ToPdfObject() _df.PdfObject {
	_fcgcd.PdfField.ToPdfObject()
	_gacb := _fcgcd._cdbc
	_bdabe := _gacb.PdfObject.(*_df.PdfObjectDictionary)
	_bdabe.Set("\u0046\u0054", _df.MakeName("\u0042\u0074\u006e"))
	if _fcgcd.Opt != nil {
		_bdabe.Set("\u004f\u0070\u0074", _fcgcd.Opt)
	}
	return _gacb
}

// PdfColor interface represents a generic color in PDF.
type PdfColor interface{}

// ToPdfObject implements interface PdfModel.
func (_agdba *PdfSignatureReference) ToPdfObject() _df.PdfObject {
	_gecde := _df.MakeDict()
	_gecde.SetIfNotNil("\u0054\u0079\u0070\u0065", _agdba.Type)
	_gecde.SetIfNotNil("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064", _agdba.TransformMethod)
	_gecde.SetIfNotNil("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073", _agdba.TransformParams)
	_gecde.SetIfNotNil("\u0044\u0061\u0074\u0061", _agdba.Data)
	_gecde.SetIfNotNil("\u0044\u0069\u0067e\u0073\u0074\u004d\u0065\u0074\u0068\u006f\u0064", _agdba.DigestMethod)
	return _gecde
}

// ToPdfObject returns a PDF object representation of the outline item.
func (_bfgfc *OutlineItem) ToPdfObject() _df.PdfObject {
	_gcebg, _ := _bfgfc.ToPdfOutlineItem()
	return _gcebg.ToPdfObject()
}

// PdfActionThread represents a thread action.
type PdfActionThread struct {
	*PdfAction
	F *PdfFilespec
	D _df.PdfObject
	B _df.PdfObject
}

func (_dca *PdfReader) newPdfActionNamedFromDict(_bbee *_df.PdfObjectDictionary) (*PdfActionNamed, error) {
	return &PdfActionNamed{N: _bbee.Get("\u004e")}, nil
}

// Mask returns the uin32 bitmask for the specific flag.
func (_agcg FieldFlag) Mask() uint32 { return uint32(_agcg) }

// ToPdfObject converts rectangle to a PDF object.
func (_fcgaa *PdfRectangle) ToPdfObject() _df.PdfObject {
	return _df.MakeArray(_df.MakeFloat(_fcgaa.Llx), _df.MakeFloat(_fcgaa.Lly), _df.MakeFloat(_fcgaa.Urx), _df.MakeFloat(_fcgaa.Ury))
}

// ToPdfObject implements interface PdfModel.
func (_edcf *PdfAnnotationPrinterMark) ToPdfObject() _df.PdfObject {
	_edcf.PdfAnnotation.ToPdfObject()
	_fcda := _edcf._bfde
	_dgba := _fcda.PdfObject.(*_df.PdfObjectDictionary)
	_dgba.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("P\u0072\u0069\u006e\u0074\u0065\u0072\u004d\u0061\u0072\u006b"))
	_dgba.SetIfNotNil("\u004d\u004e", _edcf.MN)
	return _fcda
}

// ImageToRGB returns the passed in image. Method exists in order to satisfy
// the PdfColorspace interface.
func (_aga *PdfColorspaceDeviceRGB) ImageToRGB(img Image) (Image, error) { return img, nil }

func (_dceee *PdfWriter) getPdfVersion() string {
	return _c.Sprintf("\u0025\u0064\u002e%\u0064", _dceee._aeffd.Major, _dceee._aeffd.Minor)
}

func (_aeee *PdfReader) newPdfAnnotationStampFromDict(_abdf *_df.PdfObjectDictionary) (*PdfAnnotationStamp, error) {
	_dcfd := PdfAnnotationStamp{}
	_eeda, _bedg := _aeee.newPdfAnnotationMarkupFromDict(_abdf)
	if _bedg != nil {
		return nil, _bedg
	}
	_dcfd.PdfAnnotationMarkup = _eeda
	_dcfd.Name = _abdf.Get("\u004e\u0061\u006d\u0065")
	return &_dcfd, nil
}

func (_eced *PdfFont) baseFields() *fontCommon {
	if _eced._eaeg == nil {
		_bcd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0062\u0061\u0073\u0065\u0046\u0069\u0065l\u0064s\u002e \u0063o\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u002e")
		return nil
	}
	return _eced._eaeg.baseFields()
}

// PageBoundary represents the name of the page boundary representing
// the visible area.
type PageBoundary string

// SetKDict sets the KDict for the KValue.
func (_aadce *KValue) SetKDict(kDict *KDict) { _aadce.Clear(); _aadce._eebde = kDict }

// RemovePage removes a page by number.
func (_gdd *PdfAppender) RemovePage(pageNum int) {
	_afcf := pageNum - 1
	_gdd._dgac = append(_gdd._dgac[0:_afcf], _gdd._dgac[pageNum:]...)
}

// PdfActionURI represents an URI action.
type PdfActionURI struct {
	*PdfAction
	URI   _df.PdfObject
	IsMap _df.PdfObject
}

func (_abdbd *PdfFilespec) getDict() *_df.PdfObjectDictionary {
	if _debca, _accfe := _abdbd._gaafd.(*_df.PdfIndirectObject); _accfe {
		_adgd, _ffef := _debca.PdfObject.(*_df.PdfObjectDictionary)
		if !_ffef {
			return nil
		}
		return _adgd
	} else if _agggg, _cegb := _abdbd._gaafd.(*_df.PdfObjectDictionary); _cegb {
		return _agggg
	} else {
		_bcd.Log.Debug("\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020F\u0069\u006c\u0065\u0073\u0070\u0065\u0063\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006f\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u006f\u0062\u006a\u0065\u0063\u0074 \u0074\u0079p\u0065\u0020(\u0025T\u0029", _abdbd._gaafd)
		return nil
	}
}

type pdfSignDictionary struct {
	*_df.PdfObjectDictionary
	_dabb   *SignatureHandler
	_gbbba  *PdfSignature
	_ebeeda int64
	_gcfcd  int
	_ecbd   int
	_ddfde  int
	_dffg   int
}

// SetDirection sets the value of the direction.
func (_beafga *ViewerPreferences) SetDirection(direction Direction) { _beafga._cggbe = direction }

// NewPdfColorspaceCalRGB returns a new CalRGB colorspace object.
func NewPdfColorspaceCalRGB() *PdfColorspaceCalRGB {
	_eede := &PdfColorspaceCalRGB{}
	_eede.BlackPoint = []float64{0.0, 0.0, 0.0}
	_eede.Gamma = []float64{1.0, 1.0, 1.0}
	_eede.Matrix = []float64{1, 0, 0, 0, 1, 0, 0, 0, 1}
	return _eede
}

// NewPdfSignature creates a new PdfSignature object.
func NewPdfSignature(handler SignatureHandler) *PdfSignature {
	_aaccg := &PdfSignature{Type: _df.MakeName("\u0053\u0069\u0067"), Handler: handler}
	_gfca := &pdfSignDictionary{PdfObjectDictionary: _df.MakeDict(), _dabb: &handler, _gbbba: _aaccg}
	_aaccg._aeddbb = _df.MakeIndirectObject(_gfca)
	return _aaccg
}

// NewPdfAnnotationWatermark returns a new watermark annotation.
func NewPdfAnnotationWatermark() *PdfAnnotationWatermark {
	_ffbf := NewPdfAnnotation()
	_aeab := &PdfAnnotationWatermark{}
	_aeab.PdfAnnotation = _ffbf
	_ffbf.SetContext(_aeab)
	return _aeab
}

// ToPdfObject converts the ID tree to a PDF object.
func (_aefce *IDTree) ToPdfObject() _df.PdfObject {
	_eccfe := _df.MakeDict()
	if _aefce.Names != nil && _aefce.Names.Len() > 0 {
		_eccfe.Set("\u004e\u0061\u006de\u0073", _aefce.Names)
		_eccfe.Set("\u004c\u0069\u006d\u0069\u0074\u0073", _aefce.Limits)
	}
	if len(_aefce.Kids) > 0 {
		_dddc := _df.MakeArray()
		for _, _gegfd := range _aefce.Kids {
			_dddc.Append(_gegfd.ToPdfObject())
		}
		_dgfcb := _df.MakeDict()
		_dgfcb.Set("\u004b\u0069\u0064\u0073", _dddc)
		_eccfe.Set("\u004b\u0069\u0064\u0073", _dgfcb)
	}
	return _eccfe
}

// PdfFieldText represents a text field where user can enter text.
type PdfFieldText struct {
	*PdfField
	DA     *_df.PdfObjectString
	Q      *_df.PdfObjectInteger
	DS     *_df.PdfObjectString
	RV     _df.PdfObject
	MaxLen *_df.PdfObjectInteger
}

// GetContainingPdfObject returns the container of the shading object (indirect object).
func (_cabe *PdfShading) GetContainingPdfObject() _df.PdfObject { return _cabe._bgdag }

func (_ffba *PdfColorspaceSpecialIndexed) String() string {
	return "\u0049n\u0064\u0065\u0078\u0065\u0064"
}

var _ pdfFont = (*pdfFontSimple)(nil)

// NewPdfDate returns a new PdfDate object from a PDF date string (see 7.9.4 Dates).
// format: "D: YYYYMMDDHHmmSSOHH'mm"
func NewPdfDate(dateStr string) (PdfDate, error) {
	_bdaad, _dabbe := _bbe.ParsePdfTime(dateStr)
	if _dabbe != nil {
		return PdfDate{}, _dabbe
	}
	return NewPdfDateFromTime(_bdaad)
}

func _cffdd(_fcdce *_df.PdfObjectStream) (*PdfFunctionType4, error) {
	_badf := &PdfFunctionType4{}
	_badf._ebea = _fcdce
	_aaeb := _fcdce.PdfObjectDictionary
	_efafb, _eceb := _df.TraceToDirectObject(_aaeb.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_df.PdfObjectArray)
	if !_eceb {
		_bcd.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _deb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _efafb.Len()%2 != 0 {
		_bcd.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _deb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_gbdb, _gbfgg := _efafb.ToFloat64Array()
	if _gbfgg != nil {
		return nil, _gbfgg
	}
	_badf.Domain = _gbdb
	_efafb, _eceb = _df.TraceToDirectObject(_aaeb.Get("\u0052\u0061\u006eg\u0065")).(*_df.PdfObjectArray)
	if _eceb {
		if _efafb.Len() < 0 || _efafb.Len()%2 != 0 {
			return nil, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_eccd, _ebfbb := _efafb.ToFloat64Array()
		if _ebfbb != nil {
			return nil, _ebfbb
		}
		_badf.Range = _eccd
	}
	_eaaee, _gbfgg := _df.DecodeStream(_fcdce)
	if _gbfgg != nil {
		return nil, _gbfgg
	}
	_badf._acbe = _eaaee
	_edgdb := _eg.NewPSParser(_eaaee)
	_aaefgc, _gbfgg := _edgdb.Parse()
	if _gbfgg != nil {
		return nil, _gbfgg
	}
	_badf.Program = _aaefgc
	return _badf, nil
}

// Resample resamples the image data converting from current BitsPerComponent to a target BitsPerComponent
// value.  Sets the image's BitsPerComponent to the target value following resampling.
//
// For example, converting an 8-bit RGB image to 1-bit grayscale (common for scanned images):
//
//	// Convert RGB image to grayscale.
//	rgbColorSpace := pdf.NewPdfColorspaceDeviceRGB()
//	grayImage, err := rgbColorSpace.ImageToGray(rgbImage)
//	if err != nil {
//	  return err
//	}
//	// Resample as 1 bit.
//	grayImage.Resample(1)
func (_abdfe *Image) Resample(targetBitsPerComponent int64) {
	if _abdfe.BitsPerComponent == targetBitsPerComponent {
		return
	}
	_ggbge := _abdfe.GetSamples()
	if targetBitsPerComponent < _abdfe.BitsPerComponent {
		_ebdac := _abdfe.BitsPerComponent - targetBitsPerComponent
		for _geac := range _ggbge {
			_ggbge[_geac] >>= uint(_ebdac)
		}
	} else if targetBitsPerComponent > _abdfe.BitsPerComponent {
		_cfed := targetBitsPerComponent - _abdfe.BitsPerComponent
		for _fdbag := range _ggbge {
			_ggbge[_fdbag] <<= uint(_cfed)
		}
	}
	_abdfe.BitsPerComponent = targetBitsPerComponent
	if _abdfe.BitsPerComponent < 8 {
		_abdfe.resampleLowBits(_ggbge)
		return
	}
	_dbge := _bge.BytesPerLine(int(_abdfe.Width), int(_abdfe.BitsPerComponent), _abdfe.ColorComponents)
	_dddf := make([]byte, _dbge*int(_abdfe.Height))
	var (
		_bddde, _gdgc, _dccg, _ceage int
		_abea                        uint32
	)
	for _dccg = 0; _dccg < int(_abdfe.Height); _dccg++ {
		_bddde = _dccg * _dbge
		_gdgc = (_dccg+1)*_dbge - 1
		_dagf := _aff.ResampleUint32(_ggbge[_bddde:_gdgc], int(targetBitsPerComponent), 8)
		for _ceage, _abea = range _dagf {
			_dddf[_ceage+_bddde] = byte(_abea)
		}
	}
	_abdfe.Data = _dddf
}

// GetRevisionNumber returns the version of the current Pdf document
func (_egdfc *PdfReader) GetRevisionNumber() int { return _egdfc._gfdaag.GetRevisionNumber() }

// NewEmbeddedFileFromContent construct a new EmbeddedFile from supplied file content.
func NewEmbeddedFileFromContent(content []byte) (*EmbeddedFile, error) {
	_cead := _be.Detect(content)
	_dgef := _af.Sum(content)
	_bgcag := &EmbeddedFile{Name: "\u0061\u0074\u0074\u0061\u0063\u0068\u006d\u0065\u006e\u0074", Content: content, FileType: _cead.String(), Hash: _ab.EncodeToString(_dgef[:])}
	return _bgcag, nil
}

// String returns a string representation of what flags are set.
func (_abeba FieldFlag) String() string {
	_gdbcg := ""
	if _abeba == FieldFlagClear {
		_gdbcg = "\u0043\u006c\u0065a\u0072"
		return _gdbcg
	}
	if _abeba&FieldFlagReadOnly > 0 {
		_gdbcg += "\u007cR\u0065\u0061\u0064\u004f\u006e\u006cy"
	}
	if _abeba&FieldFlagRequired > 0 {
		_gdbcg += "\u007cR\u0065\u0071\u0075\u0069\u0072\u0065d"
	}
	if _abeba&FieldFlagNoExport > 0 {
		_gdbcg += "\u007cN\u006f\u0045\u0078\u0070\u006f\u0072t"
	}
	if _abeba&FieldFlagNoToggleToOff > 0 {
		_gdbcg += "\u007c\u004e\u006f\u0054\u006f\u0067\u0067\u006c\u0065T\u006f\u004f\u0066\u0066"
	}
	if _abeba&FieldFlagRadio > 0 {
		_gdbcg += "\u007c\u0052\u0061\u0064\u0069\u006f"
	}
	if _abeba&FieldFlagPushbutton > 0 {
		_gdbcg += "|\u0050\u0075\u0073\u0068\u0062\u0075\u0074\u0074\u006f\u006e"
	}
	if _abeba&FieldFlagRadiosInUnision > 0 {
		_gdbcg += "\u007c\u0052a\u0064\u0069\u006fs\u0049\u006e\u0055\u006e\u0069\u0073\u0069\u006f\u006e"
	}
	if _abeba&FieldFlagMultiline > 0 {
		_gdbcg += "\u007c\u004d\u0075\u006c\u0074\u0069\u006c\u0069\u006e\u0065"
	}
	if _abeba&FieldFlagPassword > 0 {
		_gdbcg += "\u007cP\u0061\u0073\u0073\u0077\u006f\u0072d"
	}
	if _abeba&FieldFlagFileSelect > 0 {
		_gdbcg += "|\u0046\u0069\u006c\u0065\u0053\u0065\u006c\u0065\u0063\u0074"
	}
	if _abeba&FieldFlagDoNotScroll > 0 {
		_gdbcg += "\u007c\u0044\u006fN\u006f\u0074\u0053\u0063\u0072\u006f\u006c\u006c"
	}
	if _abeba&FieldFlagComb > 0 {
		_gdbcg += "\u007c\u0043\u006fm\u0062"
	}
	if _abeba&FieldFlagRichText > 0 {
		_gdbcg += "\u007cR\u0069\u0063\u0068\u0054\u0065\u0078t"
	}
	if _abeba&FieldFlagDoNotSpellCheck > 0 {
		_gdbcg += "\u007c\u0044o\u004e\u006f\u0074S\u0070\u0065\u006c\u006c\u0043\u0068\u0065\u0063\u006b"
	}
	if _abeba&FieldFlagCombo > 0 {
		_gdbcg += "\u007c\u0043\u006f\u006d\u0062\u006f"
	}
	if _abeba&FieldFlagEdit > 0 {
		_gdbcg += "\u007c\u0045\u0064i\u0074"
	}
	if _abeba&FieldFlagSort > 0 {
		_gdbcg += "\u007c\u0053\u006fr\u0074"
	}
	if _abeba&FieldFlagMultiSelect > 0 {
		_gdbcg += "\u007c\u004d\u0075l\u0074\u0069\u0053\u0065\u006c\u0065\u0063\u0074"
	}
	if _abeba&FieldFlagCommitOnSelChange > 0 {
		_gdbcg += "\u007cC\u006fm\u006d\u0069\u0074\u004f\u006eS\u0065\u006cC\u0068\u0061\u006e\u0067\u0065"
	}
	return _gc.Trim(_gdbcg, "\u007c")
}

func (_daaad *LTV) validateSig(_cdea *PdfSignature) error {
	if _cdea == nil || _cdea.Contents == nil || len(_cdea.Contents.Bytes()) == 0 {
		return _c.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0066\u0069\u0065l\u0064:\u0020\u0025\u0076", _cdea)
	}
	return nil
}

// GetRotate gets the inheritable rotate value, either from the page
// or a higher up page/pages struct.
func (_fbacg *PdfPage) GetRotate() (int64, error) {
	if _fbacg.Rotate != nil {
		return *_fbacg.Rotate, nil
	}
	_efceb := _fbacg.Parent
	for _efceb != nil {
		_dgfea, _ggaa := _df.GetDict(_efceb)
		if !_ggaa {
			return 0, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079")
		}
		if _bacb := _dgfea.Get("\u0052\u006f\u0074\u0061\u0074\u0065"); _bacb != nil {
			_ffbacf, _eabdd := _df.GetInt(_bacb)
			if !_eabdd {
				return 0, _deb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0074a\u0074\u0065\u0020\u0076al\u0075\u0065")
			}
			if _ffbacf != nil {
				return int64(*_ffbacf), nil
			}
			return 0, _deb.New("\u0072\u006f\u0074\u0061te\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		}
		_efceb = _dgfea.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return 0, _deb.New("\u0072o\u0074a\u0074\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064")
}

func _fafcf(_bgab _df.PdfObject, _beca bool) (*PdfFont, error) {
	_ecaf, _gebdc, _eeaf := _cgae(_bgab)
	if _ecaf != nil {
		_acbfe(_ecaf)
	}
	if _eeaf != nil {
		if _eeaf == ErrType1CFontNotSupported {
			_fbgd, _fbabf := _aeda(_ecaf, _gebdc, nil)
			if _fbabf != nil {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0057h\u0069\u006c\u0065 l\u006f\u0061\u0064\u0069\u006e\u0067 \u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072=\u0025\u0076", _gebdc, _fbabf)
				return nil, _eeaf
			}
			return &PdfFont{_eaeg: _fbgd}, _eeaf
		}
		return nil, _eeaf
	}
	_gabe := &PdfFont{}
	switch _gebdc._fgfae {
	case "\u0054\u0079\u0070e\u0030":
		if !_beca {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u004c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u00650\u0020\u006e\u006f\u0074\u0020\u0061\u006c\u006c\u006f\u0077\u0065\u0064\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _gebdc)
			return nil, _deb.New("\u0063\u0079\u0063\u006cic\u0061\u006c\u0020\u0074\u0079\u0070\u0065\u0030\u0020\u006c\u006f\u0061\u0064\u0069n\u0067")
		}
		_cgadd, _ffabcg := _cbcce(_ecaf, _gebdc)
		if _ffabcg != nil {
			_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0057\u0068\u0069l\u0065\u0020\u006c\u006f\u0061\u0064\u0069ng\u0020\u0054\u0079\u0070e\u0030\u0020\u0066\u006f\u006e\u0074\u002e\u0020\u0066on\u0074\u003d%\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _gebdc, _ffabcg)
			return nil, _ffabcg
		}
		_gabe._eaeg = _cgadd
	case "\u0054\u0079\u0070e\u0031", "\u004dM\u0054\u0079\u0070\u0065\u0031", "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065":
		var _dgae *pdfFontSimple
		_bdfb, _cgccb := _da.NewStdFontByName(_da.StdFontName(_gebdc._gddcf))
		if _cgccb {
			_eecaf := _acfc(_bdfb)
			_gabe._eaeg = &_eecaf
			_bffe := _df.TraceToDirectObject(_eecaf.ToPdfObject())
			_agefc, _ddde, _faegc := _cgae(_bffe)
			if _faegc != nil {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0064\u0020\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u00314\u000a\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u000a\u0009\u0073\u0074d\u003d\u0025\u002b\u0076", _gebdc, _eecaf)
				return nil, _faegc
			}
			for _, _gbfc := range _ecaf.Keys() {
				_agefc.Set(_gbfc, _ecaf.Get(_gbfc))
			}
			_dgae, _faegc = _aeda(_agefc, _ddde, _eecaf._geecc)
			if _faegc != nil {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0064\u0020\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u00314\u000a\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u000a\u0009\u0073\u0074d\u003d\u0025\u002b\u0076", _gebdc, _eecaf)
				return nil, _faegc
			}
			_dgae._ffefd = _eecaf._ffefd
			_dgae._aeeed = _eecaf._aeeed
			if _dgae._abegg == nil {
				_dgae._abegg = _eecaf._abegg
			}
		} else {
			_dgae, _eeaf = _aeda(_ecaf, _gebdc, nil)
			if _eeaf != nil {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0057h\u0069\u006c\u0065 l\u006f\u0061\u0064\u0069\u006e\u0067 \u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072=\u0025\u0076", _gebdc, _eeaf)
				return nil, _eeaf
			}
		}
		_eeaf = _dgae.addEncoding()
		if _eeaf != nil {
			return nil, _eeaf
		}
		if _cgccb {
			_dgae.updateStandard14Font()
		}
		if _cgccb && _dgae._ebgg == nil && _dgae._geecc == nil {
			_bcd.Log.Error("\u0073\u0069\u006d\u0070\u006c\u0065\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _dgae)
			_bcd.Log.Error("\u0066n\u0074\u003d\u0025\u002b\u0076", _bdfb)
		}
		if len(_dgae._ffefd) == 0 {
			_bcd.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u004e\u006f\u0020\u0077\u0069d\u0074h\u0073.\u0020\u0066\u006f\u006e\u0074\u003d\u0025s", _dgae)
		}
		_gabe._eaeg = _dgae
	case "\u0054\u0079\u0070e\u0033":
		_geggc, _aebc := _abecf(_ecaf, _gebdc)
		if _aebc != nil {
			_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020W\u0068\u0069\u006c\u0065\u0020\u006co\u0061\u0064\u0069\u006e\u0067\u0020\u0074y\u0070\u0065\u0033\u0020\u0066\u006f\u006e\u0074\u003a\u0020%\u0076", _aebc)
			return nil, _aebc
		}
		_gabe._eaeg = _geggc
	case "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030":
		_cfecd, _ceaeab := _bddgg(_ecaf, _gebdc)
		if _ceaeab != nil {
			_bcd.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0057\u0068i\u006c\u0065\u0020l\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0069d \u0066\u006f\u006et\u0020\u0074y\u0070\u0065\u0030\u0020\u0066\u006fn\u0074\u003a \u0025\u0076", _ceaeab)
			return nil, _ceaeab
		}
		_gabe._eaeg = _cfecd
	case "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032":
		_fcea, _ebbe := _efddd(_ecaf, _gebdc)
		if _ebbe != nil {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0057\u0068\u0069l\u0065\u0020\u006co\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0069\u0064\u0020f\u006f\u006e\u0074\u0020\u0074yp\u0065\u0032\u0020\u0066\u006f\u006e\u0074\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _gebdc, _ebbe)
			return nil, _ebbe
		}
		_gabe._eaeg = _fcea
	default:
		_bcd.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020f\u006f\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073", _gebdc)
		return nil, _c.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0066\u006f\u006e\u0074\u0020\u0074y\u0070\u0065\u003a\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _gebdc)
	}
	return _gabe, nil
}

// SetHideWindowUI sets the value of the hideWindowUI flag.
func (_eafdb *ViewerPreferences) SetHideWindowUI(hideWindowUI bool) { _eafdb._dbfebfg = &hideWindowUI }

// GetContentStreamWithEncoder returns the pattern cell's content stream and its encoder
func (_acgd *PdfTilingPattern) GetContentStreamWithEncoder() ([]byte, _df.StreamEncoder, error) {
	_ggfba, _ccgad := _acgd._cbce.(*_df.PdfObjectStream)
	if !_ccgad {
		_bcd.Log.Debug("\u0054\u0069l\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _acgd._cbce)
		return nil, nil, _df.ErrTypeError
	}
	_acdad, _aadbg := _df.DecodeStream(_ggfba)
	if _aadbg != nil {
		_bcd.Log.Debug("\u0046\u0061\u0069l\u0065\u0064\u0020\u0064e\u0063\u006f\u0064\u0069\u006e\u0067\u0020s\u0074\u0072\u0065\u0061\u006d\u002c\u0020\u0065\u0072\u0072\u003a\u0020\u0025\u0076", _aadbg)
		return nil, nil, _aadbg
	}
	_abcc, _aadbg := _df.NewEncoderFromStream(_ggfba)
	if _aadbg != nil {
		_bcd.Log.Debug("F\u0061\u0069\u006c\u0065\u0064\u0020f\u0069\u006e\u0064\u0069\u006e\u0067 \u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020%\u0076", _aadbg)
		return nil, nil, _aadbg
	}
	return _acdad, _abcc, nil
}

// RunesToCharcodeBytes maps the provided runes to charcode bytes and it
// returns the resulting slice of bytes, along with the number of runes which
// could not be converted. If the number of misses is 0, all runes were
// successfully converted.
func (_efacbb *PdfFont) RunesToCharcodeBytes(data []rune) ([]byte, int) {
	var _acaa []_abg.TextEncoder
	var _gdbf _abg.CMapEncoder
	if _bbgf := _efacbb.baseFields()._afcbd; _bbgf != nil {
		_gdbf = _abg.NewCMapEncoder("", nil, _bbgf)
	}
	_gbegb := _efacbb.Encoder()
	if _gbegb != nil {
		switch _adfbd := _gbegb.(type) {
		case _abg.SimpleEncoder:
			_cfbfc := _adfbd.BaseName()
			if _, _ccdd := _cfaf[_cfbfc]; _ccdd {
				_acaa = append(_acaa, _gbegb)
			}
		}
	}
	if len(_acaa) == 0 {
		if _efacbb.baseFields()._afcbd != nil {
			_acaa = append(_acaa, _gdbf)
		}
		if _gbegb != nil {
			_acaa = append(_acaa, _gbegb)
		}
	}
	var _ggdcc _ef.Buffer
	var _cbde int
	for _, _fdcb := range data {
		var _aaeab bool
		for _, _cdgff := range _acaa {
			if _gbgd := _cdgff.Encode(string(_fdcb)); len(_gbgd) > 0 {
				_ggdcc.Write(_gbgd)
				_aaeab = true
				break
			}
		}
		if !_aaeab {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020f\u0061\u0069\u006ce\u0064\u0020\u0074\u006f \u006d\u0061\u0070\u0020\u0072\u0075\u006e\u0065\u0020\u0060\u0025\u002b\u0071\u0060\u0020\u0074\u006f\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065", _fdcb)
			_cbde++
		}
	}
	if _cbde != 0 {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0061\u006cl\u0020\u0072\u0075\u006e\u0065\u0073\u0020\u0074\u006f\u0020\u0063\u0068\u0061\u0072c\u006fd\u0065\u0073\u002e\u000a"+"\u0009\u006e\u0075\u006d\u0052\u0075\u006e\u0065\u0073\u003d\u0025d\u0020\u006e\u0075\u006d\u004d\u0069\u0073\u0073\u0065\u0073=\u0025\u0064\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073 \u0065\u006e\u0063\u006f\u0064e\u0072\u0073\u003d\u0025\u002b\u0076", len(data), _cbde, _efacbb, _acaa)
	}
	return _ggdcc.Bytes(), _cbde
}

// GetContainingPdfObject implements model.PdfModel interface.
func (_fdgdf *PdfOutputIntent) GetContainingPdfObject() _df.PdfObject { return _fdgdf._eeff }

func _afgcg() string { return _bcd.Version }

// GetXObjectImageByName returns the XObjectImage with the specified name from the
// page resources, if it exists.
func (_eadc *PdfPageResources) GetXObjectImageByName(keyName _df.PdfObjectName) (*XObjectImage, error) {
	_gcbg, _gfbbf := _eadc.GetXObjectByName(keyName)
	if _gcbg == nil {
		return nil, nil
	}
	if _gfbbf != XObjectTypeImage {
		return nil, _deb.New("\u006e\u006f\u0074 \u0061\u006e\u0020\u0069\u006d\u0061\u0067\u0065")
	}
	_gadac, _bafdcb := NewXObjectImageFromStream(_gcbg)
	if _bafdcb != nil {
		return nil, _bafdcb
	}
	return _gadac, nil
}

// PdfColorspaceCalGray represents CalGray color space.
type PdfColorspaceCalGray struct {
	WhitePoint []float64
	BlackPoint []float64
	Gamma      float64
	_faadg     *_df.PdfIndirectObject
}

// NewPdfShadingPatternType3 creates an empty shading pattern type 3 object.
func NewPdfShadingPatternType3() *PdfShadingPatternType3 {
	_bbbe := &PdfShadingPatternType3{}
	_bbbe.Matrix = _df.MakeArrayFromIntegers([]int{1, 0, 0, 1, 0, 0})
	_bbbe.PdfPattern = &PdfPattern{}
	_bbbe.PdfPattern.PatternType = int64(*_df.MakeInteger(2))
	_bbbe.PdfPattern._ecfde = _bbbe
	_bbbe.PdfPattern._cbce = _df.MakeIndirectObject(_df.MakeDict())
	return _bbbe
}

// ToPdfObject implements interface PdfModel.
func (_aaed *PdfAnnotationCaret) ToPdfObject() _df.PdfObject {
	_aaed.PdfAnnotation.ToPdfObject()
	_gfgb := _aaed._bfde
	_dggd := _gfgb.PdfObject.(*_df.PdfObjectDictionary)
	_aaed.PdfAnnotationMarkup.appendToPdfDictionary(_dggd)
	_dggd.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0043\u0061\u0072e\u0074"))
	_dggd.SetIfNotNil("\u0052\u0044", _aaed.RD)
	_dggd.SetIfNotNil("\u0053\u0079", _aaed.Sy)
	return _gfgb
}

// GetAlphabet returns a map of the runes in `text` and their frequencies.
func GetAlphabet(text string) map[rune]int {
	_efgb := map[rune]int{}
	for _, _fabbf := range text {
		_efgb[_fabbf]++
	}
	return _efgb
}

func (_decec *LTV) getCerts(_gecdf []*_ed.Certificate) ([][]byte, error) {
	_gcec := make([][]byte, 0, len(_gecdf))
	for _, _dbcgg := range _gecdf {
		_gcec = append(_gcec, _dbcgg.Raw)
	}
	return _gcec, nil
}

// EnableByName LTV enables the signature dictionary of the PDF AcroForm
// field identified the specified name. The signing certificate chain is
// extracted from the signature dictionary. Optionally, additional certificates
// can be specified through the `extraCerts` parameter. The LTV client attempts
// to build the certificate chain up to a trusted root by downloading any
// missing certificates.
func (_bgggb *LTV) EnableByName(name string, extraCerts []*_ed.Certificate) error {
	_ggbfa := _bgggb._cdad._abf.AcroForm
	for _, _agcf := range _ggbfa.AllFields() {
		_bgdg, _ := _agcf.GetContext().(*PdfFieldSignature)
		if _bgdg == nil {
			continue
		}
		if _gcgda := _bgdg.PartialName(); _gcgda != name {
			continue
		}
		return _bgggb.Enable(_bgdg.V, extraCerts)
	}
	return nil
}

// PdfAcroForm represents the AcroForm dictionary used for representation of form data in PDF.
type PdfAcroForm struct {
	Fields          *[]*PdfField
	NeedAppearances *_df.PdfObjectBool
	SigFlags        *_df.PdfObjectInteger
	CO              *_df.PdfObjectArray
	DR              *PdfPageResources
	DA              *_df.PdfObjectString
	Q               *_df.PdfObjectInteger
	XFA             _df.PdfObject

	// ADBEEchoSign extra objects from Adobe Acrobat, causing signature invalid if not exists.
	ADBEEchoSign _df.PdfObject
	_cffeg       *_df.PdfIndirectObject
	_caead       bool
}

// String returns a string that describes `font`.
func (_bgfa *PdfFont) String() string {
	_gcdb := ""
	if _bgfa._eaeg.Encoder() != nil {
		_gcdb = _bgfa._eaeg.Encoder().String()
	}
	return _c.Sprintf("\u0046\u004f\u004e\u0054\u007b\u0025\u0054\u0020\u0025s\u0020\u0025\u0073\u007d", _bgfa._eaeg, _bgfa.baseFields().coreString(), _gcdb)
}

// GetNumPages returns the number of pages in the document.
func (_bcgfd *PdfReader) GetNumPages() (int, error) {
	if _bcgfd._gfdaag.GetCrypter() != nil && !_bcgfd._gfdaag.IsAuthenticated() {
		return 0, _c.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	return len(_bcgfd._dcfee), nil
}

// FieldValueProvider provides field values from a data source such as FDF, JSON or any other.
type FieldValueProvider interface {
	FieldValues() (map[string]_df.PdfObject, error)
}

func (_daead *PdfWriter) optimizeDocument() error {
	if _daead._fbcafd == nil {
		return nil
	}
	_ecffc, _gfged := _df.GetDict(_daead._caefe)
	if !_gfged {
		return _deb.New("\u0061\u006e\u0020in\u0066\u006f\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0069s\u0020n\u006ft\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_eegeg := _cb.Document{ID: [2]string{_daead._aadde, _daead._addee}, Version: _daead._aeffd, Objects: _daead._ceeac, Info: _ecffc, Crypt: _daead._fcdg, UseHashBasedID: _daead._aeebe}
	if _eedcg := _daead._fbcafd.ApplyStandard(&_eegeg); _eedcg != nil {
		return _eedcg
	}
	_daead._aadde, _daead._addee = _eegeg.ID[0], _eegeg.ID[1]
	_daead._aeffd = _eegeg.Version
	_daead._ceeac = _eegeg.Objects
	_daead._caefe.PdfObject = _eegeg.Info
	_daead._aeebe = _eegeg.UseHashBasedID
	_daead._fcdg = _eegeg.Crypt
	_gfffa := make(map[_df.PdfObject]struct{}, len(_daead._ceeac))
	for _, _fbggec := range _daead._ceeac {
		_gfffa[_fbggec] = struct{}{}
	}
	_daead._aadfbg = _gfffa
	return nil
}

// KDict represents a K dictionary object.
type KDict struct {

	// The structure type, a name object identifying the nature of the
	// structure element and its role within the document,
	// such as a chapter, paragraph, or footnote
	S _df.PdfObject

	// The structure element that is the immediate parent of this one
	// in the structure hierarchy.
	P _df.PdfObject

	// The element identifier, a byte string designating this structure element.
	ID *_df.PdfObjectString

	// A page object representing a page on which some or all of the content
	// items designated by the K entry shall be rendered.
	Pg _df.PdfObject

	// The children of this structure element.
	K _df.PdfObject

	// A single attribute object or array of attribute objects associated
	// with this structure element.
	A _df.PdfObject

	// An attribute class name or array of class names associated with
	// this structure element.
	C _df.PdfObject

	// The current revision number of this structure element
	R *_df.PdfObjectInteger

	// The title of the structure element, a text string representing
	// it in human-readable form.
	T *_df.PdfObjectString

	// A language identifier specifying the natural language for all text
	// in the structure element except where overridden by
	// language specifications for nested structure elements or marked content.
	Lang *_df.PdfObjectString

	// An alternate description of the structure element and its
	// children in human-readable form, which is useful when extracting
	// the document’s contents in support of accessibility to users with
	// disabilities or for other purposes.
	Alt *_df.PdfObjectString

	// The expanded form of an abbreviation.
	E *_df.PdfObjectString

	// Text that is an exact replacement for the structure element and its children.
	ActualText *_df.PdfObjectString
	_dacfd     []*KValue
	_cabee     int64
	_bcbaeb    *PdfRectangle
}

var (
	ErrRequiredAttributeMissing = _deb.New("\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074t\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067")
	ErrInvalidAttribute         = _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065")
	ErrTypeCheck                = _deb.New("\u0074\u0079\u0070\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	_badg                       = _deb.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	ErrEncrypted                = _deb.New("\u0066\u0069\u006c\u0065\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	ErrNoFont                   = _deb.New("\u0066\u006fn\u0074\u0020\u006eo\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064")
	ErrFontNotSupported         = _db.Errorf("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u006fn\u0074\u0020\u0028\u0025\u0077\u0029", _df.ErrNotSupported)
	ErrType1CFontNotSupported   = _db.Errorf("\u0054y\u0070\u00651\u0043\u0020\u0066o\u006e\u0074\u0073\u0020\u0061\u0072\u0065 \u006e\u006f\u0074\u0020\u0063\u0075r\u0072\u0065\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0028\u0025\u0077\u0029", _df.ErrNotSupported)
	ErrType3FontNotSupported    = _db.Errorf("\u0054y\u0070\u00653\u0020\u0066\u006f\u006et\u0073\u0020\u0061r\u0065\u0020\u006e\u006f\u0074\u0020\u0063\u0075\u0072re\u006e\u0074\u006cy\u0020\u0073u\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0028%\u0077\u0029", _df.ErrNotSupported)
	ErrTTCmapNotSupported       = _db.Errorf("\u0075\u006es\u0075\u0070\u0070\u006fr\u0074\u0065d\u0020\u0054\u0072\u0075\u0065\u0054\u0079\u0070e\u0020\u0063\u006d\u0061\u0070\u0020\u0066\u006f\u0072\u006d\u0061\u0074 \u0028\u0025\u0077\u0029", _df.ErrNotSupported)
	ErrSignNotEnoughSpace       = _db.Errorf("\u0069\u006e\u0073\u0075\u0066\u0066\u0069c\u0069\u0065\u006et\u0020\u0073\u0070a\u0063\u0065 \u0061\u006c\u006c\u006f\u0063\u0061t\u0065d \u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0073")
	ErrSignNoCertificates       = _db.Errorf("\u0063\u006ful\u0064\u0020\u006eo\u0074\u0020\u0072\u0065tri\u0065ve\u0020\u0063\u0065\u0072\u0074\u0069\u0066ic\u0061\u0074\u0065\u0020\u0063\u0068\u0061i\u006e")
)

// SetPrintClip sets the value of the printClip.
func (_fcbcd *ViewerPreferences) SetPrintClip(printClip PageBoundary) { _fcbcd._edeeb = printClip }

// ToPdfObject implements interface PdfModel.
func (_gba *PdfActionJavaScript) ToPdfObject() _df.PdfObject {
	_gba.PdfAction.ToPdfObject()
	_cef := _gba._gcf
	_bea := _cef.PdfObject.(*_df.PdfObjectDictionary)
	_bea.SetIfNotNil("\u0053", _df.MakeName(string(ActionTypeJavaScript)))
	_bea.SetIfNotNil("\u004a\u0053", _gba.JS)
	return _cef
}

// NewXObjectFormFromStream builds the Form XObject from a stream object.
// TODO: Should this be exposed? Consider different access points.
func NewXObjectFormFromStream(stream *_df.PdfObjectStream) (*XObjectForm, error) {
	_adbfa := &XObjectForm{}
	_adbfa._bbfeg = stream
	_gebg := *(stream.PdfObjectDictionary)
	_gbcgg, _cfega := _df.NewEncoderFromStream(stream)
	if _cfega != nil {
		return nil, _cfega
	}
	_adbfa.Filter = _gbcgg
	if _dfaad := _gebg.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"); _dfaad != nil {
		_ceegb, _ddagd := _dfaad.(*_df.PdfObjectName)
		if !_ddagd {
			return nil, _deb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		if *_ceegb != "\u0046\u006f\u0072\u006d" {
			_bcd.Log.Debug("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072m\u0020\u0073\u0075\u0062ty\u0070\u0065")
			return nil, _deb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072m\u0020\u0073\u0075\u0062ty\u0070\u0065")
		}
	}
	if _cfda := _gebg.Get("\u0046\u006f\u0072\u006d\u0054\u0079\u0070\u0065"); _cfda != nil {
		_adbfa.FormType = _cfda
	}
	if _adbgg := _gebg.Get("\u0042\u0042\u006f\u0078"); _adbgg != nil {
		_adbfa.BBox = _adbgg
	}
	if _aeeggf := _gebg.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _aeeggf != nil {
		_adbfa.Matrix = _aeeggf
	}
	if _efcf := _gebg.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _efcf != nil {
		_efcf = _df.TraceToDirectObject(_efcf)
		_agbeb, _eedace := _efcf.(*_df.PdfObjectDictionary)
		if !_eedace {
			_bcd.Log.Debug("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0058\u004f\u0062j\u0065c\u0074\u0020\u0046\u006f\u0072\u006d\u0020\u0052\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006f\u0062j\u0065\u0063\u0074\u002c\u0020\u0070\u006f\u0069\u006e\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
			return nil, _df.ErrTypeError
		}
		_egcabb, _aabdf := NewPdfPageResourcesFromDict(_agbeb)
		if _aabdf != nil {
			_bcd.Log.Debug("\u0046\u0061i\u006c\u0065\u0064\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u006d\u0020\u0072\u0065\u0073\u006f\u0075rc\u0065\u0073")
			return nil, _aabdf
		}
		_adbfa.Resources = _egcabb
		_bcd.Log.Trace("\u0046\u006f\u0072\u006d r\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u003a\u0020\u0025\u0023\u0076", _adbfa.Resources)
	}
	_adbfa.Group = _gebg.Get("\u0047\u0072\u006fu\u0070")
	_adbfa.Ref = _gebg.Get("\u0052\u0065\u0066")
	_adbfa.MetaData = _gebg.Get("\u004d\u0065\u0074\u0061\u0044\u0061\u0074\u0061")
	_adbfa.PieceInfo = _gebg.Get("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o")
	_adbfa.LastModified = _gebg.Get("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064")
	_adbfa.StructParent = _gebg.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074")
	_adbfa.StructParents = _gebg.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073")
	_adbfa.OPI = _gebg.Get("\u004f\u0050\u0049")
	_adbfa.OC = _gebg.Get("\u004f\u0043")
	_adbfa.Name = _gebg.Get("\u004e\u0061\u006d\u0065")
	_adbfa.Stream = stream.Stream
	return _adbfa, nil
}

// BytesToCharcodes converts the bytes in a PDF string to character codes.
func (_afge *PdfFont) BytesToCharcodes(data []byte) []_abg.CharCode {
	_bcd.Log.Trace("\u0042\u0079\u0074es\u0054\u006f\u0043\u0068\u0061\u0072\u0063\u006f\u0064e\u0073:\u0020d\u0061t\u0061\u003d\u005b\u0025\u0020\u0030\u0032\u0078\u005d\u003d\u0025\u0023\u0071", data, data)
	if _beebc, _fadf := _afge._eaeg.(*pdfFontType0); _fadf && _beebc._eabf != nil {
		if _ecdf, _fbdac := _beebc.bytesToCharcodes(data); _fbdac {
			return _ecdf
		}
	}
	var (
		_gecg  = make([]_abg.CharCode, 0, len(data)+len(data)%2)
		_dggdg = _afge.baseFields()
	)
	if _dggdg._afcbd != nil {
		if _efbbc, _edbf := _dggdg._afcbd.BytesToCharcodes(data); _edbf {
			for _, _baee := range _efbbc {
				_gecg = append(_gecg, _abg.CharCode(_baee))
			}
			return _gecg
		}
	}
	if _dggdg.isCIDFont() {
		if len(data) == 1 {
			data = []byte{0, data[0]}
		}
		if len(data)%2 != 0 {
			_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0064\u0061\u0074\u0061\u003d\u0025\u002b\u0076\u0020t\u006f\u0020\u0065\u0076\u0065n\u0020\u006ce\u006e\u0067\u0074\u0068", data)
			data = append(data, 0)
		}
		for _bgdae := 0; _bgdae < len(data); _bgdae += 2 {
			_fgca := uint16(data[_bgdae])<<8 | uint16(data[_bgdae+1])
			_gecg = append(_gecg, _abg.CharCode(_fgca))
		}
	} else {
		for _, _beee := range data {
			_gecg = append(_gecg, _abg.CharCode(_beee))
		}
	}
	return _gecg
}

func (_fabdc Image) getBase() _bge.ImageBase {
	return _bge.NewImageBase(int(_fabdc.Width), int(_fabdc.Height), int(_fabdc.BitsPerComponent), _fabdc.ColorComponents, _fabdc.Data, _fabdc._gebab, _fabdc._bebgb)
}

func (_ecbaad *PdfWriter) copyObjects() {
	_aeddc := make(map[_df.PdfObject]_df.PdfObject)
	_abege := make([]_df.PdfObject, 0, len(_ecbaad._ceeac))
	_aagec := make(map[_df.PdfObject]struct{}, len(_ecbaad._ceeac))
	_dbgd := make(map[_df.PdfObject]struct{})
	for _, _cgfgc := range _ecbaad._ceeac {
		_gadcg := _ecbaad.copyObject(_cgfgc, _aeddc, _dbgd, false)
		if _, _aacd := _dbgd[_cgfgc]; _aacd {
			continue
		}
		_abege = append(_abege, _gadcg)
		_aagec[_gadcg] = struct{}{}
	}
	_ecbaad._ceeac = _abege
	_ecbaad._aadfbg = _aagec
	_ecbaad._caefe = _ecbaad.copyObject(_ecbaad._caefe, _aeddc, nil, false).(*_df.PdfIndirectObject)
	_ecbaad._aaag = _ecbaad.copyObject(_ecbaad._aaag, _aeddc, nil, false).(*_df.PdfIndirectObject)
	if _ecbaad._deega != nil {
		_ecbaad._deega = _ecbaad.copyObject(_ecbaad._deega, _aeddc, nil, false).(*_df.PdfIndirectObject)
	}
	if _ecbaad._gebfg {
		_bggdf := make(map[_df.PdfObject]int64)
		for _baaea, _cbaaf := range _ecbaad._gbga {
			if _dfegf, _gefea := _aeddc[_baaea]; _gefea {
				_bggdf[_dfegf] = _cbaaf
			} else {
				_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020a\u0070\u0070\u0065n\u0064\u0020\u006d\u006fd\u0065\u0020\u002d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0063\u006f\u0070\u0079\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0020\u006d\u0061\u0070")
			}
		}
		_ecbaad._gbga = _bggdf
	}
}

// NewPdfPage returns a new PDF page.
func NewPdfPage() *PdfPage {
	_efagg := PdfPage{}
	_efagg._gfcee = _df.MakeDict()
	_efagg.Resources = NewPdfPageResources()
	_edbbb := _df.PdfIndirectObject{}
	_edbbb.PdfObject = _efagg._gfcee
	_efagg._gcced = &_edbbb
	_efagg._agacd = *_efagg._gfcee
	return &_efagg
}

func (_dfbfd *pdfFontType3) baseFields() *fontCommon { return &_dfbfd.fontCommon }

func (_bbag *PdfReader) newPdfAnnotationSoundFromDict(_ebc *_df.PdfObjectDictionary) (*PdfAnnotationSound, error) {
	_baf := PdfAnnotationSound{}
	_gbbdd, _aae := _bbag.newPdfAnnotationMarkupFromDict(_ebc)
	if _aae != nil {
		return nil, _aae
	}
	_baf.PdfAnnotationMarkup = _gbbdd
	_baf.Name = _ebc.Get("\u004e\u0061\u006d\u0065")
	_baf.Sound = _ebc.Get("\u0053\u006f\u0075n\u0064")
	return &_baf, nil
}

// PdfAnnotationCaret represents Caret annotations.
// (Section 12.5.6.11).
type PdfAnnotationCaret struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	RD _df.PdfObject
	Sy _df.PdfObject
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_aafcf *PdfShadingType4) ToPdfObject() _df.PdfObject {
	_aafcf.PdfShading.ToPdfObject()
	_ecdbg, _eeceg := _aafcf.getShadingDict()
	if _eeceg != nil {
		_bcd.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _aafcf.BitsPerCoordinate != nil {
		_ecdbg.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _aafcf.BitsPerCoordinate)
	}
	if _aafcf.BitsPerComponent != nil {
		_ecdbg.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _aafcf.BitsPerComponent)
	}
	if _aafcf.BitsPerFlag != nil {
		_ecdbg.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _aafcf.BitsPerFlag)
	}
	if _aafcf.Decode != nil {
		_ecdbg.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _aafcf.Decode)
	}
	if _aafcf.Function != nil {
		if len(_aafcf.Function) == 1 {
			_ecdbg.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _aafcf.Function[0].ToPdfObject())
		} else {
			_afagg := _df.MakeArray()
			for _, _fceef := range _aafcf.Function {
				_afagg.Append(_fceef.ToPdfObject())
			}
			_ecdbg.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _afagg)
		}
	}
	return _aafcf._bgdag
}

// ToPdfObject converts the pdfFontSimple to its PDF representation for outputting.
func (_bacd *pdfFontSimple) ToPdfObject() _df.PdfObject {
	if _bacd._adbde == nil {
		_bacd._adbde = &_df.PdfIndirectObject{}
	}
	_deada := _bacd.baseFields().asPdfObjectDictionary("")
	_bacd._adbde.PdfObject = _deada
	if _bacd.FirstChar != nil {
		_deada.Set("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r", _bacd.FirstChar)
	}
	if _bacd.LastChar != nil {
		_deada.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", _bacd.LastChar)
	}
	if _bacd.Widths != nil {
		_deada.Set("\u0057\u0069\u0064\u0074\u0068\u0073", _bacd.Widths)
	}
	if _bacd.Encoding != nil {
		_deada.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _bacd.Encoding)
	} else if _bacd._ebgg != nil {
		_afgba := _bacd._ebgg.ToPdfObject()
		if _afgba != nil {
			_deada.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _afgba)
		}
	}
	return _bacd._adbde
}

// GetStandardApplier gets currently used StandardApplier..
func (_eegfc *PdfWriter) GetStandardApplier() StandardApplier { return _eegfc._fbcafd }

// GetDescent returns the Descent of the font `descriptor`.
func (_geed *PdfFontDescriptor) GetDescent() (float64, error) {
	return _df.GetNumberAsFloat(_geed.Descent)
}

// Read reads an image and loads into a new Image object with an RGB
// colormap and 8 bits per component.
func (_caacc DefaultImageHandler) Read(reader _bdd.Reader) (*Image, error) {
	_cfbb, _, _eddbe := _cg.Decode(reader)
	if _eddbe != nil {
		_bcd.Log.Debug("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _eddbe)
		return nil, _eddbe
	}
	return _caacc.NewImageFromGoImage(_cfbb)
}

// SetBoundingBox sets the bounding box in the attribute object.
func (_bggge *KDict) SetBoundingBox(x, y, width, height float64) {
	_bggge._bcbaeb = &PdfRectangle{Llx: x, Lly: y, Urx: x + width, Ury: y + height}
}

// UpdatePage updates the `page` in the new revision if it has changed.
func (_edd *PdfAppender) UpdatePage(page *PdfPage) {
	_edd.updateObjectsDeep(page.ToPdfObject(), nil)
}

// KValue is a wrapper object to hold various type of K's children objects.
type KValue struct {
	_eebde *KDict
	_ccgeg _df.PdfObject
	_dfca  *int
}

func _ceeg(_eebe *fontCommon) *pdfCIDFontType0 { return &pdfCIDFontType0{fontCommon: *_eebe} }

func _fagab() string { _gcdec.Lock(); defer _gcdec.Unlock(); return _baffd }

// PdfSignatureReference represents a PDF signature reference dictionary and is used for signing via form signature fields.
// (Section 12.8.1, Table 253 - Entries in a signature reference dictionary p. 469 in PDF32000_2008).
type PdfSignatureReference struct {
	_fabaf          *_df.PdfObjectDictionary
	Type            *_df.PdfObjectName
	TransformMethod *_df.PdfObjectName
	TransformParams _df.PdfObject
	Data            _df.PdfObject
	DigestMethod    *_df.PdfObjectName
}

// NewPdfRectangle creates a PDF rectangle object based on an input array of 4 integers.
// Defining the lower left (LL) and upper right (UR) corners with
// floating point numbers.
func NewPdfRectangle(arr _df.PdfObjectArray) (*PdfRectangle, error) {
	_dedeaf := PdfRectangle{}
	if arr.Len() != 4 {
		return nil, _deb.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0072\u0065\u0063\u0074\u0061\u006e\u0067\u006c\u0065\u0020\u0061\u0072r\u0061\u0079\u002c\u0020\u006c\u0065\u006e \u0021\u003d\u0020\u0034")
	}
	var _fdccf error
	_dedeaf.Llx, _fdccf = _df.GetNumberAsFloat(arr.Get(0))
	if _fdccf != nil {
		return nil, _fdccf
	}
	_dedeaf.Lly, _fdccf = _df.GetNumberAsFloat(arr.Get(1))
	if _fdccf != nil {
		return nil, _fdccf
	}
	_dedeaf.Urx, _fdccf = _df.GetNumberAsFloat(arr.Get(2))
	if _fdccf != nil {
		return nil, _fdccf
	}
	_dedeaf.Ury, _fdccf = _df.GetNumberAsFloat(arr.Get(3))
	if _fdccf != nil {
		return nil, _fdccf
	}
	return &_dedeaf, nil
}

// NewCompliancePdfReader creates a PdfReader or an input io.ReadSeeker that during reading will scan the files for the
// metadata details. It could be used for the PDF standard implementations like PDF/A or PDF/X.
// NOTE: This implementation is in experimental development state.
//
//	Keep in mind that it might change in the subsequent minor versions.
func NewCompliancePdfReader(rs _bdd.ReadSeeker) (*CompliancePdfReader, error) {
	const _gffb = "\u006d\u006f\u0064\u0065l\u003a\u004e\u0065\u0077\u0043\u006f\u006d\u0070\u006c\u0069a\u006ec\u0065\u0050\u0064\u0066\u0052\u0065\u0061d\u0065\u0072"
	_decg, _cfcf := _gafgf(rs, &ReaderOpts{ComplianceMode: true}, false, _gffb)
	if _cfcf != nil {
		return nil, _cfcf
	}
	return &CompliancePdfReader{PdfReader: _decg}, nil
}

// Fill populates `form` with values provided by `provider`.
func (_gabdgd *PdfAcroForm) Fill(provider FieldValueProvider) error {
	return _gabdgd.fill(provider, nil)
}

type pdfFontType0 struct {
	fontCommon
	_ddfda         *_df.PdfIndirectObject
	_gdbg          _abg.TextEncoder
	Encoding       _df.PdfObject
	DescendantFont *PdfFont
	_eabf          *_dgf.CMap
}

// NewPdfAnnotationFreeText returns a new free text annotation.
func NewPdfAnnotationFreeText() *PdfAnnotationFreeText {
	_ccd := NewPdfAnnotation()
	_dbd := &PdfAnnotationFreeText{}
	_dbd.PdfAnnotation = _ccd
	_dbd.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_ccd.SetContext(_dbd)
	return _dbd
}

// PdfAnnotationStrikeOut represents StrikeOut annotations.
// (Section 12.5.6.10).
type PdfAnnotationStrikeOut struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _df.PdfObject
}

// SetFontByName sets the font specified by keyName to the given object.
func (_bbdg *PdfPageResources) SetFontByName(keyName _df.PdfObjectName, obj _df.PdfObject) error {
	if _bbdg.Font == nil {
		_bbdg.Font = _df.MakeDict()
	}
	_gbde, _ebfd := _df.TraceToDirectObject(_bbdg.Font).(*_df.PdfObjectDictionary)
	if !_ebfd {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0021\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _df.TraceToDirectObject(_bbdg.Font))
		return _df.ErrTypeError
	}
	_gbde.Set(keyName, obj)
	return nil
}

// PdfAnnotationInk represents Ink annotations.
// (Section 12.5.6.13).
type PdfAnnotationInk struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	InkList _df.PdfObject
	BS      _df.PdfObject
}

// DecodeArray returns the range of color component values in CalGray colorspace.
func (_efac *PdfColorspaceCalGray) DecodeArray() []float64 { return []float64{0.0, 1.0} }

func _dbgee(_cfcd _df.PdfObject, _faaab *PdfReader) (*OutlineDest, error) {
	_ccbbc, _dfggc := _df.GetArray(_cfcd)
	if !_dfggc {
		return nil, _deb.New("\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0064\u0065\u0073t\u0069\u006e\u0061\u0074i\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_bbbdgc := _ccbbc.Len()
	if _bbbdgc < 2 {
		return nil, _c.Errorf("\u0069n\u0076\u0061l\u0069\u0064\u0020\u006fu\u0074\u006c\u0069n\u0065\u0020\u0064\u0065\u0073\u0074\u0069\u006e\u0061ti\u006f\u006e\u0020a\u0072\u0072a\u0079\u0020\u006c\u0065\u006e\u0067t\u0068\u003a \u0025\u0064", _bbbdgc)
	}
	_bggf := &OutlineDest{Mode: "\u0046\u0069\u0074"}
	_abebag := _ccbbc.Get(0)
	if _ddfgc, _bdfd := _df.GetIndirect(_abebag); _bdfd {
		if _, _facbf, _cgbgd := _faaab.PageFromIndirectObject(_ddfgc); _cgbgd == nil {
			_bggf.Page = int64(_facbf - 1)
		} else {
			_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020g\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u002b\u0076", _ddfgc)
		}
		_bggf.PageObj = _ddfgc
	} else if _defgb, _fccec := _df.GetIntVal(_abebag); _fccec {
		if _defgb >= 0 && _defgb < len(_faaab.PageList) {
			_bggf.PageObj = _faaab.PageList[_defgb].GetPageAsIndirectObject()
		} else {
			_bcd.Log.Debug("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064", _defgb)
		}
		_bggf.Page = int64(_defgb)
	} else {
		return nil, _c.Errorf("\u0069\u006eva\u006c\u0069\u0064 \u006f\u0075\u0074\u006cine\u0020de\u0073\u0074\u0069\u006e\u0061\u0074\u0069on\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0054", _abebag)
	}
	_efdca, _dfggc := _df.GetNameVal(_ccbbc.Get(1))
	if !_dfggc {
		_bcd.Log.Debug("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006fn\u0020\u006d\u0061\u0067\u006e\u0069\u0066\u0069\u0063\u0061\u0074i\u006f\u006e\u0020\u006d\u006f\u0064\u0065\u003a\u0020\u0025\u0076", _ccbbc.Get(1))
		return _bggf, nil
	}
	switch _efdca {
	case "\u0046\u0069\u0074", "\u0046\u0069\u0074\u0042":
	case "\u0046\u0069\u0074\u0048", "\u0046\u0069\u0074B\u0048":
		if _bbbdgc > 2 {
			_bggf.Y, _ = _df.GetNumberAsFloat(_df.TraceToDirectObject(_ccbbc.Get(2)))
		}
	case "\u0046\u0069\u0074\u0056", "\u0046\u0069\u0074B\u0056":
		if _bbbdgc > 2 {
			_bggf.X, _ = _df.GetNumberAsFloat(_df.TraceToDirectObject(_ccbbc.Get(2)))
		}
	case "\u0058\u0059\u005a":
		if _bbbdgc > 4 {
			_bggf.X, _ = _df.GetNumberAsFloat(_df.TraceToDirectObject(_ccbbc.Get(2)))
			_bggf.Y, _ = _df.GetNumberAsFloat(_df.TraceToDirectObject(_ccbbc.Get(3)))
			_bggf.Zoom, _ = _df.GetNumberAsFloat(_df.TraceToDirectObject(_ccbbc.Get(4)))
		}
	default:
		_efdca = "\u0046\u0069\u0074"
	}
	_bggf.Mode = _efdca
	return _bggf, nil
}

// HasFontByName checks whether a font is defined by the specified keyName.
func (_fgacg *PdfPageResources) HasFontByName(keyName _df.PdfObjectName) bool {
	_, _fcbb := _fgacg.GetFontByName(keyName)
	return _fcbb
}

func _ddfaee() _fa.Time { _gcdec.Lock(); defer _gcdec.Unlock(); return _eebfd }

// Permissions specify a permissions dictionary (PDF 1.5).
// (Section 12.8.4, Table 258 - Entries in a permissions dictionary p. 477 in PDF32000_2008).
type Permissions struct {
	DocMDP *PdfSignature
	_abddf *_df.PdfObjectDictionary
}

// SetPdfAuthor sets the Author attribute of the output PDF.
func SetPdfAuthor(author string) { _gcdec.Lock(); defer _gcdec.Unlock(); _geabeg = author }

// ImageToRGB converts CalRGB colorspace image to RGB and returns the result.
func (_gdce *PdfColorspaceCalRGB) ImageToRGB(img Image) (Image, error) {
	_bcgef := _aff.NewReader(img.getBase())
	_bebe := _bge.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, nil, nil)
	_bccd := _aff.NewWriter(_bebe)
	_fcdaa := _faf.Pow(2, float64(img.BitsPerComponent)) - 1
	_cbegg := make([]uint32, 3)
	var (
		_daef                                        error
		_efacb, _dgedd, _fdeb, _egca, _bbccd, _dfade float64
	)
	for {
		_daef = _bcgef.ReadSamples(_cbegg)
		if _daef == _bdd.EOF {
			break
		} else if _daef != nil {
			return img, _daef
		}
		_efacb = float64(_cbegg[0]) / _fcdaa
		_dgedd = float64(_cbegg[1]) / _fcdaa
		_fdeb = float64(_cbegg[2]) / _fcdaa
		_egca = _gdce.Matrix[0]*_faf.Pow(_efacb, _gdce.Gamma[0]) + _gdce.Matrix[3]*_faf.Pow(_dgedd, _gdce.Gamma[1]) + _gdce.Matrix[6]*_faf.Pow(_fdeb, _gdce.Gamma[2])
		_bbccd = _gdce.Matrix[1]*_faf.Pow(_efacb, _gdce.Gamma[0]) + _gdce.Matrix[4]*_faf.Pow(_dgedd, _gdce.Gamma[1]) + _gdce.Matrix[7]*_faf.Pow(_fdeb, _gdce.Gamma[2])
		_dfade = _gdce.Matrix[2]*_faf.Pow(_efacb, _gdce.Gamma[0]) + _gdce.Matrix[5]*_faf.Pow(_dgedd, _gdce.Gamma[1]) + _gdce.Matrix[8]*_faf.Pow(_fdeb, _gdce.Gamma[2])
		_efacb = 3.240479*_egca + -1.537150*_bbccd + -0.498535*_dfade
		_dgedd = -0.969256*_egca + 1.875992*_bbccd + 0.041556*_dfade
		_fdeb = 0.055648*_egca + -0.204043*_bbccd + 1.057311*_dfade
		_efacb = _faf.Min(_faf.Max(_efacb, 0), 1.0)
		_dgedd = _faf.Min(_faf.Max(_dgedd, 0), 1.0)
		_fdeb = _faf.Min(_faf.Max(_fdeb, 0), 1.0)
		_cbegg[0] = uint32(_efacb * _fcdaa)
		_cbegg[1] = uint32(_dgedd * _fcdaa)
		_cbegg[2] = uint32(_fdeb * _fcdaa)
		if _daef = _bccd.WriteSamples(_cbegg); _daef != nil {
			return img, _daef
		}
	}
	return _agbg(&_bebe), nil
}

// GenerateHashMaps generates DSS hashmaps for Certificates, OCSPs and CRLs to make sure they are unique.
func (_aefd *DSS) GenerateHashMaps() error {
	_bdgcd, _efcb := _aefd.generateHashMap(_aefd.Certs)
	if _efcb != nil {
		return _efcb
	}
	_egdgc, _efcb := _aefd.generateHashMap(_aefd.OCSPs)
	if _efcb != nil {
		return _efcb
	}
	_bbdd, _efcb := _aefd.generateHashMap(_aefd.CRLs)
	if _efcb != nil {
		return _efcb
	}
	_aefd._cdeb = _bdgcd
	_aefd._fgdg = _egdgc
	_aefd._fcba = _bbdd
	return nil
}

func (_ccge *PdfReader) loadPerms() (*Permissions, error) {
	if _gacad := _ccge._afbaf.Get("\u0050\u0065\u0072m\u0073"); _gacad != nil {
		if _dfaef, _cbcfe := _df.GetDict(_gacad); _cbcfe {
			_cabf := _dfaef.Get("\u0044\u006f\u0063\u004d\u0044\u0050")
			if _cabf == nil {
				return nil, nil
			}
			if _eceggf, _dggdb := _df.GetIndirect(_cabf); _dggdb {
				_aeff, _cbfac := _ccge.newPdfSignatureFromIndirect(_eceggf)
				if _cbfac != nil {
					return nil, _cbfac
				}
				return NewPermissions(_aeff), nil
			}
			return nil, _c.Errorf("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0044\u006f\u0063M\u0044\u0050\u0020\u0065nt\u0072\u0079")
		}
		return nil, _c.Errorf("\u0069\u006e\u0076\u0061li\u0064\u0020\u0050\u0065\u0072\u006d\u0073\u0020\u0065\u006e\u0074\u0072\u0079")
	}
	return nil, nil
}

// SetOpenAction sets the OpenAction in the PDF catalog.
// The value shall be either an array defining a destination (12.3.2 "Destinations" PDF32000_2008),
// or an action dictionary representing an action (12.6 "Actions" PDF32000_2008).
func (_bdede *PdfWriter) SetOpenAction(dest _df.PdfObject) error {
	if dest == nil || _df.IsNullObject(dest) {
		return nil
	}
	_bdede._gdee.Set("\u004f\u0070\u0065\u006e\u0041\u0063\u0074\u0069\u006f\u006e", dest)
	return _bdede.addObjects(dest)
}

// String returns the name of the colorspace (DeviceN).
func (_cecb *PdfColorspaceDeviceN) String() string { return "\u0044e\u0076\u0069\u0063\u0065\u004e" }

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element in
// range 0-1.
func (_dfde *PdfColorspaceCalGray) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_fafg, _cffg := _df.GetNumbersAsFloat(objects)
	if _cffg != nil {
		return nil, _cffg
	}
	return _dfde.ColorFromFloats(_fafg)
}

// ReaderToWriterOpts options used to generate a PdfWriter.
type ReaderToWriterOpts struct {
	SkipAcroForm          bool
	SkipInfo              bool
	SkipNameDictionary    bool
	SkipNamedDests        bool
	SkipOCProperties      bool
	SkipOutlines          bool
	SkipPageLabels        bool
	SkipRotation          bool
	SkipMetadata          bool
	SkipMarkInfo          bool
	SkipViewerPreferences bool
	SkipLanguage          bool
	PageProcessCallback   PageProcessCallback

	// Deprecated: will be removed in v4. Use PageProcessCallback instead.
	PageCallback PageCallback
}

func (_abbd *PdfAnnotation) String() string {
	_dfba := ""
	_dad, _fcc := _abbd.ToPdfObject().(*_df.PdfIndirectObject)
	if _fcc {
		_dfba = _c.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _abbd._afaa, _dad.PdfObject.String())
	}
	return _dfba
}

type pdfCIDFontType0 struct {
	fontCommon
	_gecgb *_df.PdfIndirectObject
	_bafeg _abg.TextEncoder

	// Table 117 – Entries in a CIDFont dictionary (page 269)
	// (Required) Dictionary that defines the character collection of the CIDFont.
	// See Table 116.
	CIDSystemInfo *_df.PdfObjectDictionary

	// Glyph metrics fields (optional).
	DW     _df.PdfObject
	W      _df.PdfObject
	DW2    _df.PdfObject
	W2     _df.PdfObject
	_cbee  map[_abg.CharCode]float64
	_ggbda float64
}

// ReaderOpts defines options for creating PdfReader instances.
type ReaderOpts struct {

	// Password password of the PDF file encryption.
	// Default: empty ("").
	Password string

	// LazyLoad set if the PDF file would be loaded using lazy-loading mode.
	// Default: true.
	LazyLoad bool

	// ComplianceMode set if parsed PDF file should contain meta information for the verifiers of the compliance standards like PDF/A.
	ComplianceMode bool

	// RelaxedMode indicates whether the parser should operate in a relaxed mode, ignoring certain insignificant errors and continuing to parse the PDF file.
	// For example, it skips AcroForm loading errors and proceeds with the rest of the file if no form-related processing is required.
	RelaxedMode bool
}

// ImageToRGB converts an image in CMYK32 colorspace to an RGB image.
func (_fccf *PdfColorspaceDeviceCMYK) ImageToRGB(img Image) (Image, error) {
	_bcd.Log.Trace("\u0043\u004d\u0059\u004b\u0033\u0032\u0020\u002d\u003e\u0020\u0052\u0047\u0042")
	_bcd.Log.Trace("I\u006d\u0061\u0067\u0065\u0020\u0042P\u0043\u003a\u0020\u0025\u0064\u002c \u0043\u006f\u006c\u006f\u0072\u0020\u0063o\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073\u003a\u0020%\u0064", img.BitsPerComponent, img.ColorComponents)
	_bcd.Log.Trace("\u004c\u0065\u006e \u0064\u0061\u0074\u0061\u003a\u0020\u0025\u0064", len(img.Data))
	_bcd.Log.Trace("H\u0065\u0069\u0067\u0068t:\u0020%\u0064\u002c\u0020\u0057\u0069d\u0074\u0068\u003a\u0020\u0025\u0064", img.Height, img.Width)
	_dbbgf, _ecgc := _bge.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._gebab, img._bebgb)
	if _ecgc != nil {
		return Image{}, _ecgc
	}
	_efg, _ecgc := _bge.NRGBAConverter.Convert(_dbbgf)
	if _ecgc != nil {
		return Image{}, _ecgc
	}
	return _agbg(_efg.Base()), nil
}

// Flags returns the field flags for the field accounting for any inherited flags.
func (_cgcc *PdfField) Flags() FieldFlag {
	var _ffdg FieldFlag
	_fged, _cfebe := _cgcc.inherit(func(_cfaba *PdfField) bool {
		if _cfaba.Ff != nil {
			_ffdg = FieldFlag(*_cfaba.Ff)
			return true
		}
		return false
	})
	if _cfebe != nil {
		_bcd.Log.Debug("\u0045\u0072\u0072o\u0072\u0020\u0065\u0076\u0061\u006c\u0075\u0061\u0074\u0069\u006e\u0067\u0020\u0066\u006c\u0061\u0067\u0073\u0020\u0076\u0069\u0061\u0020\u0069\u006e\u0068\u0065\u0072\u0069t\u0061\u006e\u0063\u0065\u003a\u0020\u0025\u0076", _cfebe)
	}
	if !_fged {
		_bcd.Log.Trace("N\u006f\u0020\u0066\u0069\u0065\u006cd\u0020\u0066\u006c\u0061\u0067\u0073 \u0066\u006f\u0075\u006e\u0064\u0020\u002d \u0061\u0073\u0073\u0075\u006d\u0065\u0020\u0063\u006c\u0065a\u0072")
	}
	return _ffdg
}

// AddCustomInfo adds a custom info into document info dictionary.
func (_cgdg *PdfInfo) AddCustomInfo(name string, value string) error {
	if _cgdg._bcec == nil {
		_cgdg._bcec = _df.MakeDict()
	}
	if _, _fdbfcf := _ffcfc[name]; _fdbfcf {
		return _c.Errorf("\u0063\u0061\u006e\u006e\u006ft\u0020\u0075\u0073\u0065\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u0072\u0064 \u0069\u006e\u0066\u006f\u0020\u006b\u0065\u0079\u0020\u0025\u0073\u0020\u0061\u0073\u0020\u0063\u0075\u0073\u0074\u006f\u006d\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u006b\u0065y", name)
	}
	_cgdg._bcec.SetIfNotNil(*_df.MakeName(name), _df.MakeString(value))
	return nil
}

// PdfAnnotationPolygon represents Polygon annotations.
// (Section 12.5.6.9).
type PdfAnnotationPolygon struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Vertices _df.PdfObject
	LE       _df.PdfObject
	BS       _df.PdfObject
	IC       _df.PdfObject
	BE       _df.PdfObject
	IT       _df.PdfObject
	Measure  _df.PdfObject
}

const (
	ButtonTypeCheckbox ButtonType = iota
	ButtonTypePush     ButtonType = iota
	ButtonTypeRadio    ButtonType = iota
)

// NewPdfTransformParamsDocMDP create a PdfTransformParamsDocMDP with the specific permissions.
func NewPdfTransformParamsDocMDP(permission _ffc.DocMDPPermission) *PdfTransformParamsDocMDP {
	return &PdfTransformParamsDocMDP{Type: _df.MakeName("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"), P: _df.MakeInteger(int64(permission)), V: _df.MakeName("\u0031\u002e\u0032")}
}

// PdfActionImportData represents a importData action.
type PdfActionImportData struct {
	*PdfAction
	F *PdfFilespec
}

// ToPdfObject returns a stream object.
func (_caaab *XObjectImage) ToPdfObject() _df.PdfObject {
	_bgdec := _caaab._fgdgd
	if _caaab._acgbea {
		return _bgdec
	}
	_bfffc := _bgdec.PdfObjectDictionary
	if _caaab.Filter != nil {
		_bfffc = _caaab.Filter.MakeStreamDict()
		_bgdec.PdfObjectDictionary = _bfffc
	}
	_bfffc.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0058O\u0062\u006a\u0065\u0063\u0074"))
	_bfffc.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _df.MakeName("\u0049\u006d\u0061g\u0065"))
	_bfffc.Set("\u0057\u0069\u0064t\u0068", _df.MakeInteger(*(_caaab.Width)))
	_bfffc.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _df.MakeInteger(*(_caaab.Height)))
	if _caaab.BitsPerComponent != nil {
		_bfffc.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _df.MakeInteger(*(_caaab.BitsPerComponent)))
	}
	if _caaab.ColorSpace != nil {
		_bfffc.SetIfNotNil("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _caaab.ColorSpace.ToPdfObject())
	}
	_bfffc.SetIfNotNil("\u0049\u006e\u0074\u0065\u006e\u0074", _caaab.Intent)
	_bfffc.SetIfNotNil("\u0049m\u0061\u0067\u0065\u004d\u0061\u0073k", _caaab.ImageMask)
	_bfffc.SetIfNotNil("\u004d\u0061\u0073\u006b", _caaab.Mask)
	_dbdda := _bfffc.Get("\u0044\u0065\u0063\u006f\u0064\u0065") != nil
	if _caaab.Decode == nil && _dbdda {
		_bfffc.Remove("\u0044\u0065\u0063\u006f\u0064\u0065")
	} else if _caaab.Decode != nil {
		_bfffc.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _caaab.Decode)
	}
	_bfffc.SetIfNotNil("I\u006e\u0074\u0065\u0072\u0070\u006f\u006c\u0061\u0074\u0065", _caaab.Interpolate)
	_bfffc.SetIfNotNil("\u0041\u006c\u0074e\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0073", _caaab.Alternatives)
	_bfffc.SetIfNotNil("\u0053\u004d\u0061s\u006b", _caaab.SMask)
	_bfffc.SetIfNotNil("S\u004d\u0061\u0073\u006b\u0049\u006e\u0044\u0061\u0074\u0061", _caaab.SMaskInData)
	_bfffc.SetIfNotNil("\u004d\u0061\u0074t\u0065", _caaab.Matte)
	_bfffc.SetIfNotNil("\u004e\u0061\u006d\u0065", _caaab.Name)
	_bfffc.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _caaab.StructParent)
	_bfffc.SetIfNotNil("\u0049\u0044", _caaab.ID)
	_bfffc.SetIfNotNil("\u004f\u0050\u0049", _caaab.OPI)
	_bfffc.SetIfNotNil("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _caaab.Metadata)
	_bfffc.SetIfNotNil("\u004f\u0043", _caaab.OC)
	_bfffc.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _df.MakeInteger(int64(len(_caaab.Stream))))
	_bgdec.Stream = _caaab.Stream
	_caaab._acgbea = true
	return _bgdec
}

// GetContainingPdfObject returns the container of the pattern object (indirect object).
func (_gedbf *PdfPattern) GetContainingPdfObject() _df.PdfObject { return _gedbf._cbce }

func (_ceb *PdfReader) newPdfAnnotationFromIndirectObject(_afce *_df.PdfIndirectObject) (*PdfAnnotation, error) {
	_bggb, _ffa := _afce.PdfObject.(*_df.PdfObjectDictionary)
	if !_ffa {
		return nil, _c.Errorf("\u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0069\u006e\u0064\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006ft\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if model := _ceb._ceggc.GetModelFromPrimitive(_bggb); model != nil {
		_bbab, _gebc := model.(*PdfAnnotation)
		if !_gebc {
			return nil, _c.Errorf("\u0063\u0061\u0063\u0068\u0065\u0064 \u006d\u006f\u0064\u0065\u006c\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0050D\u0046\u0020\u0061\u006e\u006e\u006f\u0074a\u0074\u0069\u006f\u006e")
		}
		return _bbab, nil
	}
	_fcag := &PdfAnnotation{}
	_fcag._bfde = _afce
	_ceb._ceggc.Register(_bggb, _fcag)
	if _agd := _bggb.Get("\u0054\u0079\u0070\u0065"); _agd != nil {
		_eagd, _fdbb := _agd.(*_df.PdfObjectName)
		if !_fdbb {
			_bcd.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _agd)
		} else {
			if *_eagd != "\u0041\u006e\u006eo\u0074" {
				_bcd.Log.Trace("\u0055\u006e\u0073\u0075\u0073\u0070\u0065\u0063\u0074\u0065d\u0020\u0054\u0079\u0070\u0065\u0020\u0021=\u0020\u0041\u006e\u006e\u006f\u0074\u0020\u0028\u0025\u0073\u0029", *_eagd)
			}
		}
	}
	if _cfae := _bggb.Get("\u0052\u0065\u0063\u0074"); _cfae != nil {
		_fcag.Rect = _cfae
	}
	if _bee := _bggb.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"); _bee != nil {
		_fcag.Contents = _bee
	}
	if _dda := _bggb.Get("\u0050"); _dda != nil {
		_fcag.P = _dda
	}
	if _dff := _bggb.Get("\u004e\u004d"); _dff != nil {
		_fcag.NM = _dff
	}
	if _fbg := _bggb.Get("\u004d"); _fbg != nil {
		_fcag.M = _fbg
	}
	if _cce := _bggb.Get("\u0046"); _cce != nil {
		_fcag.F = _cce
	}
	if _feg := _bggb.Get("\u0041\u0050"); _feg != nil {
		_fcag.AP = _feg
	}
	if _dec := _bggb.Get("\u0041\u0053"); _dec != nil {
		_fcag.AS = _dec
	}
	if _gdga := _bggb.Get("\u0042\u006f\u0072\u0064\u0065\u0072"); _gdga != nil {
		_fcag.Border = _gdga
	}
	if _agc := _bggb.Get("\u0043"); _agc != nil {
		_fcag.C = _agc
	}
	if _fba := _bggb.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074"); _fba != nil {
		_fcag.StructParent = _fba
	}
	if _ccec := _bggb.Get("\u004f\u0043"); _ccec != nil {
		_fcag.OC = _ccec
	}
	_gebcg := _bggb.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")
	if _gebcg == nil {
		_bcd.Log.Debug("\u0057\u0041\u0052\u004e\u0049\u004e\u0047:\u0020\u0043\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079 \u0069s\u0073\u0075\u0065\u0020\u002d\u0020a\u006e\u006e\u006f\u0074\u0061\u0074\u0069o\u006e\u0020\u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u002d\u0020\u0061\u0073\u0073u\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0073\u0075\u0062\u0074\u0079p\u0065")
		_fcag._afaa = nil
		return _fcag, nil
	}
	_agdg, _cdf := _gebcg.(*_df.PdfObjectName)
	if !_cdf {
		_bcd.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0053\u0075\u0062ty\u0070\u0065\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065 !\u003d\u0020n\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _gebcg)
		return nil, _c.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d n\u0061\u006d\u0065 \u0028%\u0054\u0029", _gebcg)
	}
	switch *_agdg {
	case "\u0054\u0065\u0078\u0074":
		_gaa, _bfge := _ceb.newPdfAnnotationTextFromDict(_bggb)
		if _bfge != nil {
			return nil, _bfge
		}
		_gaa.PdfAnnotation = _fcag
		_fcag._afaa = _gaa
		return _fcag, nil
	case "\u004c\u0069\u006e\u006b":
		_cgeb, _ecfa := _ceb.newPdfAnnotationLinkFromDict(_bggb)
		if _ecfa != nil {
			return nil, _ecfa
		}
		_cgeb.PdfAnnotation = _fcag
		_fcag._afaa = _cgeb
		return _fcag, nil
	case "\u0046\u0072\u0065\u0065\u0054\u0065\u0078\u0074":
		_ffbe, _ffcf := _ceb.newPdfAnnotationFreeTextFromDict(_bggb)
		if _ffcf != nil {
			return nil, _ffcf
		}
		_ffbe.PdfAnnotation = _fcag
		_fcag._afaa = _ffbe
		return _fcag, nil
	case "\u004c\u0069\u006e\u0065":
		_cdb, _bdgb := _ceb.newPdfAnnotationLineFromDict(_bggb)
		if _bdgb != nil {
			return nil, _bdgb
		}
		_cdb.PdfAnnotation = _fcag
		_fcag._afaa = _cdb
		_bcd.Log.Trace("\u004c\u0049\u004e\u0045\u0020\u0041N\u004e\u004f\u0054\u0041\u0054\u0049\u004f\u004e\u003a\u0020\u0061\u006e\u006eo\u0074\u0020\u0028\u0025\u0054\u0029\u003a \u0025\u002b\u0076\u000a", _fcag, _fcag)
		_bcd.Log.Trace("\u004c\u0049\u004eE\u0020\u0041\u004e\u004eO\u0054\u0041\u0054\u0049\u004f\u004e\u003a \u0063\u0074\u0078\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u002b\u0076\u000a", _cdb, _cdb)
		_bcd.Log.Trace("\u004c\u0049\u004e\u0045\u0020\u0041\u004e\u004e\u004f\u0054\u0041\u0054\u0049\u004f\u004e\u0020\u004d\u0061\u0072\u006b\u0075\u0070\u003a\u0020c\u0074\u0078\u0020\u0028\u0025T\u0029\u003a \u0025\u002b\u0076\u000a", _cdb.PdfAnnotationMarkup, _cdb.PdfAnnotationMarkup)
		return _fcag, nil
	case "\u0053\u0071\u0075\u0061\u0072\u0065":
		_bgf, _beef := _ceb.newPdfAnnotationSquareFromDict(_bggb)
		if _beef != nil {
			return nil, _beef
		}
		_bgf.PdfAnnotation = _fcag
		_fcag._afaa = _bgf
		return _fcag, nil
	case "\u0043\u0069\u0072\u0063\u006c\u0065":
		_fcef, _baa := _ceb.newPdfAnnotationCircleFromDict(_bggb)
		if _baa != nil {
			return nil, _baa
		}
		_fcef.PdfAnnotation = _fcag
		_fcag._afaa = _fcef
		return _fcag, nil
	case "\u0050o\u006c\u0079\u0067\u006f\u006e":
		_cdg, _baea := _ceb.newPdfAnnotationPolygonFromDict(_bggb)
		if _baea != nil {
			return nil, _baea
		}
		_cdg.PdfAnnotation = _fcag
		_fcag._afaa = _cdg
		return _fcag, nil
	case "\u0050\u006f\u006c\u0079\u004c\u0069\u006e\u0065":
		_dcf, _ddee := _ceb.newPdfAnnotationPolyLineFromDict(_bggb)
		if _ddee != nil {
			return nil, _ddee
		}
		_dcf.PdfAnnotation = _fcag
		_fcag._afaa = _dcf
		return _fcag, nil
	case "\u0048i\u0067\u0068\u006c\u0069\u0067\u0068t":
		_ffg, _eebf := _ceb.newPdfAnnotationHighlightFromDict(_bggb)
		if _eebf != nil {
			return nil, _eebf
		}
		_ffg.PdfAnnotation = _fcag
		_fcag._afaa = _ffg
		return _fcag, nil
	case "\u0055n\u0064\u0065\u0072\u006c\u0069\u006ee":
		_dbcb, _eceg := _ceb.newPdfAnnotationUnderlineFromDict(_bggb)
		if _eceg != nil {
			return nil, _eceg
		}
		_dbcb.PdfAnnotation = _fcag
		_fcag._afaa = _dbcb
		return _fcag, nil
	case "\u0053\u0071\u0075\u0069\u0067\u0067\u006c\u0079":
		_fgg, _fegb := _ceb.newPdfAnnotationSquigglyFromDict(_bggb)
		if _fegb != nil {
			return nil, _fegb
		}
		_fgg.PdfAnnotation = _fcag
		_fcag._afaa = _fgg
		return _fcag, nil
	case "\u0053t\u0072\u0069\u006b\u0065\u004f\u0075t":
		_fcae, _gead := _ceb.newPdfAnnotationStrikeOut(_bggb)
		if _gead != nil {
			return nil, _gead
		}
		_fcae.PdfAnnotation = _fcag
		_fcag._afaa = _fcae
		return _fcag, nil
	case "\u0043\u0061\u0072e\u0074":
		_gdaa, _cgeba := _ceb.newPdfAnnotationCaretFromDict(_bggb)
		if _cgeba != nil {
			return nil, _cgeba
		}
		_gdaa.PdfAnnotation = _fcag
		_fcag._afaa = _gdaa
		return _fcag, nil
	case "\u0053\u0074\u0061m\u0070":
		_cae, _dbce := _ceb.newPdfAnnotationStampFromDict(_bggb)
		if _dbce != nil {
			return nil, _dbce
		}
		_cae.PdfAnnotation = _fcag
		_fcag._afaa = _cae
		return _fcag, nil
	case "\u0049\u006e\u006b":
		_dfae, _cbdb := _ceb.newPdfAnnotationInkFromDict(_bggb)
		if _cbdb != nil {
			return nil, _cbdb
		}
		_dfae.PdfAnnotation = _fcag
		_fcag._afaa = _dfae
		return _fcag, nil
	case "\u0050\u006f\u0070u\u0070":
		_agf, _eefa := _ceb.newPdfAnnotationPopupFromDict(_bggb)
		if _eefa != nil {
			return nil, _eefa
		}
		_agf.PdfAnnotation = _fcag
		_fcag._afaa = _agf
		return _fcag, nil
	case "\u0046\u0069\u006c\u0065\u0041\u0074\u0074\u0061\u0063h\u006d\u0065\u006e\u0074":
		_abd, _adb := _ceb.newPdfAnnotationFileAttachmentFromDict(_bggb)
		if _adb != nil {
			return nil, _adb
		}
		_abd.PdfAnnotation = _fcag
		_fcag._afaa = _abd
		return _fcag, nil
	case "\u0053\u006f\u0075n\u0064":
		_cedg, _ade := _ceb.newPdfAnnotationSoundFromDict(_bggb)
		if _ade != nil {
			return nil, _ade
		}
		_cedg.PdfAnnotation = _fcag
		_fcag._afaa = _cedg
		return _fcag, nil
	case "\u0052i\u0063\u0068\u004d\u0065\u0064\u0069a":
		_bgd, _eed := _ceb.newPdfAnnotationRichMediaFromDict(_bggb)
		if _eed != nil {
			return nil, _eed
		}
		_bgd.PdfAnnotation = _fcag
		_fcag._afaa = _bgd
		return _fcag, nil
	case "\u004d\u006f\u0076i\u0065":
		_dfdc, _dcfa := _ceb.newPdfAnnotationMovieFromDict(_bggb)
		if _dcfa != nil {
			return nil, _dcfa
		}
		_dfdc.PdfAnnotation = _fcag
		_fcag._afaa = _dfdc
		return _fcag, nil
	case "\u0053\u0063\u0072\u0065\u0065\u006e":
		_edag, _agda := _ceb.newPdfAnnotationScreenFromDict(_bggb)
		if _agda != nil {
			return nil, _agda
		}
		_edag.PdfAnnotation = _fcag
		_fcag._afaa = _edag
		return _fcag, nil
	case "\u0057\u0069\u0064\u0067\u0065\u0074":
		_gfda, _cdbg := _ceb.newPdfAnnotationWidgetFromDict(_bggb)
		if _cdbg != nil {
			return nil, _cdbg
		}
		_gfda.PdfAnnotation = _fcag
		_fcag._afaa = _gfda
		return _fcag, nil
	case "P\u0072\u0069\u006e\u0074\u0065\u0072\u004d\u0061\u0072\u006b":
		_gae, _ccg := _ceb.newPdfAnnotationPrinterMarkFromDict(_bggb)
		if _ccg != nil {
			return nil, _ccg
		}
		_gae.PdfAnnotation = _fcag
		_fcag._afaa = _gae
		return _fcag, nil
	case "\u0054r\u0061\u0070\u004e\u0065\u0074":
		_dfe, _ffac := _ceb.newPdfAnnotationTrapNetFromDict(_bggb)
		if _ffac != nil {
			return nil, _ffac
		}
		_dfe.PdfAnnotation = _fcag
		_fcag._afaa = _dfe
		return _fcag, nil
	case "\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k":
		_dfec, _geada := _ceb.newPdfAnnotationWatermarkFromDict(_bggb)
		if _geada != nil {
			return nil, _geada
		}
		_dfec.PdfAnnotation = _fcag
		_fcag._afaa = _dfec
		return _fcag, nil
	case "\u0033\u0044":
		_abbb, _cgff := _ceb.newPdfAnnotation3DFromDict(_bggb)
		if _cgff != nil {
			return nil, _cgff
		}
		_abbb.PdfAnnotation = _fcag
		_fcag._afaa = _abbb
		return _fcag, nil
	case "\u0050\u0072\u006f\u006a\u0065\u0063\u0074\u0069\u006f\u006e":
		_bac, _dbcd := _ceb.newPdfAnnotationProjectionFromDict(_bggb)
		if _dbcd != nil {
			return nil, _dbcd
		}
		_bac.PdfAnnotation = _fcag
		_fcag._afaa = _bac
		return _fcag, nil
	case "\u0052\u0065\u0064\u0061\u0063\u0074":
		_adga, _ddg := _ceb.newPdfAnnotationRedactFromDict(_bggb)
		if _ddg != nil {
			return nil, _ddg
		}
		_adga.PdfAnnotation = _fcag
		_fcag._afaa = _adga
		return _fcag, nil
	}
	_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020a\u006e\u006e\u006f\u0074\u0061t\u0069\u006fn\u003a\u0020\u0025\u0073", *_agdg)
	return nil, nil
}

func _dfdde(_ggfbe *PdfPage) {
	_ebafe := _abc.GetLicenseKey()
	if _ebafe != nil && _ebafe.IsLicensed() {
		return
	}
	_feffe := _df.PdfObjectName("\u0055\u0046\u0031")
	if !_ggfbe.Resources.HasFontByName(_feffe) {
		_ggfbe.Resources.SetFontByName(_feffe, DefaultFont().ToPdfObject())
	}
	var _dbaba []string
	_dbaba = append(_dbaba, "\u0071")
	_dbaba = append(_dbaba, "\u0042\u0054")
	_dbaba = append(_dbaba, _c.Sprintf("\u002f%\u0073\u0020\u0031\u0034\u0020\u0054f", _feffe.String()))
	_dbaba = append(_dbaba, "\u0031\u0020\u0030\u0020\u0030\u0020\u0072\u0067")
	_dbaba = append(_dbaba, "\u0031\u0030\u0020\u0031\u0030\u0020\u0054\u0064")
	_agaa := "\u0055\u006e\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0064\u0020\u0055\u006e\u0069\u0044o\u0063\u0020\u002d\u0020\u0047\u0065\u0074\u0020\u0061\u0020\u006c\u0069\u0063e\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073:/\u002f\u0075\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f"
	_dbaba = append(_dbaba, _c.Sprintf("\u0028%\u0073\u0029\u0020\u0054\u006a", _agaa))
	_dbaba = append(_dbaba, "\u0045\u0054")
	_dbaba = append(_dbaba, "\u0051")
	_aece := _gc.Join(_dbaba, "\u000a")
	_ggfbe.AddContentStreamByString(_aece)
	_ggfbe.ToPdfObject()
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element.
func (_fccc *PdfColorspaceSpecialIndexed) ColorFromPdfObjects(objects []_df.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _deb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_affe, _ddbb := _df.GetNumbersAsFloat(objects)
	if _ddbb != nil {
		return nil, _ddbb
	}
	return _fccc.ColorFromFloats(_affe)
}

func (_bbdfe *PdfReader) traverseObjectData(_dbgg _df.PdfObject) error {
	return _df.ResolveReferencesDeep(_dbgg, _bbdfe._eebc)
}

// GetContainingPdfObject returns the container of the outline item (indirect object).
func (_cccde *PdfOutlineItem) GetContainingPdfObject() _df.PdfObject { return _cccde._acfea }

const (
	FieldFlagClear             FieldFlag = 0
	FieldFlagReadOnly          FieldFlag = 1
	FieldFlagRequired          FieldFlag = (1 << 1)
	FieldFlagNoExport          FieldFlag = (2 << 1)
	FieldFlagNoToggleToOff     FieldFlag = (1 << 14)
	FieldFlagRadio             FieldFlag = (1 << 15)
	FieldFlagPushbutton        FieldFlag = (1 << 16)
	FieldFlagRadiosInUnision   FieldFlag = (1 << 25)
	FieldFlagMultiline         FieldFlag = (1 << 12)
	FieldFlagPassword          FieldFlag = (1 << 13)
	FieldFlagFileSelect        FieldFlag = (1 << 20)
	FieldFlagDoNotScroll       FieldFlag = (1 << 23)
	FieldFlagComb              FieldFlag = (1 << 24)
	FieldFlagRichText          FieldFlag = (1 << 26)
	FieldFlagDoNotSpellCheck   FieldFlag = (1 << 22)
	FieldFlagCombo             FieldFlag = (1 << 17)
	FieldFlagEdit              FieldFlag = (1 << 18)
	FieldFlagSort              FieldFlag = (1 << 19)
	FieldFlagMultiSelect       FieldFlag = (1 << 21)
	FieldFlagCommitOnSelChange FieldFlag = (1 << 27)
)

// GenerateXObjectName generates an unused XObject name that can be used for
// adding new XObjects. Uses format XObj1, XObj2, ...
func (_egcbb *PdfPageResources) GenerateXObjectName() _df.PdfObjectName {
	_caaefe := 1
	for {
		_fbbbd := _df.MakeName(_c.Sprintf("\u0058\u004f\u0062\u006a\u0025\u0064", _caaefe))
		if !_egcbb.HasXObjectByName(*_fbbbd) {
			return *_fbbbd
		}
		_caaefe++
	}
}

func (_caeba *PdfReader) newPdfSignatureFromIndirect(_fggga *_df.PdfIndirectObject) (*PdfSignature, error) {
	_eddec, _ccbbf := _fggga.PdfObject.(*_df.PdfObjectDictionary)
	if !_ccbbf {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006ft\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
		return nil, ErrTypeCheck
	}
	if _ddbbf, _fafed := _caeba._ceggc.GetModelFromPrimitive(_fggga).(*PdfSignature); _fafed {
		return _ddbbf, nil
	}
	_egbfe := &PdfSignature{}
	_egbfe._aeddbb = _fggga
	_egbfe.Type, _ = _df.GetName(_eddec.Get("\u0054\u0079\u0070\u0065"))
	_egbfe.Filter, _ccbbf = _df.GetName(_eddec.Get("\u0046\u0069\u006c\u0074\u0065\u0072"))
	if !_ccbbf {
		_bcd.Log.Error("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053i\u0067\u006e\u0061\u0074\u0075r\u0065\u0020\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	_egbfe.SubFilter, _ = _df.GetName(_eddec.Get("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r"))
	_egbfe.Contents, _ccbbf = _df.GetString(_eddec.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"))
	if !_ccbbf {
		_bcd.Log.Error("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006et\u0065\u006e\u0074\u0073\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	if _gccff, _cbgcg := _df.GetArray(_eddec.Get("\u0052e\u0066\u0065\u0072\u0065\u006e\u0063e")); _cbgcg {
		_egbfe.Reference = _df.MakeArray()
		for _, _fbcag := range _gccff.Elements() {
			_bgfec, _ddgged := _df.GetDict(_fbcag)
			if !_ddgged {
				_bcd.Log.Error("\u0045\u0052R\u004f\u0052\u003a\u0020R\u0065\u0066e\u0072\u0065\u006e\u0063\u0065\u0020\u0063\u006fn\u0074\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0061\u0074\u0065\u0064")
				return nil, ErrInvalidAttribute
			}
			_cbbda, _bfga := _caeba.newPdfSignatureReferenceFromDict(_bgfec)
			if _bfga != nil {
				return nil, _bfga
			}
			_egbfe.Reference.Append(_cbbda.ToPdfObject())
		}
	}
	_egbfe.Cert = _eddec.Get("\u0043\u0065\u0072\u0074")
	_egbfe.ByteRange, _ = _df.GetArray(_eddec.Get("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e"))
	_egbfe.Changes, _ = _df.GetArray(_eddec.Get("\u0043h\u0061\u006e\u0067\u0065\u0073"))
	_egbfe.Name, _ = _df.GetString(_eddec.Get("\u004e\u0061\u006d\u0065"))
	_egbfe.M, _ = _df.GetString(_eddec.Get("\u004d"))
	_egbfe.Location, _ = _df.GetString(_eddec.Get("\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e"))
	_egbfe.Reason, _ = _df.GetString(_eddec.Get("\u0052\u0065\u0061\u0073\u006f\u006e"))
	_egbfe.ContactInfo, _ = _df.GetString(_eddec.Get("C\u006f\u006e\u0074\u0061\u0063\u0074\u0049\u006e\u0066\u006f"))
	_egbfe.R, _ = _df.GetInt(_eddec.Get("\u0052"))
	_egbfe.V, _ = _df.GetInt(_eddec.Get("\u0056"))
	_egbfe.PropBuild, _ = _df.GetDict(_eddec.Get("\u0050\u0072\u006f\u0070\u005f\u0042\u0075\u0069\u006c\u0064"))
	_egbfe.PropAuthTime, _ = _df.GetInt(_eddec.Get("\u0050\u0072\u006f\u0070\u005f\u0041\u0075\u0074\u0068\u0054\u0069\u006d\u0065"))
	_egbfe.PropAuthType, _ = _df.GetName(_eddec.Get("\u0050\u0072\u006f\u0070\u005f\u0041\u0075\u0074\u0068\u0054\u0079\u0070\u0065"))
	_caeba._ceggc.Register(_fggga, _egbfe)
	return _egbfe, nil
}

// PdfActionSubmitForm represents a submitForm action.
type PdfActionSubmitForm struct {
	*PdfAction
	F      *PdfFilespec
	Fields _df.PdfObject
	Flags  _df.PdfObject
}

// ToPdfObject implements interface PdfModel.
func (_dged *PdfAnnotationProjection) ToPdfObject() _df.PdfObject {
	_dged.PdfAnnotation.ToPdfObject()
	_eebd := _dged._bfde
	_gfgd := _eebd.PdfObject.(*_df.PdfObjectDictionary)
	_dged.PdfAnnotationMarkup.appendToPdfDictionary(_gfgd)
	return _eebd
}

// NewPdfOutputIntentFromPdfObject creates a new PdfOutputIntent from the input core.PdfObject.
func NewPdfOutputIntentFromPdfObject(object _df.PdfObject) (*PdfOutputIntent, error) {
	_ecafg := &PdfOutputIntent{}
	if _cfgbg := _ecafg.ParsePdfObject(object); _cfgbg != nil {
		return nil, _cfgbg
	}
	return _ecafg, nil
}

// ToPdfObject converts the font to a PDF representation.
func (_dabdb *pdfFontType0) ToPdfObject() _df.PdfObject {
	if _dabdb._ddfda == nil {
		_dabdb._ddfda = &_df.PdfIndirectObject{}
	}
	_gfga := _dabdb.baseFields().asPdfObjectDictionary("\u0054\u0079\u0070e\u0030")
	_dabdb._ddfda.PdfObject = _gfga
	if _dabdb.Encoding != nil {
		_gfga.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _dabdb.Encoding)
	} else if _dabdb._gdbg != nil {
		_gfga.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _dabdb._gdbg.ToPdfObject())
	}
	if _dabdb.DescendantFont != nil {
		_gfga.Set("\u0044e\u0073c\u0065\u006e\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073", _df.MakeArray(_dabdb.DescendantFont.ToPdfObject()))
	}
	return _dabdb._ddfda
}

// PdfColorspaceLab is a L*, a*, b* 3 component colorspace.
type PdfColorspaceLab struct {
	WhitePoint []float64
	BlackPoint []float64
	Range      []float64
	_dced      *_df.PdfIndirectObject
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_edce *PdfColorspaceSpecialSeparation) ToPdfObject() _df.PdfObject {
	_eegaa := _df.MakeArray(_df.MakeName("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e"))
	_eegaa.Append(_edce.ColorantName)
	_eegaa.Append(_edce.AlternateSpace.ToPdfObject())
	_eegaa.Append(_edce.TintTransform.ToPdfObject())
	if _edce._afad != nil {
		_edce._afad.PdfObject = _eegaa
		return _edce._afad
	}
	return _eegaa
}

// SetNumCopies sets the value of the numCopies.
func (_bgabg *ViewerPreferences) SetNumCopies(numCopies int) { _bgabg._edded = numCopies }

func (_cfdf *PdfField) inherit(_ffdeg func(*PdfField) bool) (bool, error) {
	_aedfg := map[*PdfField]bool{}
	_dega := false
	_bbbc := _cfdf
	for _bbbc != nil {
		if _, _gfgdf := _aedfg[_bbbc]; _gfgdf {
			return false, _deb.New("\u0072\u0065\u0063\u0075rs\u0069\u0076\u0065\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c")
		}
		_aafge := _ffdeg(_bbbc)
		if _aafge {
			_dega = true
			break
		}
		_aedfg[_bbbc] = true
		_bbbc = _bbbc.Parent
	}
	return _dega, nil
}

// ToInteger convert to an integer format.
func (_adff *PdfColorDeviceCMYK) ToInteger(bits int) [4]uint32 {
	_eaef := _faf.Pow(2, float64(bits)) - 1
	return [4]uint32{uint32(_eaef * _adff.C()), uint32(_eaef * _adff.M()), uint32(_eaef * _adff.Y()), uint32(_eaef * _adff.K())}
}

func _egad(_bgbff *_df.PdfObjectDictionary) (*PdfShadingPattern, error) {
	_ffgdd := &PdfShadingPattern{}
	_bgbe := _bgbff.Get("\u0053h\u0061\u0064\u0069\u006e\u0067")
	if _bgbe == nil {
		_bcd.Log.Debug("\u0053h\u0061d\u0069\u006e\u0067\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_aggfc, _bdgf := _abfbgf(_bgbe)
	if _bdgf != nil {
		_bcd.Log.Debug("\u0045r\u0072\u006f\u0072\u0020l\u006f\u0061\u0064\u0069\u006eg\u0020s\u0068a\u0064\u0069\u006e\u0067\u003a\u0020\u0025v", _bdgf)
		return nil, _bdgf
	}
	_ffgdd.Shading = _aggfc
	if _bbefd := _bgbff.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _bbefd != nil {
		_ffff, _dccb := _bbefd.(*_df.PdfObjectArray)
		if !_dccb {
			_bcd.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _bbefd)
			return nil, _df.ErrTypeError
		}
		_ffgdd.Matrix = _ffff
	}
	if _efbe := _bgbff.Get("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e"); _efbe != nil {
		_ffgdd.ExtGState = _efbe
	}
	return _ffgdd, nil
}

func (_ebfe *PdfReader) newPdfAnnotationSquigglyFromDict(_gga *_df.PdfObjectDictionary) (*PdfAnnotationSquiggly, error) {
	_bgfd := PdfAnnotationSquiggly{}
	_cfd, _gfed := _ebfe.newPdfAnnotationMarkupFromDict(_gga)
	if _gfed != nil {
		return nil, _gfed
	}
	_bgfd.PdfAnnotationMarkup = _cfd
	_bgfd.QuadPoints = _gga.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_bgfd, nil
}

func (_gdbca *PdfAcroForm) signatureFields() []*PdfFieldSignature {
	var _fegdf []*PdfFieldSignature
	for _, _aeggb := range _gdbca.AllFields() {
		switch _edbbde := _aeggb.GetContext().(type) {
		case *PdfFieldSignature:
			_bceca := _edbbde
			_fegdf = append(_fegdf, _bceca)
		}
	}
	return _fegdf
}

func (_cbec *PdfReader) newPdfActionFromIndirectObject(_ebd *_df.PdfIndirectObject) (*PdfAction, error) {
	_fddb, _efe := _ebd.PdfObject.(*_df.PdfObjectDictionary)
	if !_efe {
		return nil, _c.Errorf("\u0061\u0063\u0074\u0069\u006f\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u006e\u006f\u0074 \u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if model := _cbec._ceggc.GetModelFromPrimitive(_fddb); model != nil {
		_acfd, _acc := model.(*PdfAction)
		if !_acc {
			return nil, _c.Errorf("\u0063\u0061c\u0068\u0065\u0064\u0020\u006d\u006f\u0064\u0065\u006c\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0050\u0044\u0046\u0020\u0061\u0063ti\u006f\u006e")
		}
		return _acfd, nil
	}
	_dbbd := &PdfAction{}
	_dbbd._gcf = _ebd
	_cbec._ceggc.Register(_fddb, _dbbd)
	if _bfdb := _fddb.Get("\u0054\u0079\u0070\u0065"); _bfdb != nil {
		_acd, _gdb := _bfdb.(*_df.PdfObjectName)
		if !_gdb {
			_bcd.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _bfdb)
		} else {
			if *_acd != "\u0041\u0063\u0074\u0069\u006f\u006e" {
				_bcd.Log.Trace("\u0055\u006e\u0073u\u0073\u0070\u0065\u0063t\u0065\u0064\u0020\u0054\u0079\u0070\u0065 \u0021\u003d\u0020\u0041\u0063\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029", *_acd)
			}
			_dbbd.Type = _acd
		}
	}
	if _eefd := _fddb.Get("\u004e\u0065\u0078\u0074"); _eefd != nil {
		_dbbd.Next = _eefd
	}
	if _ccbf := _fddb.Get("\u0053"); _ccbf != nil {
		_dbbd.S = _ccbf
	}
	_ead, _cgfb := _dbbd.S.(*_df.PdfObjectName)
	if !_cgfb {
		_bcd.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _dbbd.S)
		return nil, _c.Errorf("\u0069\u006e\u0076al\u0069\u0064\u0020\u0053\u0020\u006f\u0062\u006a\u0065c\u0074 \u0074y\u0070e\u0020\u0021\u003d\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _dbbd.S)
	}
	_egff := PdfActionType(_ead.String())
	switch _egff {
	case ActionTypeGoTo:
		_ffbd, _ced := _cbec.newPdfActionGotoFromDict(_fddb)
		if _ced != nil {
			return nil, _ced
		}
		_ffbd.PdfAction = _dbbd
		_dbbd._aab = _ffbd
		return _dbbd, nil
	case ActionTypeGoToR:
		_geb, _gbe := _cbec.newPdfActionGotoRFromDict(_fddb)
		if _gbe != nil {
			return nil, _gbe
		}
		_geb.PdfAction = _dbbd
		_dbbd._aab = _geb
		return _dbbd, nil
	case ActionTypeGoToE:
		_aaa, _dgfc := _cbec.newPdfActionGotoEFromDict(_fddb)
		if _dgfc != nil {
			return nil, _dgfc
		}
		_aaa.PdfAction = _dbbd
		_dbbd._aab = _aaa
		return _dbbd, nil
	case ActionTypeLaunch:
		_bef, _dga := _cbec.newPdfActionLaunchFromDict(_fddb)
		if _dga != nil {
			return nil, _dga
		}
		_bef.PdfAction = _dbbd
		_dbbd._aab = _bef
		return _dbbd, nil
	case ActionTypeThread:
		_dbf, _dd := _cbec.newPdfActionThreadFromDict(_fddb)
		if _dd != nil {
			return nil, _dd
		}
		_dbf.PdfAction = _dbbd
		_dbbd._aab = _dbf
		return _dbbd, nil
	case ActionTypeURI:
		_adc, _gbag := _cbec.newPdfActionURIFromDict(_fddb)
		if _gbag != nil {
			return nil, _gbag
		}
		_adc.PdfAction = _dbbd
		_dbbd._aab = _adc
		return _dbbd, nil
	case ActionTypeSound:
		_aadb, _ec := _cbec.newPdfActionSoundFromDict(_fddb)
		if _ec != nil {
			return nil, _ec
		}
		_aadb.PdfAction = _dbbd
		_dbbd._aab = _aadb
		return _dbbd, nil
	case ActionTypeMovie:
		_abgg, _dce := _cbec.newPdfActionMovieFromDict(_fddb)
		if _dce != nil {
			return nil, _dce
		}
		_abgg.PdfAction = _dbbd
		_dbbd._aab = _abgg
		return _dbbd, nil
	case ActionTypeHide:
		_fcf, _cfa := _cbec.newPdfActionHideFromDict(_fddb)
		if _cfa != nil {
			return nil, _cfa
		}
		_fcf.PdfAction = _dbbd
		_dbbd._aab = _fcf
		return _dbbd, nil
	case ActionTypeNamed:
		_edgd, _ded := _cbec.newPdfActionNamedFromDict(_fddb)
		if _ded != nil {
			return nil, _ded
		}
		_edgd.PdfAction = _dbbd
		_dbbd._aab = _edgd
		return _dbbd, nil
	case ActionTypeSubmitForm:
		_cba, _dgea := _cbec.newPdfActionSubmitFormFromDict(_fddb)
		if _dgea != nil {
			return nil, _dgea
		}
		_cba.PdfAction = _dbbd
		_dbbd._aab = _cba
		return _dbbd, nil
	case ActionTypeResetForm:
		_ddc, _acb := _cbec.newPdfActionResetFormFromDict(_fddb)
		if _acb != nil {
			return nil, _acb
		}
		_ddc.PdfAction = _dbbd
		_dbbd._aab = _ddc
		return _dbbd, nil
	case ActionTypeImportData:
		_ecf, _cbeg := _cbec.newPdfActionImportDataFromDict(_fddb)
		if _cbeg != nil {
			return nil, _cbeg
		}
		_ecf.PdfAction = _dbbd
		_dbbd._aab = _ecf
		return _dbbd, nil
	case ActionTypeSetOCGState:
		_eeg, _cbc := _cbec.newPdfActionSetOCGStateFromDict(_fddb)
		if _cbc != nil {
			return nil, _cbc
		}
		_eeg.PdfAction = _dbbd
		_dbbd._aab = _eeg
		return _dbbd, nil
	case ActionTypeRendition:
		_aac, _cbf := _cbec.newPdfActionRenditionFromDict(_fddb)
		if _cbf != nil {
			return nil, _cbf
		}
		_aac.PdfAction = _dbbd
		_dbbd._aab = _aac
		return _dbbd, nil
	case ActionTypeTrans:
		_gca, _bdb := _cbec.newPdfActionTransFromDict(_fddb)
		if _bdb != nil {
			return nil, _bdb
		}
		_gca.PdfAction = _dbbd
		_dbbd._aab = _gca
		return _dbbd, nil
	case ActionTypeGoTo3DView:
		_dfb, _eab := _cbec.newPdfActionGoTo3DViewFromDict(_fddb)
		if _eab != nil {
			return nil, _eab
		}
		_dfb.PdfAction = _dbbd
		_dbbd._aab = _dfb
		return _dbbd, nil
	case ActionTypeJavaScript:
		_ebdf, _adg := _cbec.newPdfActionJavaScriptFromDict(_fddb)
		if _adg != nil {
			return nil, _adg
		}
		_ebdf.PdfAction = _dbbd
		_dbbd._aab = _ebdf
		return _dbbd, nil
	}
	_bcd.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u0067\u006e\u006f\u0072\u0069\u006eg\u0020u\u006ek\u006eo\u0077\u006e\u0020\u0061\u0063\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0073", _egff)
	return nil, nil
}

// SignatureHandlerDocMDPParams describe the specific parameters for the SignatureHandlerEx
// These parameters describe how to check the difference between revisions.
// Revisions of the document get from the PdfParser.
type SignatureHandlerDocMDPParams struct {
	Parser     *_df.PdfParser
	DiffPolicy _ffc.DiffPolicy
}

// B returns the value of the B component of the color.
func (_fedce *PdfColorCalRGB) B() float64 { return _fedce[1] }

// PdfActionSetOCGState represents a SetOCGState action.
type PdfActionSetOCGState struct {
	*PdfAction
	State      _df.PdfObject
	PreserveRB _df.PdfObject
}

// GetPageAsIndirectObject returns the page as a dictionary within an PdfIndirectObject.
func (_abcba *PdfPage) GetPageAsIndirectObject() *_df.PdfIndirectObject { return _abcba._gcced }

func (_fea *PdfAnnotationMarkup) appendToPdfDictionary(_gfb *_df.PdfObjectDictionary) {
	_gfb.SetIfNotNil("\u0054", _fea.T)
	if _fea.Popup != nil {
		_gfb.Set("\u0050\u006f\u0070u\u0070", _fea.Popup.ToPdfObject())
	}
	_gfb.SetIfNotNil("\u0043\u0041", _fea.CA)
	_gfb.SetIfNotNil("\u0052\u0043", _fea.RC)
	_gfb.SetIfNotNil("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _fea.CreationDate)
	_gfb.SetIfNotNil("\u0049\u0052\u0054", _fea.IRT)
	_gfb.SetIfNotNil("\u0053\u0075\u0062\u006a", _fea.Subj)
	_gfb.SetIfNotNil("\u0052\u0054", _fea.RT)
	_gfb.SetIfNotNil("\u0049\u0054", _fea.IT)
	_gfb.SetIfNotNil("\u0045\u0078\u0044\u0061\u0074\u0061", _fea.ExData)
}

func (_cdadd *PdfWriter) writeOutputIntents() error {
	if len(_cdadd._dfbgg) == 0 {
		return nil
	}
	_edcge := make([]_df.PdfObject, len(_cdadd._dfbgg))
	for _ceabc, _abcfc := range _cdadd._dfbgg {
		_cedfae := _abcfc.ToPdfObject()
		_edcge[_ceabc] = _df.MakeIndirectObject(_cedfae)
	}
	_affgc := _df.MakeIndirectObject(_df.MakeArray(_edcge...))
	_cdadd._gdee.Set("\u004f\u0075\u0074\u0070\u0075\u0074\u0049\u006e\u0074\u0065\u006e\u0074\u0073", _affgc)
	if _egaa := _cdadd.addObjects(_affgc); _egaa != nil {
		return _egaa
	}
	return nil
}

// ToPdfObject returns the PDF representation of the pattern.
func (_gded *PdfPattern) ToPdfObject() _df.PdfObject {
	_ceecf := _gded.getDict()
	_ceecf.Set("\u0054\u0079\u0070\u0065", _df.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e"))
	_ceecf.Set("P\u0061\u0074\u0074\u0065\u0072\u006e\u0054\u0079\u0070\u0065", _df.MakeInteger(_gded.PatternType))
	return _gded._cbce
}

// StructTreeRoot represents the structure tree root dictionary.
// Reference: PDF documentation chapter 14.7 Logical Structure, table 322.
type StructTreeRoot struct {
	K                 []*KDict
	IDTree            *IDTree
	ParentTree        *_df.PdfObjectDictionary
	ParentTreeNextKey int64
	RoleMap           _df.PdfObject
	ClassMap          *_df.PdfObjectDictionary
	_cgea             *_df.PdfIndirectObject
	_baeee            []_aa.UUID
}

func (_fbgaf *PdfAcroForm) filteredFields(_efga FieldFilterFunc, _fbcdb bool) []*PdfField {
	if _fbgaf == nil {
		return nil
	}
	return _ebacbe(_fbgaf.Fields, _efga, _fbcdb)
}

// GetCapHeight returns the CapHeight of the font `descriptor`.
func (_efaf *PdfFontDescriptor) GetCapHeight() (float64, error) {
	return _df.GetNumberAsFloat(_efaf.CapHeight)
}

// NewOutlineItem returns a new outline item instance.
func NewOutlineItem(title string, dest OutlineDest) *OutlineItem {
	return &OutlineItem{Title: title, Dest: dest}
}

// IDTree represents the ID tree dictionary where the format of the content
// is using Name Trees as described in chapter 7.9.6.
type IDTree struct {

	// Limits shall be an array of two strings, that shall specify the (lexically) least and greatest keys included in the Names array.
	Limits *_df.PdfObjectArray

	// Names shall be an array of the form
	//
	// [ key1 value1 key2 value2 … keyn valuen]
	//
	// where each keyi shall be a string and the corresponding valuei shall be the object
	// associated with that key. The keys shall be sorted in lexical order, as described below.
	Names *_df.PdfObjectArray

	// Kids Shall be an array of indirect references to the immediate children of this node.
	Kids []*IDTree
}
